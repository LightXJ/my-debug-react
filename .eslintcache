[{"/Users/wxj/locality/my-debug/src/index.js":"1","/Users/wxj/locality/my-debug/src/App.js":"2","/Users/wxj/locality/my-debug/src/reportWebVitals.js":"3","/Users/wxj/locality/my-debug/src/react/packages/react-dom/index.js":"4","/Users/wxj/locality/my-debug/src/react/packages/react/index.js":"5","/Users/wxj/locality/my-debug/src/react/packages/react/src/React.js":"6","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOM.js":"7","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactBaseClasses.js":"8","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactChildren.js":"9","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactCreateRef.js":"10","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactContext.js":"11","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactElement.js":"12","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactLazy.js":"13","/Users/wxj/locality/my-debug/src/react/packages/react/src/forwardRef.js":"14","/Users/wxj/locality/my-debug/src/react/packages/react/src/memo.js":"15","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactElementValidator.js":"16","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactHooks.js":"17","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactSharedInternals.js":"18","/Users/wxj/locality/my-debug/src/react/packages/react/src/withComponentStack.js":"19","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactVersion.js":"20","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactFeatureFlags.js":"21","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactSymbols.js":"22","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMComponentTree.js":"23","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactPortal.js":"24","/Users/wxj/locality/my-debug/src/react/packages/shared/ExecutionEnvironment.js":"25","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactInstanceMap.js":"26","/Users/wxj/locality/my-debug/src/react/packages/shared/getComponentName.js":"27","/Users/wxj/locality/my-debug/src/react/packages/shared/warningWithoutStack.js":"28","/Users/wxj/locality/my-debug/src/react/packages/shared/lowPriorityWarning.js":"29","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/checkReact.js":"30","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/HTMLNodeType.js":"31","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/DOMProperty.js":"32","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMClientInjection.js":"33","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMComponent.js":"34","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/ReactDOMEventListener.js":"35","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/inline.dom.js":"36","/Users/wxj/locality/my-debug/src/react/packages/shared/invariant.js":"37","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactSharedInternals.js":"38","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactNoopUpdateQueue.js":"39","/Users/wxj/locality/my-debug/src/react/packages/shared/warning.js":"40","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactDebugCurrentFrame.js":"41","/Users/wxj/locality/my-debug/src/react/packages/shared/isValidElementType.js":"42","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactCurrentOwner.js":"43","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactCurrentDispatcher.js":"44","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactWorkTags.js":"45","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactLazyComponent.js":"46","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/DOMEventPluginOrder.js":"47","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/DOMPropertyOperations.js":"48","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMSelect.js":"49","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMOption.js":"50","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMInput.js":"51","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/setInnerHTML.js":"52","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMTextarea.js":"53","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/inputValueTracking.js":"54","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/setTextContent.js":"55","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/CSSPropertyOperations.js":"56","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/assertValidProps.js":"57","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/isCustomComponent.js":"58","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/possibleStandardNames.js":"59","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/DOMNamespaces.js":"60","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactDOMInvalidARIAHook.js":"61","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactDOMNullInputValuePropHook.js":"62","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/ChangeEventPlugin.js":"63","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SelectEventPlugin.js":"64","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/checkPassiveEvents.js":"65","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/EventListener.js":"66","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventTarget.js":"67","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/reflection.js":"68","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/EnterLeaveEventPlugin.js":"69","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/BeforeInputEventPlugin.js":"70","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SimpleEventPlugin.js":"71","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/DOMEventResponderSystem.js":"72","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/DOMTopLevelEventTypes.js":"73","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactCurrentFiber.js":"74","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/ReactBrowserEventEmitter.js":"75","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactDOMUnknownPropertyHook.js":"76","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberReconciler.js":"77","/Users/wxj/locality/my-debug/src/react/packages/shared/describeComponentFrame.js":"78","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/sanitizeURL.js":"79","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactControlledValuePropTypes.js":"80","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ToStringValue.js":"81","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/createMicrosoftUnsafeLocalFunction.js":"82","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/CSSShorthandProperty.js":"83","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/dangerousStyleValue.js":"84","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/hyphenateStyleName.js":"85","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/warnValidStyle.js":"86","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/validAriaProperties.js":"87","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/voidElementTags.js":"88","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/isEventSupported.js":"89","/Users/wxj/locality/my-debug/src/react/packages/shared/isTextInputElement.js":"90","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/getActiveElement.js":"91","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactInputSelection.js":"92","/Users/wxj/locality/my-debug/src/react/packages/shared/shallowEqual.js":"93","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberTreeReflection.js":"94","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticMouseEvent.js":"95","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticPointerEvent.js":"96","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/FallbackCompositionState.js":"97","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticFocusEvent.js":"98","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticDragEvent.js":"99","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticTouchEvent.js":"100","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticKeyboardEvent.js":"101","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticWheelEvent.js":"102","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventCharCode.js":"103","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactErrorUtils.js":"104","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getVendorPrefixedEventName.js":"105","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberContext.js":"106","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberRoot.js":"107","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberDevToolsHook.js":"108","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberScheduler.js":"109","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberInstrumentation.js":"110","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactTypeOfMode.js":"111","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactUpdateQueue.js":"112","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberExpirationTime.js":"113","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticCompositionEvent.js":"114","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticAnimationEvent.js":"115","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticInputEvent.js":"116","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticClipboardEvent.js":"117","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticUIEvent.js":"118","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticTransitionEvent.js":"119","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHostConfig.js":"120","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/CSSProperty.js":"121","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/omittedCloseTags.js":"122","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMSelection.js":"123","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactSideEffectTags.js":"124","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventModifierState.js":"125","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventKey.js":"126","/Users/wxj/locality/my-debug/src/react/packages/shared/invokeGuardedCallbackImpl.js":"127","/Users/wxj/locality/my-debug/src/react/packages/shared/objectIs.js":"128","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberStack.js":"129","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactDebugFiberPerf.js":"130","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiber.js":"131","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberNewContext.js":"132","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/maxSigned31BitInt.js":"133","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/SchedulerWithReactIntegration.js":"134","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberScheduler.new.js":"135","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberScheduler.old.js":"136","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/getNodeForCharacterOffset.js":"137","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberCompleteWork.js":"138","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberUnwindWork.js":"139","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberCommitWork.js":"140","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactCapturedValue.js":"141","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactProfilerTimer.js":"142","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactStrictModeWarnings.js":"143","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHooks.js":"144","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberPendingPriority.js":"145","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberBeginWork.js":"146","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHostContext.js":"147","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberSuspenseComponent.js":"148","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberErrorLogger.js":"149","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberLazyComponent.js":"150","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHydrationContext.js":"151","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactHookEffectTags.js":"152","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactChildFiber.js":"153","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberClassComponent.js":"154","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberErrorDialog.js":"155","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/forks/ReactFiberHostConfig.dom.js":"156","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMHostConfig.js":"157","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/validateDOMNesting.js":"158","/Users/wxj/locality/my-debug/src/react/packages/shared/HostConfigWithNoPersistence.js":"159","/Users/wxj/locality/my-debug/src/react/packages/events/ReactGenericBatching.js":"160","/Users/wxj/locality/my-debug/src/react/packages/events/ReactControlledComponent.js":"161","/Users/wxj/locality/my-debug/src/react/packages/events/EventPluginHub.js":"162","/Users/wxj/locality/my-debug/src/react/packages/events/EventBatching.js":"163","/Users/wxj/locality/my-debug/src/react/packages/events/EventPropagators.js":"164","/Users/wxj/locality/my-debug/src/react/packages/events/EventPluginRegistry.js":"165","/Users/wxj/locality/my-debug/src/react/packages/events/EventPluginUtils.js":"166","/Users/wxj/locality/my-debug/src/react/packages/events/accumulateInto.js":"167","/Users/wxj/locality/my-debug/src/react/packages/events/forEachAccumulated.js":"168","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactTreeTraversal.js":"169","/Users/wxj/locality/my-debug/src/react/packages/events/EventSystemFlags.js":"170","/Users/wxj/locality/my-debug/src/react/packages/events/SyntheticEvent.js":"171","/Users/wxj/locality/my-debug/src/react/packages/events/TopLevelEventTypes.js":"172"},{"size":219,"mtime":1609406651943,"results":"173","hashOfConfig":"174"},{"size":555,"mtime":1609404726788,"results":"175","hashOfConfig":"174"},{"size":362,"mtime":1609402153493,"results":"176","hashOfConfig":"177"},{"size":424,"mtime":1609406978431,"results":"178","hashOfConfig":"174"},{"size":405,"mtime":1609406978316,"results":"179","hashOfConfig":"174"},{"size":2585,"mtime":1609406978320,"results":"180","hashOfConfig":"174"},{"size":29418,"mtime":1609407139391,"results":"181","hashOfConfig":"174"},{"size":6278,"mtime":1609406978321,"results":"182","hashOfConfig":"174"},{"size":15291,"mtime":1609406978322,"results":"183","hashOfConfig":"174"},{"size":741,"mtime":1609406978324,"results":"184","hashOfConfig":"174"},{"size":4812,"mtime":1609406978323,"results":"185","hashOfConfig":"174"},{"size":11716,"mtime":1609406978328,"results":"186","hashOfConfig":"174"},{"size":2133,"mtime":1609406978330,"results":"187","hashOfConfig":"174"},{"size":2104,"mtime":1609406978366,"results":"188","hashOfConfig":"174"},{"size":1035,"mtime":1609406978367,"results":"189","hashOfConfig":"174"},{"size":10958,"mtime":1609406978329,"results":"190","hashOfConfig":"174"},{"size":4468,"mtime":1609406978329,"results":"191","hashOfConfig":"174"},{"size":1480,"mtime":1609406978332,"results":"192","hashOfConfig":"174"},{"size":1249,"mtime":1609406978368,"results":"193","hashOfConfig":"174"},{"size":296,"mtime":1609406979054,"results":"194","hashOfConfig":"174"},{"size":2691,"mtime":1609406979045,"results":"195","hashOfConfig":"174"},{"size":2434,"mtime":1609406979051,"results":"196","hashOfConfig":"174"},{"size":2426,"mtime":1609406978556,"results":"197","hashOfConfig":"174"},{"size":746,"mtime":1609406979048,"results":"198","hashOfConfig":"174"},{"size":331,"mtime":1609406979036,"results":"199","hashOfConfig":"174"},{"size":1054,"mtime":1609406979046,"results":"200","hashOfConfig":"174"},{"size":3403,"mtime":1609406979087,"results":"201","hashOfConfig":"174"},{"size":1799,"mtime":1609406979098,"results":"202","hashOfConfig":"174"},{"size":1677,"mtime":1609406979093,"results":"203","hashOfConfig":"174"},{"size":405,"mtime":1609406978658,"results":"204","hashOfConfig":"174"},{"size":435,"mtime":1609406978653,"results":"205","hashOfConfig":"174"},{"size":15392,"mtime":1609406978652,"results":"206","hashOfConfig":"174"},{"size":1461,"mtime":1609407139391,"results":"207","hashOfConfig":"174"},{"size":46568,"mtime":1609407139391,"results":"208","hashOfConfig":"174"},{"size":8498,"mtime":1609407139568,"results":"209","hashOfConfig":"174"},{"size":360,"mtime":1609406978816,"results":"210","hashOfConfig":"174"},{"size":784,"mtime":1609406979088,"results":"211","hashOfConfig":"174"},{"size":791,"mtime":1609407069020,"results":"212","hashOfConfig":"174"},{"size":3890,"mtime":1609406978331,"results":"213","hashOfConfig":"174"},{"size":1054,"mtime":1609406979097,"results":"214","hashOfConfig":"174"},{"size":1494,"mtime":1609406978327,"results":"215","hashOfConfig":"174"},{"size":1352,"mtime":1609406979092,"results":"216","hashOfConfig":"174"},{"size":574,"mtime":1609406978326,"results":"217","hashOfConfig":"174"},{"size":492,"mtime":1609406978325,"results":"218","hashOfConfig":"174"},{"size":1237,"mtime":1609406979055,"results":"219","hashOfConfig":"174"},{"size":869,"mtime":1609406979047,"results":"220","hashOfConfig":"174"},{"size":932,"mtime":1609406978577,"results":"221","hashOfConfig":"174"},{"size":5729,"mtime":1609406978552,"results":"222","hashOfConfig":"174"},{"size":6442,"mtime":1609406978561,"results":"223","hashOfConfig":"174"},{"size":2909,"mtime":1609406978560,"results":"224","hashOfConfig":"174"},{"size":15813,"mtime":1609406978559,"results":"225","hashOfConfig":"174"},{"size":1329,"mtime":1609406978571,"results":"226","hashOfConfig":"174"},{"size":5821,"mtime":1609406978563,"results":"227","hashOfConfig":"174"},{"size":3410,"mtime":1609406978571,"results":"228","hashOfConfig":"174"},{"size":904,"mtime":1609406978572,"results":"229","hashOfConfig":"174"},{"size":4924,"mtime":1609406978649,"results":"230","hashOfConfig":"174"},{"size":2398,"mtime":1609406978657,"results":"231","hashOfConfig":"174"},{"size":972,"mtime":1609406978662,"results":"232","hashOfConfig":"174"},{"size":13483,"mtime":1609406978664,"results":"233","hashOfConfig":"174"},{"size":1194,"mtime":1609406978650,"results":"234","hashOfConfig":"174"},{"size":3290,"mtime":1609406978655,"results":"235","hashOfConfig":"174"},{"size":1064,"mtime":1609406978656,"results":"236","hashOfConfig":"174"},{"size":9492,"mtime":1609407139569,"results":"237","hashOfConfig":"174"},{"size":6610,"mtime":1609407139569,"results":"238","hashOfConfig":"174"},{"size":982,"mtime":1609406978611,"results":"239","hashOfConfig":"174"},{"size":805,"mtime":1609406978580,"results":"240","hashOfConfig":"174"},{"size":1033,"mtime":1609406978617,"results":"241","hashOfConfig":"174"},{"size":265,"mtime":1609406978829,"results":"242","hashOfConfig":"174"},{"size":4252,"mtime":1609407139568,"results":"243","hashOfConfig":"174"},{"size":14751,"mtime":1609407139569,"results":"244","hashOfConfig":"174"},{"size":12991,"mtime":1609407139568,"results":"245","hashOfConfig":"174"},{"size":13348,"mtime":1609407139569,"results":"246","hashOfConfig":"174"},{"size":8200,"mtime":1609407139568,"results":"247","hashOfConfig":"174"},{"size":2624,"mtime":1609406978835,"results":"248","hashOfConfig":"174"},{"size":6932,"mtime":1609407139569,"results":"249","hashOfConfig":"174"},{"size":8976,"mtime":1609407139568,"results":"250","hashOfConfig":"174"},{"size":13932,"mtime":1609406978860,"results":"251","hashOfConfig":"174"},{"size":1163,"mtime":1609406979065,"results":"252","hashOfConfig":"174"},{"size":1935,"mtime":1609406978665,"results":"253","hashOfConfig":"174"},{"size":2195,"mtime":1609406978654,"results":"254","hashOfConfig":"174"},{"size":900,"mtime":1609406978565,"results":"255","hashOfConfig":"174"},{"size":673,"mtime":1609406978659,"results":"256","hashOfConfig":"174"},{"size":5112,"mtime":1609406978650,"results":"257","hashOfConfig":"174"},{"size":1701,"mtime":1609406978660,"results":"258","hashOfConfig":"174"},{"size":823,"mtime":1609406978661,"results":"259","hashOfConfig":"174"},{"size":3231,"mtime":1609406978668,"results":"260","hashOfConfig":"174"},{"size":1461,"mtime":1609406978666,"results":"261","hashOfConfig":"174"},{"size":503,"mtime":1609406978667,"results":"262","hashOfConfig":"174"},{"size":1084,"mtime":1609406978618,"results":"263","hashOfConfig":"174"},{"size":974,"mtime":1609406979089,"results":"264","hashOfConfig":"174"},{"size":494,"mtime":1609406978569,"results":"265","hashOfConfig":"174"},{"size":5785,"mtime":1609406978564,"results":"266","hashOfConfig":"174"},{"size":1164,"mtime":1609406979096,"results":"267","hashOfConfig":"174"},{"size":9247,"mtime":1609406978868,"results":"268","hashOfConfig":"174"},{"size":1731,"mtime":1609406978593,"results":"269","hashOfConfig":"174"},{"size":610,"mtime":1609406978594,"results":"270","hashOfConfig":"174"},{"size":1657,"mtime":1609406978581,"results":"271","hashOfConfig":"174"},{"size":442,"mtime":1609406978590,"results":"272","hashOfConfig":"174"},{"size":447,"mtime":1609406978589,"results":"273","hashOfConfig":"174"},{"size":649,"mtime":1609406978594,"results":"274","hashOfConfig":"174"},{"size":2059,"mtime":1609406978592,"results":"275","hashOfConfig":"174"},{"size":1362,"mtime":1609406978597,"results":"276","hashOfConfig":"174"},{"size":1548,"mtime":1609406978614,"results":"277","hashOfConfig":"174"},{"size":3157,"mtime":1609406979044,"results":"278","hashOfConfig":"174"},{"size":2609,"mtime":1609406978618,"results":"279","hashOfConfig":"174"},{"size":10082,"mtime":1609406978845,"results":"280","hashOfConfig":"174"},{"size":7339,"mtime":1609406978861,"results":"281","hashOfConfig":"174"},{"size":2651,"mtime":1609406978846,"results":"282","hashOfConfig":"174"},{"size":5903,"mtime":1609406978862,"results":"283","hashOfConfig":"174"},{"size":553,"mtime":1609406978854,"results":"284","hashOfConfig":"174"},{"size":372,"mtime":1609406978876,"results":"285","hashOfConfig":"174"},{"size":21594,"mtime":1609406978877,"results":"286","hashOfConfig":"174"},{"size":3837,"mtime":1609406978849,"results":"287","hashOfConfig":"174"},{"size":470,"mtime":1609407139568,"results":"288","hashOfConfig":"174"},{"size":588,"mtime":1609407139392,"results":"289","hashOfConfig":"174"},{"size":478,"mtime":1609407139392,"results":"290","hashOfConfig":"174"},{"size":557,"mtime":1609407139392,"results":"291","hashOfConfig":"174"},{"size":366,"mtime":1609407139568,"results":"292","hashOfConfig":"174"},{"size":602,"mtime":1609407139392,"results":"293","hashOfConfig":"174"},{"size":714,"mtime":1609407032564,"results":"294","hashOfConfig":"174"},{"size":2030,"mtime":1609406978648,"results":"295","hashOfConfig":"174"},{"size":650,"mtime":1609406978663,"results":"296","hashOfConfig":"174"},{"size":5896,"mtime":1609406978562,"results":"297","hashOfConfig":"174"},{"size":1374,"mtime":1609406979050,"results":"298","hashOfConfig":"174"},{"size":1253,"mtime":1609407139568,"results":"299","hashOfConfig":"174"},{"size":2847,"mtime":1609406978615,"results":"300","hashOfConfig":"174"},{"size":9146,"mtime":1609406979089,"results":"301","hashOfConfig":"174"},{"size":555,"mtime":1609406979094,"results":"302","hashOfConfig":"174"},{"size":1767,"mtime":1609406978866,"results":"303","hashOfConfig":"174"},{"size":14689,"mtime":1609406978837,"results":"304","hashOfConfig":"174"},{"size":26531,"mtime":1609406978838,"results":"305","hashOfConfig":"174"},{"size":12656,"mtime":1609406978856,"results":"306","hashOfConfig":"174"},{"size":358,"mtime":1609406978947,"results":"307","hashOfConfig":"174"},{"size":5690,"mtime":1609406978877,"results":"308","hashOfConfig":"174"},{"size":74121,"mtime":1609406978864,"results":"309","hashOfConfig":"174"},{"size":94635,"mtime":1609406978865,"results":"310","hashOfConfig":"174"},{"size":1579,"mtime":1609406978570,"results":"311","hashOfConfig":"174"},{"size":27020,"mtime":1609406978844,"results":"312","hashOfConfig":"174"},{"size":19118,"mtime":1609406978870,"results":"313","hashOfConfig":"174"},{"size":42577,"mtime":1609406978843,"results":"314","hashOfConfig":"174"},{"size":916,"mtime":1609406978831,"results":"315","hashOfConfig":"174"},{"size":1869,"mtime":1609406978872,"results":"316","hashOfConfig":"174"},{"size":12527,"mtime":1609406978873,"results":"317","hashOfConfig":"174"},{"size":54915,"mtime":1609406978851,"results":"318","hashOfConfig":"174"},{"size":9978,"mtime":1609406978859,"results":"319","hashOfConfig":"174"},{"size":77403,"mtime":1609406978839,"results":"320","hashOfConfig":"174"},{"size":4991,"mtime":1609406978853,"results":"321","hashOfConfig":"174"},{"size":861,"mtime":1609406978867,"results":"322","hashOfConfig":"174"},{"size":3553,"mtime":1609406978849,"results":"323","hashOfConfig":"174"},{"size":2619,"mtime":1609406978855,"results":"324","hashOfConfig":"174"},{"size":13128,"mtime":1609406978853,"results":"325","hashOfConfig":"174"},{"size":671,"mtime":1609406978871,"results":"326","hashOfConfig":"174"},{"size":45071,"mtime":1609406978832,"results":"327","hashOfConfig":"174"},{"size":40127,"mtime":1609406978842,"results":"328","hashOfConfig":"174"},{"size":514,"mtime":1609406978847,"results":"329","hashOfConfig":"174"},{"size":259,"mtime":1609406978939,"results":"330","hashOfConfig":"174"},{"size":28767,"mtime":1609406978558,"results":"331","hashOfConfig":"174"},{"size":12451,"mtime":1609406978573,"results":"332","hashOfConfig":"174"},{"size":989,"mtime":1609406979039,"results":"333","hashOfConfig":"174"},{"size":2366,"mtime":1609406978286,"results":"334","hashOfConfig":"174"},{"size":1995,"mtime":1609406978285,"results":"335","hashOfConfig":"174"},{"size":4854,"mtime":1609406978279,"results":"336","hashOfConfig":"174"},{"size":2011,"mtime":1609406978279,"results":"337","hashOfConfig":"174"},{"size":4639,"mtime":1609406978282,"results":"338","hashOfConfig":"174"},{"size":7105,"mtime":1609406978280,"results":"339","hashOfConfig":"174"},{"size":5544,"mtime":1609406978281,"results":"340","hashOfConfig":"174"},{"size":1492,"mtime":1609406978299,"results":"341","hashOfConfig":"174"},{"size":915,"mtime":1609406978299,"results":"342","hashOfConfig":"174"},{"size":3443,"mtime":1609406979052,"results":"343","hashOfConfig":"174"},{"size":438,"mtime":1609406978283,"results":"344","hashOfConfig":"174"},{"size":9238,"mtime":1609406978292,"results":"345","hashOfConfig":"174"},{"size":978,"mtime":1609406978293,"results":"346","hashOfConfig":"174"},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},"uhx2xk",{"filePath":"350","messages":"351","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"352","messages":"353","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1hoo5y5",{"filePath":"354","messages":"355","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"356","messages":"357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"358","messages":"359","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"360","messages":"361","errorCount":8,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"362","messages":"363","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"364","usedDeprecatedRules":"349"},{"filePath":"365","messages":"366","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"367","usedDeprecatedRules":"349"},{"filePath":"368","messages":"369","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"370","messages":"371","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"372","messages":"373","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"374","usedDeprecatedRules":"349"},{"filePath":"375","messages":"376","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"377","messages":"378","errorCount":3,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"379","usedDeprecatedRules":"349"},{"filePath":"380","messages":"381","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"382","usedDeprecatedRules":"349"},{"filePath":"383","messages":"384","errorCount":5,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"385","usedDeprecatedRules":"349"},{"filePath":"386","messages":"387","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"388","messages":"389","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"390","messages":"391","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"392","messages":"393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"396","messages":"397","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"398","usedDeprecatedRules":"349"},{"filePath":"399","messages":"400","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"401","messages":"402","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"403","messages":"404","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"405","messages":"406","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"407","messages":"408","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"409","messages":"410","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"411","usedDeprecatedRules":"349"},{"filePath":"412","messages":"413","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"414","usedDeprecatedRules":"349"},{"filePath":"415","messages":"416","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"417","messages":"418","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"419","messages":"420","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"421","usedDeprecatedRules":"349"},{"filePath":"422","messages":"423","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"424","messages":"425","errorCount":16,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"426","messages":"427","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"428","messages":"429","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"430","messages":"431","errorCount":8,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"432","usedDeprecatedRules":"349"},{"filePath":"433","messages":"434","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"435","usedDeprecatedRules":"349"},{"filePath":"436","messages":"437","errorCount":9,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"438","usedDeprecatedRules":"349"},{"filePath":"439","messages":"440","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"441","usedDeprecatedRules":"349"},{"filePath":"442","messages":"443","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"444","messages":"445","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"446","messages":"447","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"448","messages":"449","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"450","messages":"451","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"452","messages":"453","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"454","messages":"455","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"456","messages":"457","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"458","messages":"459","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"460","usedDeprecatedRules":"349"},{"filePath":"461","messages":"462","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"463","messages":"464","errorCount":6,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"465","usedDeprecatedRules":"349"},{"filePath":"466","messages":"467","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"468","messages":"469","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"470","usedDeprecatedRules":"349"},{"filePath":"471","messages":"472","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"473","usedDeprecatedRules":"349"},{"filePath":"474","messages":"475","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"476","messages":"477","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"478","usedDeprecatedRules":"349"},{"filePath":"479","messages":"480","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"481","messages":"482","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"483","messages":"484","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"485","messages":"486","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"487","messages":"488","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"489","usedDeprecatedRules":"349"},{"filePath":"490","messages":"491","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"492","messages":"493","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"494","messages":"495","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"496","messages":"497","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"498","usedDeprecatedRules":"349"},{"filePath":"499","messages":"500","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"501","messages":"502","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"503","messages":"504","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"505","messages":"506","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"507","messages":"508","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"509","messages":"510","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"511","messages":"512","errorCount":9,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"513","messages":"514","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"515","messages":"516","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"517","usedDeprecatedRules":"349"},{"filePath":"518","messages":"519","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"520","messages":"521","errorCount":3,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"522","messages":"523","errorCount":5,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"524","usedDeprecatedRules":"349"},{"filePath":"525","messages":"526","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"527","usedDeprecatedRules":"349"},{"filePath":"528","messages":"529","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"530","usedDeprecatedRules":"349"},{"filePath":"531","messages":"532","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"533","usedDeprecatedRules":"349"},{"filePath":"534","messages":"535","errorCount":3,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"536","usedDeprecatedRules":"349"},{"filePath":"537","messages":"538","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"539","messages":"540","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"541","messages":"542","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"543","usedDeprecatedRules":"349"},{"filePath":"544","messages":"545","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"546","messages":"547","errorCount":5,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"548","usedDeprecatedRules":"349"},{"filePath":"549","messages":"550","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"551","messages":"552","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"553","messages":"554","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"555","messages":"556","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"557","messages":"558","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"559","messages":"560","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"561","messages":"562","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"563","messages":"564","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"565","usedDeprecatedRules":"349"},{"filePath":"566","messages":"567","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"568","messages":"569","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"570","messages":"571","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"572","messages":"573","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"574","messages":"575","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"576","messages":"577","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"578","messages":"579","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"580","messages":"581","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"582","messages":"583","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"584","messages":"585","errorCount":18,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"586","usedDeprecatedRules":"349"},{"filePath":"587","messages":"588","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"589","usedDeprecatedRules":"349"},{"filePath":"590","messages":"591","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"592","messages":"593","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"594","messages":"595","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"596","messages":"597","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"598","messages":"599","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"600","messages":"601","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"602","messages":"603","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"604","usedDeprecatedRules":"349"},{"filePath":"605","messages":"606","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"607","messages":"608","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"609","messages":"610","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"611","messages":"612","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"613","messages":"614","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"615","messages":"616","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"617","messages":"618","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"619","messages":"620","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"621","usedDeprecatedRules":"349"},{"filePath":"622","messages":"623","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"624","messages":"625","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"626","messages":"627","errorCount":3,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"628","usedDeprecatedRules":"349"},{"filePath":"629","messages":"630","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"631","messages":"632","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"633","messages":"634","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"635","messages":"636","errorCount":13,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"637","usedDeprecatedRules":"349"},{"filePath":"638","messages":"639","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"640","messages":"641","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"642","messages":"643","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"644","messages":"645","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"646","usedDeprecatedRules":"349"},{"filePath":"647","messages":"648","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"649","messages":"650","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"651","messages":"652","errorCount":10,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"653","usedDeprecatedRules":"349"},{"filePath":"654","messages":"655","errorCount":3,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"656","usedDeprecatedRules":"349"},{"filePath":"657","messages":"658","errorCount":7,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"659","usedDeprecatedRules":"349"},{"filePath":"660","messages":"661","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"662","messages":"663","errorCount":15,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"664","usedDeprecatedRules":"349"},{"filePath":"665","messages":"666","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"667","usedDeprecatedRules":"349"},{"filePath":"668","messages":"669","errorCount":7,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"670","usedDeprecatedRules":"349"},{"filePath":"671","messages":"672","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"673","messages":"674","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"675","usedDeprecatedRules":"349"},{"filePath":"676","messages":"677","errorCount":6,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"678","usedDeprecatedRules":"349"},{"filePath":"679","messages":"680","errorCount":44,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"681","usedDeprecatedRules":"349"},{"filePath":"682","messages":"683","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"684","messages":"685","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"686","messages":"687","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"688","messages":"689","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"690","messages":"691","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"692","messages":"693","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"694","messages":"695","errorCount":6,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"696","usedDeprecatedRules":"349"},{"filePath":"697","messages":"698","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"699","messages":"700","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"701","usedDeprecatedRules":"349"},{"filePath":"702","messages":"703","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"704","usedDeprecatedRules":"349"},{"filePath":"705","messages":"706","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"707"},{"filePath":"708","messages":"709","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"710","messages":"711","errorCount":15,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"712","usedDeprecatedRules":"349"},{"filePath":"713","messages":"714","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"349"},{"filePath":"715","messages":"716","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"717","usedDeprecatedRules":"349"},{"filePath":"718","messages":"719","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"720","messages":"721","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"722","messages":"723","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"724","messages":"725","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"726","messages":"727","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"728","messages":"729","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"730","messages":"731","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"732","messages":"733","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"734","messages":"735","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"736","messages":"737","errorCount":2,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"738","messages":"739","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"740","messages":"741","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"742","messages":"743","errorCount":4,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/wxj/locality/my-debug/src/index.js",[],[],"/Users/wxj/locality/my-debug/src/App.js",[],"/Users/wxj/locality/my-debug/src/reportWebVitals.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/index.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/index.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/React.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOM.js",["744","745","746","747","748","749","750","751"],"/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactBaseClasses.js",["752"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport invariant from 'shared/invariant';\nimport lowPriorityWarning from 'shared/lowPriorityWarning';\n\nimport ReactNoopUpdateQueue from './ReactNoopUpdateQueue';\n\n// 该文件包含两个基本组件，分别为 Component 及 PureComponent\n// 没看这个文件之前以为 Component 会很复杂，内部需要处理一大堆逻辑\n// 其实简单的一匹\n\nconst emptyObject = {};\nif (__DEV__) {\n  Object.freeze(emptyObject);\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  // ref 有好几个方式创建，字符串的不讲了，一般都是通过传入一个函数来给一个变量赋值 ref 的\n  // ref={el => this.el = el} 这种方式最推荐\n  // 当然还有种方式是通过 React.createRef 创建一个 ref 变量，然后这样使用\n  // this.el = React.createRef()\n  // ref={this.el}\n  // 关于 React.createRef 就阅读 ReactCreateRef.js 文件了\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  // 如果你在组件中打印 this 的话，可能看到过 updater 这个属性\n  // 有兴趣可以去看看 ReactNoopUpdateQueue 中的内容，虽然没几个 API，并且也基本没啥用，都是用来报警告的\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n// 我们在组件中调用 setState 其实就是调用到这里了\n// 用法不说了，如果不清楚的把上面的注释和相应的文档看一下就行\n// 一开始以为 setState 一大堆逻辑，结果就是调用了 updater 里的方法\n// 所以 updater 还是个蛮重要的东西\nComponent.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' ||\n      typeof partialState === 'function' ||\n      partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.',\n  );\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n// 这个 API 用的很好，不清楚作用的看文档吧\nComponent.prototype.forceUpdate = function(callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\nif (__DEV__) {\n  const deprecatedAPIs = {\n    isMounted: [\n      'isMounted',\n      'Instead, make sure to clean up subscriptions and pending requests in ' +\n        'componentWillUnmount to prevent memory leaks.',\n    ],\n    replaceState: [\n      'replaceState',\n      'Refactor your code to use setState instead (see ' +\n        'https://github.com/facebook/react/issues/3236).',\n    ],\n  };\n  const defineDeprecationWarning = function(methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function() {\n        lowPriorityWarning(\n          false,\n          '%s(...) is deprecated in plain JavaScript React classes. %s',\n          info[0],\n          info[1],\n        );\n        return undefined;\n      },\n    });\n  };\n  for (const fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\n// 以下做的都是继承功能，让 PureComponent 继承自 Component\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\nObject.assign(pureComponentPrototype, Component.prototype);\n// 通过这个变量区别下普通的 Component\npureComponentPrototype.isPureReactComponent = true;\n\nexport {Component, PureComponent};\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactChildren.js",["753"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {isValidElement, cloneAndReplaceKey} from './ReactElement';\nimport ReactDebugCurrentFrame from './ReactDebugCurrentFrame';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n// 这个代码算是 React 这个文件夹下有点东西的东西\n// React.Children 这个 API 我只在写组件的时候用过\n// 一般会用在组合组件设计模式上\n// 如果你不清楚啥是组合组件的话，可以看下 Ant-design，内部大量使用了这种设计模式\n// https://react-cn.github.io/react/docs/multiple-components.html 这里也有文档可以阅读\n// 比如说 Radio.Group、Radio.Button\n\n// 这个文件我们只关注 mapChildren 这个函数，因为这个函数内部的实现基本就贯穿了整个文件了\n// 当然你想全看了当然也是可以滴，但是我一般来说不会选择全看，毕竟我只想了解代码的核心意图\n// 如果你真的想全看完代码的话，推荐看完 mapChildren 的流程以后再去阅读\n// 另外如果你不了解这个 API 干嘛用的，可以阅读文档 https://reactjs.org/docs/react-api.html#reactchildren\n// 接下来我们就直接定位到 mapChildren 函数，开始阅读吧\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = ('' + key).replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(\n  children,\n  nameSoFar,\n  callback,\n  traverseContext,\n) {\n  // 这个函数核心作用就是通过把传入的 children 数组通过遍历摊平成单个节点\n  // 然后去执行 mapSingleChildIntoContext\n\n  // 开始判断 children 的类型\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n  // 如果 children 是可以渲染的节点的话，就直接调用 callback\n  // callback 是 mapSingleChildIntoContext\n  // 我们先去阅读下 mapSingleChildIntoContext 函数的源码\n  if (invokeCallback) {\n    callback(\n      traverseContext,\n      children,\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n    );\n    return 1;\n  }\n\n  // nextName 和 nextNamePrefix 都是在处理 key 的命名\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  // 节点是数组的话，就开始遍历数组，并且把数组中的每个元素再递归执行 traverseAllChildrenImpl\n  // 这一步操作也用来摊平数组的\n  // React.Children.map(this.props.children, c => [[c, c]])\n  // c => [[c, c]] 会被摊平为 [c, c, c, c]\n  // 这里如果看不明白的话过会在 mapSingleChildIntoContext 中肯定能看明白\n  if (Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        callback,\n        traverseContext,\n      );\n    }\n  } else {\n    // 不是数组的话，就看看 children 是否可以支持迭代\n    // 就是通过 obj[Symbol.iterator] 的方式去取\n    const iteratorFn = getIteratorFn(children);\n    // 只有取出来对象是个函数类型才是正确的\n    if (typeof iteratorFn === 'function') {\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          warning(\n            didWarnAboutMaps,\n            'Using Maps as children is unsupported and will likely yield ' +\n              'unexpected results. Convert it to a sequence/iterable of keyed ' +\n              'ReactElements instead.',\n          );\n          didWarnAboutMaps = true;\n        }\n      }\n      // 然后就是执行迭代器，重复上面 if 中的逻辑了\n      const iterator = iteratorFn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          callback,\n          traverseContext,\n        );\n      }\n    } else if (type === 'object') {\n      let addendum = '';\n      if (__DEV__) {\n        addendum =\n          ' If you meant to render a collection of children, use an array ' +\n          'instead.' +\n          ReactDebugCurrentFrame.getStackAddendum();\n      }\n      const childrenString = '' + children;\n      invariant(\n        false,\n        'Objects are not valid as a React child (found: %s).%s',\n        childrenString === '[object Object]'\n          ? 'object with keys {' + Object.keys(children).join(', ') + '}'\n          : childrenString,\n        addendum,\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (\n    typeof component === 'object' &&\n    component !== null &&\n    component.key != null\n  ) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  const {func, context} = bookKeeping;\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  const traverseContext = getPooledTraverseContext(\n    null,\n    null,\n    forEachFunc,\n    forEachContext,\n  );\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * 这个函数只有当传入的 child 是单个节点是才会调用\n * @param bookKeeping 就是我们从对象池子里取出来的东西\n * @param child 传入的节点\n * @param childKey 节点的 key\n */\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  const {result, keyPrefix, func, context} = bookKeeping;\n  // func 就是我们在 React.Children.map(this.props.children, c => c)\n  // 中传入的第二个函数参数\n  let mappedChild = func.call(context, child, bookKeeping.count++);\n  // 判断函数返回值是否为数组\n  // 因为可能会出现这种情况\n  // React.Children.map(this.props.children, c => [c, c])\n  // 对于 c => [c, c] 这种情况来说，每个子元素都会被返回出去两次\n  // 也就是说假如有 2 个子元素 c1 c2，那么通过调用 React.Children.map(this.props.children, c => [c, c]) 后\n  // 返回的应该是 4 个子元素，c1 c1 c2 c2\n  if (Array.isArray(mappedChild)) {\n    // 是数组的话就回到最先调用的函数中\n    // 然后回到之前 traverseAllChildrenImpl 摊平数组的问题\n    // 假如 c => [[c, c]]，当执行这个函数时，返回值应该是 [c, c]\n    // 然后 [c, c] 会被当成 children 传入\n    // traverseAllChildrenImpl 内部逻辑判断是数组又会重新递归执行\n    // 所以说即使你的函数是 c => [[[[c, c]]]]\n    // 最后也会被递归摊平到 [c, c, c, c]\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n  } else if (mappedChild != null) {\n    // 不是数组且返回值不为空，判断返回值是否为有效的 Element\n    // 是的话就把这个元素 clone 一遍并且替换掉 key\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(\n        mappedChild,\n        // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        keyPrefix +\n          (mappedChild.key && (!child || child.key !== mappedChild.key)\n            ? escapeUserProvidedKey(mappedChild.key) + '/'\n            : '') +\n          childKey,\n      );\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  // 这里是处理 key，不关心也没事\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  // getPooledTraverseContext 和 releaseTraverseContext 是配套的函数\n  // 用处其实很简单，就是维护一个大小为 10 的对象重用池\n  // 每次从这个池子里取一个对象去赋值，用完了就将对象上的属性置空然后丢回池子\n  // 维护这个池子的用意就是提高性能，毕竟频繁创建销毁一个有很多属性的对象消耗性能\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  // 遍历出来的元素会丢到 result 中最后返回出去\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children) {\n  return traverseAllChildren(children, () => null, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children) {\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, child => child);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  invariant(\n    isValidElement(children),\n    'React.Children.only expected to receive a single React element child.',\n  );\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactCreateRef.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactContext.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactElement.js",["754","755"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';\n\nimport ReactCurrentOwner from './ReactCurrentOwner';\n\n// 这个文件直接从 ReactElement 开始看起\n// 上面的这些代码没啥阅读意义\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true,\n};\n\nlet specialPropKeyWarningShown, specialPropRefWarningShown;\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  const warnAboutAccessingKey = function() {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warningWithoutStack(\n        false,\n        '%s: `key` is not a prop. Trying to access it will result ' +\n        'in `undefined` being returned. If you need to access the same ' +\n        'value within the child component, you should pass it as a different ' +\n        'prop. (https://fb.me/react-special-props)',\n        displayName,\n      );\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true,\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  const warnAboutAccessingRef = function() {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warningWithoutStack(\n        false,\n        '%s: `ref` is not a prop. Trying to access it will result ' +\n        'in `undefined` being returned. If you need to access the same ' +\n        'value within the child component, you should pass it as a different ' +\n        'prop. (https://fb.me/react-special-props)',\n        displayName,\n      );\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true,\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\n// 这就是个工厂函数，帮助我们创建 React Element 的\n// 内部代码很简单，无非多了一个 $$typeof 帮助我们标识\n// 这是一个 React Element\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false,\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self,\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * 根据 type 返回一个新的 ReactElement\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n  export function createElement(type, config, children) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n  // 判断是否传入配置，比如 <div className='11'></div> 中的 className 会被解析到配置中\n  if (config != null) {\n    // 验证 ref 和 key，只在开发环境下\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n    // 赋值操作\n    // self 呢就是为了以后正确获取 this\n    // source 基本来说没啥用，内部有一些 filename, line number 这种\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    // 遍历配置，把内建的几个属性剔除后丢到 props 中\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  // 处理 children 的几个操作，很简单\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  // 判断是否有给组件设置 defaultProps，有的话判断是否有给 props 赋值，只有当值为\n  // undefined 时，才会设置默认值\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key || ref) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\nexport function createFactory(type) {\n  const factory = createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook: remove it\n  factory.type = type;\n  return factory;\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const newElement = ReactElement(\n    oldElement.type,\n    newKey,\n    oldElement.ref,\n    oldElement._self,\n    oldElement._source,\n    oldElement._owner,\n    oldElement.props,\n  );\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  invariant(\n    !(element === null || element === undefined),\n    'React.cloneElement(...): The argument must be a React element, but you passed %s.',\n    element,\n  );\n\n  let propName;\n\n  // Original props are copied\n  const props = Object.assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n  let ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  const self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  const source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    let defaultProps;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactLazy.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/forwardRef.js",["756","757","758"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\n// 这个 API 我也没有用过，具体文档看这里 https://reactjs.org/docs/forwarding-refs.html\n// 总结来说就是能把 ref 传递到函数组件上\n// 其实没有这个 API 之前，你也可以通过 props 的方式传递 ref\n// 这个实现没啥好说的，就是让 render 函数多了 ref 这个参数\nexport default function forwardRef<Props, ElementType: React$ElementType>(\n  render: (props: Props, ref: React$Ref<ElementType>) => React$Node,\n) {\n\n  if (__DEV__) {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      warningWithoutStack(\n        false,\n        'forwardRef requires a render function but received a `memo` ' +\n          'component. Instead of forwardRef(memo(...)), use ' +\n          'memo(forwardRef(...)).',\n      );\n    } else if (typeof render !== 'function') {\n      warningWithoutStack(\n        false,\n        'forwardRef requires a render function but was given %s.',\n        render === null ? 'null' : typeof render,\n      );\n    } else {\n      warningWithoutStack(\n        // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object\n        render.length === 0 || render.length === 2,\n        'forwardRef render functions accept exactly two parameters: props and ref. %s',\n        render.length === 1\n          ? 'Did you forget to use the ref parameter?'\n          : 'Any additional parameter will be undefined.',\n      );\n    }\n\n    if (render != null) {\n      warningWithoutStack(\n        render.defaultProps == null && render.propTypes == null,\n        'forwardRef render functions do not support propTypes or defaultProps. ' +\n          'Did you accidentally pass a React component?',\n      );\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render,\n  };\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/memo.js",["759"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nimport isValidElementType from 'shared/isValidElementType';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\n// 这玩意就是让函数组件支持 PureComponent\n// 第二个参数可以传入一个函数，用法和 shouldComponentUpdate 一致\n// 其他内容就没啥好说的了\nexport default function memo<Props>(\n  type: React$ElementType,\n  compare?: (oldProps: Props, newProps: Props) => boolean,\n) {\n  if (__DEV__) {\n    if (!isValidElementType(type)) {\n      warningWithoutStack(\n        false,\n        'memo: The first argument must be a component. Instead ' +\n          'received: %s',\n        type === null ? 'null' : typeof type,\n      );\n    }\n  }\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type,\n    compare: compare === undefined ? null : compare,\n  };\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactElementValidator.js",["760","761","762","763","764"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nimport lowPriorityWarning from 'shared/lowPriorityWarning';\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentName from 'shared/getComponentName';\nimport {\n  getIteratorFn,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_ELEMENT_TYPE,\n} from 'shared/ReactSymbols';\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nimport ReactCurrentOwner from './ReactCurrentOwner';\nimport {isValidElement, createElement, cloneElement} from './ReactElement';\nimport ReactDebugCurrentFrame, {\n  setCurrentlyValidatingElement,\n} from './ReactDebugCurrentFrame';\n\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    const name = getComponentName(ReactCurrentOwner.current.type);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (\n    elementProps !== null &&\n    elementProps !== undefined &&\n    elementProps.__source !== undefined\n  ) {\n    const source = elementProps.__source;\n    const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    const lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  let info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    const parentName =\n      typeof parentType === 'string'\n        ? parentType\n        : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  let childOwner = '';\n  if (\n    element &&\n    element._owner &&\n    element._owner !== ReactCurrentOwner.current\n  ) {\n    // Give the component that originally created this child.\n    childOwner = ` It was passed a child from ${getComponentName(\n      element._owner.type,\n    )}.`;\n  }\n\n  setCurrentlyValidatingElement(element);\n  if (__DEV__) {\n    warning(\n      false,\n      'Each child in a list should have a unique \"key\" prop.' +\n        '%s%s See https://fb.me/react-warning-keys for more information.',\n      currentComponentErrorInfo,\n      childOwner,\n    );\n  }\n  setCurrentlyValidatingElement(null);\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      const child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    const iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        const iterator = iteratorFn.call(node);\n        let step;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  const type = element.type;\n  if (type === null || type === undefined || typeof type === 'string') {\n    return;\n  }\n  const name = getComponentName(type);\n  let propTypes;\n  if (typeof type === 'function') {\n    propTypes = type.propTypes;\n  } else if (\n    typeof type === 'object' &&\n    (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n      // Note: Memo only checks outer props here.\n      // Inner props are checked in the reconciler.\n      type.$$typeof === REACT_MEMO_TYPE)\n  ) {\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n  if (propTypes) {\n    setCurrentlyValidatingElement(element);\n    checkPropTypes(\n      propTypes,\n      element.props,\n      'prop',\n      name,\n      ReactDebugCurrentFrame.getStackAddendum,\n    );\n    setCurrentlyValidatingElement(null);\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warningWithoutStack(\n      false,\n      'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',\n      name || 'Unknown',\n    );\n  }\n  if (typeof type.getDefaultProps === 'function') {\n    warningWithoutStack(\n      type.getDefaultProps.isReactClassApproved,\n      'getDefaultProps is only used on classic React.createClass ' +\n        'definitions. Use a static property named `defaultProps` instead.',\n    );\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  setCurrentlyValidatingElement(fragment);\n\n  const keys = Object.keys(fragment.props);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning(\n        false,\n        'Invalid prop `%s` supplied to `React.Fragment`. ' +\n          'React.Fragment can only have `key` and `children` props.',\n        key,\n      );\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n\nexport function createElementWithValidation(type, props, children) {\n  const validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    let info = '';\n    if (\n      type === undefined ||\n      (typeof type === 'object' &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        ' You likely forgot to export your component from the file ' +\n        \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info =\n        ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(\n      false,\n      'React.createElement: type is invalid -- expected a string (for ' +\n        'built-in components) or a class/function (for composite ' +\n        'components) but got: %s.%s',\n      typeString,\n      info,\n    );\n  }\n\n  const element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nexport function createFactoryWithValidation(type) {\n  const validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  if (__DEV__) {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function() {\n        lowPriorityWarning(\n          false,\n          'Factory.type is deprecated. Access the class directly ' +\n            'before passing it to createFactory.',\n        );\n        Object.defineProperty(this, 'type', {\n          value: type,\n        });\n        return type;\n      },\n    });\n  }\n\n  return validatedFactory;\n}\n\nexport function cloneElementWithValidation(element, props, children) {\n  const newElement = cloneElement.apply(this, arguments);\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactHooks.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactSharedInternals.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/withComponentStack.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactVersion.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactFeatureFlags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactSymbols.js",["765"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nexport const REACT_ELEMENT_TYPE = hasSymbol\n  ? Symbol.for('react.element')\n  : 0xeac7;\nexport const REACT_PORTAL_TYPE = hasSymbol\n  ? Symbol.for('react.portal')\n  : 0xeaca;\nexport const REACT_FRAGMENT_TYPE = hasSymbol\n  ? Symbol.for('react.fragment')\n  : 0xeacb;\nexport const REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.strict_mode')\n  : 0xeacc;\nexport const REACT_PROFILER_TYPE = hasSymbol\n  ? Symbol.for('react.profiler')\n  : 0xead2;\nexport const REACT_PROVIDER_TYPE = hasSymbol\n  ? Symbol.for('react.provider')\n  : 0xeacd;\nexport const REACT_CONTEXT_TYPE = hasSymbol\n  ? Symbol.for('react.context')\n  : 0xeace;\nexport const REACT_ASYNC_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.async_mode')\n  : 0xeacf;\nexport const REACT_CONCURRENT_MODE_TYPE = hasSymbol\n  ? Symbol.for('react.concurrent_mode')\n  : 0xeacf;\nexport const REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for('react.forward_ref')\n  : 0xead0;\nexport const REACT_SUSPENSE_TYPE = hasSymbol\n  ? Symbol.for('react.suspense')\n  : 0xead1;\nexport const REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nexport const REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nexport const REACT_EVENT_COMPONENT_TYPE = hasSymbol\n  ? Symbol.for('react.event_component')\n  : 0xead5;\nexport const REACT_EVENT_TARGET_TYPE = hasSymbol\n  ? Symbol.for('react.event_target')\n  : 0xead6;\n\n// React event targets\nexport const REACT_EVENT_TARGET_TOUCH_HIT = hasSymbol\n  ? Symbol.for('react.event_target.touch_hit')\n  : 0xead7;\n\nconst MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<*> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMComponentTree.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactPortal.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ExecutionEnvironment.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactInstanceMap.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/getComponentName.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/warningWithoutStack.js",["766"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nlet warningWithoutStack = () => {};\n\nif (__DEV__) {\n  warningWithoutStack = function(condition, format, ...args) {\n    if (format === undefined) {\n      throw new Error(\n        '`warningWithoutStack(condition, format, ...args)` requires a warning ' +\n          'message argument',\n      );\n    }\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error(\n        'warningWithoutStack() currently supports at most 8 arguments.',\n      );\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== 'undefined') {\n      const argsWithFormat = args.map(item => '' + item);\n      argsWithFormat.unshift('Warning: ' + format);\n\n      // We intentionally don't use spread (or .apply) directly because it\n      // breaks IE9: https://github.com/facebook/react/issues/13610\n      Function.prototype.apply.call(console.error, console, argsWithFormat);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      let argIndex = 0;\n      const message =\n        'Warning: ' + format.replace(/%s/g, () => args[argIndex++]);\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nexport default warningWithoutStack;\n","/Users/wxj/locality/my-debug/src/react/packages/shared/lowPriorityWarning.js",["767"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nlet lowPriorityWarning = function() {};\n\nif (__DEV__) {\n  const printWarning = function(format, ...args) {\n    let argIndex = 0;\n    const message = 'Warning: ' + format.replace(/%s/g, () => args[argIndex++]);\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function(condition, format, ...args) {\n    if (format === undefined) {\n      throw new Error(\n        '`lowPriorityWarning(condition, format, ...args)` requires a warning ' +\n          'message argument',\n      );\n    }\n    if (!condition) {\n      printWarning(format, ...args);\n    }\n  };\n}\n\nexport default lowPriorityWarning;\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/checkReact.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/HTMLNodeType.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/DOMProperty.js",["768","769","770","771"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport warning from 'shared/warning';\n\ntype PropertyType = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nexport const RESERVED = 0;\n\n// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nexport const STRING = 1;\n\n// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nexport const BOOLEANISH_STRING = 2;\n\n// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nexport const BOOLEAN = 3;\n\n// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nexport const OVERLOADED_BOOLEAN = 4;\n\n// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nexport const NUMERIC = 5;\n\n// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nexport const POSITIVE_NUMERIC = 6;\n\nexport type PropertyInfo = {|\n  +acceptsBooleans: boolean,\n  +attributeName: string,\n  +attributeNamespace: string | null,\n  +mustUseProperty: boolean,\n  +propertyName: string,\n  +type: PropertyType,\n  +sanitizeURL: boolean,\n|};\n\n/* eslint-disable max-len */\nexport const ATTRIBUTE_NAME_START_CHAR =\n  ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\nexport const ATTRIBUTE_NAME_CHAR =\n  ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n\nexport const ID_ATTRIBUTE_NAME = 'data-reactid';\nexport const ROOT_ATTRIBUTE_NAME = 'data-reactroot';\nexport const VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\n  '^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$',\n);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst illegalAttributeNameCache = {};\nconst validatedAttributeNameCache = {};\n\nexport function isAttributeNameSafe(attributeName: string): boolean {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n    return true;\n  }\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  if (__DEV__) {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\nexport function shouldIgnoreAttribute(\n  name: string,\n  propertyInfo: PropertyInfo | null,\n  isCustomComponentTag: boolean,\n): boolean {\n  if (propertyInfo !== null) {\n    return propertyInfo.type === RESERVED;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (\n    name.length > 2 &&\n    (name[0] === 'o' || name[0] === 'O') &&\n    (name[1] === 'n' || name[1] === 'N')\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function shouldRemoveAttributeWithWarning(\n  name: string,\n  value: mixed,\n  propertyInfo: PropertyInfo | null,\n  isCustomComponentTag: boolean,\n): boolean {\n  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n    return false;\n  }\n  switch (typeof value) {\n    case 'function':\n    // $FlowIssue symbol is perfectly valid here\n    case 'symbol': // eslint-disable-line\n      return true;\n    case 'boolean': {\n      if (isCustomComponentTag) {\n        return false;\n      }\n      if (propertyInfo !== null) {\n        return !propertyInfo.acceptsBooleans;\n      } else {\n        const prefix = name.toLowerCase().slice(0, 5);\n        return prefix !== 'data-' && prefix !== 'aria-';\n      }\n    }\n    default:\n      return false;\n  }\n}\n\nexport function shouldRemoveAttribute(\n  name: string,\n  value: mixed,\n  propertyInfo: PropertyInfo | null,\n  isCustomComponentTag: boolean,\n): boolean {\n  if (value === null || typeof value === 'undefined') {\n    return true;\n  }\n  if (\n    shouldRemoveAttributeWithWarning(\n      name,\n      value,\n      propertyInfo,\n      isCustomComponentTag,\n    )\n  ) {\n    return true;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (propertyInfo !== null) {\n    switch (propertyInfo.type) {\n      case BOOLEAN:\n        return !value;\n      case OVERLOADED_BOOLEAN:\n        return value === false;\n      case NUMERIC:\n        return isNaN(value);\n      case POSITIVE_NUMERIC:\n        return isNaN(value) || (value: any) < 1;\n    }\n  }\n  return false;\n}\n\nexport function getPropertyInfo(name: string): PropertyInfo | null {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction PropertyInfoRecord(\n  name: string,\n  type: PropertyType,\n  mustUseProperty: boolean,\n  attributeName: string,\n  attributeNamespace: string | null,\n  sanitizeURL: boolean,\n) {\n  this.acceptsBooleans =\n    type === BOOLEANISH_STRING ||\n    type === BOOLEAN ||\n    type === OVERLOADED_BOOLEAN;\n  this.attributeName = attributeName;\n  this.attributeNamespace = attributeNamespace;\n  this.mustUseProperty = mustUseProperty;\n  this.propertyName = name;\n  this.type = type;\n  this.sanitizeURL = sanitizeURL;\n}\n\n// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nconst properties = {};\n\n// These props are reserved by React. They shouldn't be written to the DOM.\n[\n  'children',\n  'dangerouslySetInnerHTML',\n  // TODO: This prevents the assignment of defaultValue to regular\n  // elements (not just inputs). Now that ReactDOMInput assigns to the\n  // defaultValue property -- do we need this?\n  'defaultValue',\n  'defaultChecked',\n  'innerHTML',\n  'suppressContentEditableWarning',\n  'suppressHydrationWarning',\n  'style',\n].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    RESERVED,\n    false, // mustUseProperty\n    name, // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[\n  ['acceptCharset', 'accept-charset'],\n  ['className', 'class'],\n  ['htmlFor', 'for'],\n  ['httpEquiv', 'http-equiv'],\n].forEach(([name, attributeName]) => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    STRING,\n    false, // mustUseProperty\n    attributeName, // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    BOOLEANISH_STRING,\n    false, // mustUseProperty\n    name.toLowerCase(), // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n[\n  'autoReverse',\n  'externalResourcesRequired',\n  'focusable',\n  'preserveAlpha',\n].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    BOOLEANISH_STRING,\n    false, // mustUseProperty\n    name, // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are HTML boolean attributes.\n[\n  'allowFullScreen',\n  'async',\n  // Note: there is a special case that prevents it from being written to the DOM\n  // on the client side because the browsers are inconsistent. Instead we call focus().\n  'autoFocus',\n  'autoPlay',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'hidden',\n  'loop',\n  'noModule',\n  'noValidate',\n  'open',\n  'playsInline',\n  'readOnly',\n  'required',\n  'reversed',\n  'scoped',\n  'seamless',\n  // Microdata\n  'itemScope',\n].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    BOOLEAN,\n    false, // mustUseProperty\n    name.toLowerCase(), // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n[\n  'checked',\n  // Note: `option.selected` is not updated if `select.multiple` is\n  // disabled with `removeAttribute`. We have special logic for handling this.\n  'multiple',\n  'muted',\n  'selected',\n\n  // NOTE: if you add a camelCased prop to this list,\n  // you'll need to set attributeName to name.toLowerCase()\n  // instead in the assignment below.\n].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    BOOLEAN,\n    true, // mustUseProperty\n    name, // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n[\n  'capture',\n  'download',\n\n  // NOTE: if you add a camelCased prop to this list,\n  // you'll need to set attributeName to name.toLowerCase()\n  // instead in the assignment below.\n].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    OVERLOADED_BOOLEAN,\n    false, // mustUseProperty\n    name, // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are HTML attributes that must be positive numbers.\n[\n  'cols',\n  'rows',\n  'size',\n  'span',\n\n  // NOTE: if you add a camelCased prop to this list,\n  // you'll need to set attributeName to name.toLowerCase()\n  // instead in the assignment below.\n].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    POSITIVE_NUMERIC,\n    false, // mustUseProperty\n    name, // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These are HTML attributes that must be numbers.\n['rowSpan', 'start'].forEach(name => {\n  properties[name] = new PropertyInfoRecord(\n    name,\n    NUMERIC,\n    false, // mustUseProperty\n    name.toLowerCase(), // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\nconst CAMELIZE = /[\\-\\:]([a-z])/g;\nconst capitalize = token => token[1].toUpperCase();\n\n// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n[\n  'accent-height',\n  'alignment-baseline',\n  'arabic-form',\n  'baseline-shift',\n  'cap-height',\n  'clip-path',\n  'clip-rule',\n  'color-interpolation',\n  'color-interpolation-filters',\n  'color-profile',\n  'color-rendering',\n  'dominant-baseline',\n  'enable-background',\n  'fill-opacity',\n  'fill-rule',\n  'flood-color',\n  'flood-opacity',\n  'font-family',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-style',\n  'font-variant',\n  'font-weight',\n  'glyph-name',\n  'glyph-orientation-horizontal',\n  'glyph-orientation-vertical',\n  'horiz-adv-x',\n  'horiz-origin-x',\n  'image-rendering',\n  'letter-spacing',\n  'lighting-color',\n  'marker-end',\n  'marker-mid',\n  'marker-start',\n  'overline-position',\n  'overline-thickness',\n  'paint-order',\n  'panose-1',\n  'pointer-events',\n  'rendering-intent',\n  'shape-rendering',\n  'stop-color',\n  'stop-opacity',\n  'strikethrough-position',\n  'strikethrough-thickness',\n  'stroke-dasharray',\n  'stroke-dashoffset',\n  'stroke-linecap',\n  'stroke-linejoin',\n  'stroke-miterlimit',\n  'stroke-opacity',\n  'stroke-width',\n  'text-anchor',\n  'text-decoration',\n  'text-rendering',\n  'underline-position',\n  'underline-thickness',\n  'unicode-bidi',\n  'unicode-range',\n  'units-per-em',\n  'v-alphabetic',\n  'v-hanging',\n  'v-ideographic',\n  'v-mathematical',\n  'vector-effect',\n  'vert-adv-y',\n  'vert-origin-x',\n  'vert-origin-y',\n  'word-spacing',\n  'writing-mode',\n  'xmlns:xlink',\n  'x-height',\n\n  // NOTE: if you add a camelCased prop to this list,\n  // you'll need to set attributeName to name.toLowerCase()\n  // instead in the assignment below.\n].forEach(attributeName => {\n  const name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(\n    name,\n    STRING,\n    false, // mustUseProperty\n    attributeName,\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// String SVG attributes with the xlink namespace.\n[\n  'xlink:actuate',\n  'xlink:arcrole',\n  'xlink:role',\n  'xlink:show',\n  'xlink:title',\n  'xlink:type',\n\n  // NOTE: if you add a camelCased prop to this list,\n  // you'll need to set attributeName to name.toLowerCase()\n  // instead in the assignment below.\n].forEach(attributeName => {\n  const name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(\n    name,\n    STRING,\n    false, // mustUseProperty\n    attributeName,\n    'http://www.w3.org/1999/xlink',\n    false, // sanitizeURL\n  );\n});\n\n// String SVG attributes with the xml namespace.\n[\n  'xml:base',\n  'xml:lang',\n  'xml:space',\n\n  // NOTE: if you add a camelCased prop to this list,\n  // you'll need to set attributeName to name.toLowerCase()\n  // instead in the assignment below.\n].forEach(attributeName => {\n  const name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(\n    name,\n    STRING,\n    false, // mustUseProperty\n    attributeName,\n    'http://www.w3.org/XML/1998/namespace',\n    false, // sanitizeURL\n  );\n});\n\n// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex', 'crossOrigin'].forEach(attributeName => {\n  properties[attributeName] = new PropertyInfoRecord(\n    attributeName,\n    STRING,\n    false, // mustUseProperty\n    attributeName.toLowerCase(), // attributeName\n    null, // attributeNamespace\n    false, // sanitizeURL\n  );\n});\n\n// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nconst xlinkHref = 'xlinkHref';\nproperties[xlinkHref] = new PropertyInfoRecord(\n  'xlinkHref',\n  STRING,\n  false, // mustUseProperty\n  'xlink:href',\n  'http://www.w3.org/1999/xlink',\n  true, // sanitizeURL\n);\n\n['src', 'href', 'action', 'formAction'].forEach(attributeName => {\n  properties[attributeName] = new PropertyInfoRecord(\n    attributeName,\n    STRING,\n    false, // mustUseProperty\n    attributeName.toLowerCase(), // attributeName\n    null, // attributeNamespace\n    true, // sanitizeURL\n  );\n});\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMClientInjection.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMComponent.js",["772","773","774","775","776","777","778","779","780","781","782","783","784","785","786","787"],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/ReactDOMEventListener.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/inline.dom.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/invariant.js",["788","789","790","791","792","793","794","795"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nexport default function invariant(condition, format, a, b, c, d, e, f) {\n  throw new Error(\n    'Internal React error: invariant() is meant to be replaced at compile ' +\n      'time. There is no runtime version.',\n  );\n}\n","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactSharedInternals.js",["796","797"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React from 'react';\n\n// const ReactSharedInternals =\n//   React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nimport ReactSharedInternals from '../react/src/ReactSharedInternals';\n\n// Prevent newer renderers from RTE when used with older react package versions.\n// Current owner and dispatcher used to share the same ref,\n// but PR #14548 split them out to better support the react-debug-tools package.\nif (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {\n  ReactSharedInternals.ReactCurrentDispatcher = {\n    current: null,\n  };\n}\n\nexport default ReactSharedInternals;\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactNoopUpdateQueue.js",["798","799","800","801","802","803","804","805","806"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nconst didWarnStateUpdateForUnmountedComponent = {};\n\n// 以下的几个 API 都是用于报警告的，看不看都无所谓\n\nfunction warnNoop(publicInstance, callerName) {\n  if (__DEV__) {\n    const constructor = publicInstance.constructor;\n    const componentName =\n      (constructor && (constructor.displayName || constructor.name)) ||\n      'ReactClass';\n    const warningKey = `${componentName}.${callerName}`;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warningWithoutStack(\n      false,\n      \"Can't call %s on a component that is not yet mounted. \" +\n        'This is a no-op, but it might indicate a bug in your application. ' +\n        'Instead, assign to `this.state` directly or define a `state = {};` ' +\n        'class property with the desired state in the %s component.',\n      callerName,\n      componentName,\n    );\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nconst ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function(publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function(publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function(\n    publicInstance,\n    completeState,\n    callback,\n    callerName,\n  ) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function(\n    publicInstance,\n    partialState,\n    callback,\n    callerName,\n  ) {\n    warnNoop(publicInstance, 'setState');\n  },\n};\n\nexport default ReactNoopUpdateQueue;\n","/Users/wxj/locality/my-debug/src/react/packages/shared/warning.js",["807"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nlet warning = warningWithoutStack;\n\nif (__DEV__) {\n  warning = function(condition, format, ...args) {\n    if (condition) {\n      return;\n    }\n    const ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    const stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n    warningWithoutStack(false, format + '%s', ...args, stack);\n  };\n}\n\nexport default warning;\n","/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactDebugCurrentFrame.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/isValidElementType.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactCurrentOwner.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react/src/ReactCurrentDispatcher.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactWorkTags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactLazyComponent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/DOMEventPluginOrder.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/DOMPropertyOperations.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMSelect.js",["808"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nimport {getCurrentFiberOwnerNameInDevOrNull} from 'react-reconciler/src/ReactCurrentFiber';\nimport warning from 'shared/warning';\n\nimport ReactControlledValuePropTypes from '../shared/ReactControlledValuePropTypes';\nimport {getToStringValue, toString} from './ToStringValue';\n\nlet didWarnValueDefaultValue;\n\nif (__DEV__) {\n  didWarnValueDefaultValue = false;\n}\n\ntype SelectWithWrapperState = HTMLSelectElement & {\n  _wrapperState: {\n    wasMultiple: boolean,\n  },\n};\n\nfunction getDeclarationErrorAddendum() {\n  const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nconst valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props);\n\n  for (let i = 0; i < valuePropNames.length; i++) {\n    const propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    const isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(\n        false,\n        'The `%s` prop supplied to <select> must be an array if ' +\n          '`multiple` is true.%s',\n        propName,\n        getDeclarationErrorAddendum(),\n      );\n    } else if (!props.multiple && isArray) {\n      warning(\n        false,\n        'The `%s` prop supplied to <select> must be a scalar ' +\n          'value if `multiple` is false.%s',\n        propName,\n        getDeclarationErrorAddendum(),\n      );\n    }\n  }\n}\n\nfunction updateOptions(\n  node: HTMLSelectElement,\n  multiple: boolean,\n  propValue: any,\n  setDefaultSelected: boolean,\n) {\n  type IndexableHTMLOptionsCollection = HTMLOptionsCollection & {\n    [key: number]: HTMLOptionElement,\n  };\n  const options: IndexableHTMLOptionsCollection = node.options;\n\n  if (multiple) {\n    let selectedValues = (propValue: Array<string>);\n    let selectedValue = {};\n    for (let i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (let i = 0; i < options.length; i++) {\n      const selected = selectedValue.hasOwnProperty('$' + options[i].value);\n      if (options[i].selected !== selected) {\n        options[i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    let selectedValue = toString(getToStringValue((propValue: any)));\n    let defaultSelected = null;\n    for (let i = 0; i < options.length; i++) {\n      if (options[i].value === selectedValue) {\n        options[i].selected = true;\n        if (setDefaultSelected) {\n          options[i].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[i].disabled) {\n        defaultSelected = options[i];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nexport function getHostProps(element: Element, props: Object) {\n  return Object.assign({}, props, {\n    value: undefined,\n  });\n}\n\nexport function initWrapperState(element: Element, props: Object) {\n  const node = ((element: any): SelectWithWrapperState);\n  if (__DEV__) {\n    checkSelectPropTypes(props);\n  }\n\n  node._wrapperState = {\n    wasMultiple: !!props.multiple,\n  };\n\n  if (__DEV__) {\n    if (\n      props.value !== undefined &&\n      props.defaultValue !== undefined &&\n      !didWarnValueDefaultValue\n    ) {\n      warning(\n        false,\n        'Select elements must be either controlled or uncontrolled ' +\n          '(specify either the value prop, or the defaultValue prop, but not ' +\n          'both). Decide between using a controlled or uncontrolled select ' +\n          'element and remove one of these props. More info: ' +\n          'https://fb.me/react-controlled-components',\n      );\n      didWarnValueDefaultValue = true;\n    }\n  }\n}\n\nexport function postMountWrapper(element: Element, props: Object) {\n  const node = ((element: any): SelectWithWrapperState);\n  node.multiple = !!props.multiple;\n  const value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nexport function postUpdateWrapper(element: Element, props: Object) {\n  const node = ((element: any): SelectWithWrapperState);\n  const wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  const value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nexport function restoreControlledState(element: Element, props: Object) {\n  const node = ((element: any): SelectWithWrapperState);\n  const value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMOption.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMInput.js",["809","810","811","812","813","814"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nimport {getCurrentFiberOwnerNameInDevOrNull} from 'react-reconciler/src/ReactCurrentFiber';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\n\nimport {setValueForProperty} from './DOMPropertyOperations';\nimport {getFiberCurrentPropsFromNode} from './ReactDOMComponentTree';\nimport {getToStringValue, toString} from './ToStringValue';\nimport ReactControlledValuePropTypes from '../shared/ReactControlledValuePropTypes';\nimport {updateValueIfChanged} from './inputValueTracking';\nimport {disableInputAttributeSyncing} from 'shared/ReactFeatureFlags';\n\nimport type {ToStringValue} from './ToStringValue';\n\ntype InputWithWrapperState = HTMLInputElement & {\n  _wrapperState: {\n    initialValue: ToStringValue,\n    initialChecked: ?boolean,\n    controlled?: boolean,\n  },\n};\n\nlet didWarnValueDefaultValue = false;\nlet didWarnCheckedDefaultChecked = false;\nlet didWarnControlledToUncontrolled = false;\nlet didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  const usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nexport function getHostProps(element: Element, props: Object) {\n  const node = ((element: any): InputWithWrapperState);\n  const checked = props.checked;\n\n  const hostProps = Object.assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked,\n  });\n\n  return hostProps;\n}\n\nexport function initWrapperState(element: Element, props: Object) {\n  if (__DEV__) {\n    ReactControlledValuePropTypes.checkPropTypes('input', props);\n\n    if (\n      props.checked !== undefined &&\n      props.defaultChecked !== undefined &&\n      !didWarnCheckedDefaultChecked\n    ) {\n      warning(\n        false,\n        '%s contains an input of type %s with both checked and defaultChecked props. ' +\n          'Input elements must be either controlled or uncontrolled ' +\n          '(specify either the checked prop, or the defaultChecked prop, but not ' +\n          'both). Decide between using a controlled or uncontrolled input ' +\n          'element and remove one of these props. More info: ' +\n          'https://fb.me/react-controlled-components',\n        getCurrentFiberOwnerNameInDevOrNull() || 'A component',\n        props.type,\n      );\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (\n      props.value !== undefined &&\n      props.defaultValue !== undefined &&\n      !didWarnValueDefaultValue\n    ) {\n      warning(\n        false,\n        '%s contains an input of type %s with both value and defaultValue props. ' +\n          'Input elements must be either controlled or uncontrolled ' +\n          '(specify either the value prop, or the defaultValue prop, but not ' +\n          'both). Decide between using a controlled or uncontrolled input ' +\n          'element and remove one of these props. More info: ' +\n          'https://fb.me/react-controlled-components',\n        getCurrentFiberOwnerNameInDevOrNull() || 'A component',\n        props.type,\n      );\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  const node = ((element: any): InputWithWrapperState);\n  const defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n\n  node._wrapperState = {\n    initialChecked:\n      props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getToStringValue(\n      props.value != null ? props.value : defaultValue,\n    ),\n    controlled: isControlled(props),\n  };\n}\n\nexport function updateChecked(element: Element, props: Object) {\n  const node = ((element: any): InputWithWrapperState);\n  const checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\n\nexport function updateWrapper(element: Element, props: Object) {\n  const node = ((element: any): InputWithWrapperState);\n  if (__DEV__) {\n    const controlled = isControlled(props);\n\n    if (\n      !node._wrapperState.controlled &&\n      controlled &&\n      !didWarnUncontrolledToControlled\n    ) {\n      warning(\n        false,\n        'A component is changing an uncontrolled input of type %s to be controlled. ' +\n          'Input elements should not switch from uncontrolled to controlled (or vice versa). ' +\n          'Decide between using a controlled or uncontrolled input ' +\n          'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',\n        props.type,\n      );\n      didWarnUncontrolledToControlled = true;\n    }\n    if (\n      node._wrapperState.controlled &&\n      !controlled &&\n      !didWarnControlledToUncontrolled\n    ) {\n      warning(\n        false,\n        'A component is changing a controlled input of type %s to be uncontrolled. ' +\n          'Input elements should not switch from controlled to uncontrolled (or vice versa). ' +\n          'Decide between using a controlled or uncontrolled input ' +\n          'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',\n        props.type,\n      );\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  const value = getToStringValue(props.value);\n  const type = props.type;\n\n  if (value != null) {\n    if (type === 'number') {\n      if (\n        (value === 0 && node.value === '') ||\n        // We explicitly want to coerce to number here if possible.\n        // eslint-disable-next-line\n        node.value != (value: any)\n      ) {\n        node.value = toString(value);\n      }\n    } else if (node.value !== toString(value)) {\n      node.value = toString(value);\n    }\n  } else if (type === 'submit' || type === 'reset') {\n    // Submit/reset inputs need the attribute removed completely to avoid\n    // blank-text buttons.\n    node.removeAttribute('value');\n    return;\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the value attribute, React only assigns a new value\n    // whenever the defaultValue React prop has changed. When not present,\n    // React does nothing\n    if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  } else {\n    // When syncing the value attribute, the value comes from a cascade of\n    // properties:\n    //  1. The value React property\n    //  2. The defaultValue React property\n    //  3. Otherwise there should be no change\n    if (props.hasOwnProperty('value')) {\n      setDefaultValue(node, props.type, value);\n    } else if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the attribute is directly\n    // controllable from the defaultValue React property. It needs to be\n    // updated as new props come in.\n    if (props.defaultChecked == null) {\n      node.removeAttribute('checked');\n    } else {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, it only changes when it needs\n    // to be removed, such as transitioning from a checkbox into a text input\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\n\nexport function postMountWrapper(\n  element: Element,\n  props: Object,\n  isHydrating: boolean,\n) {\n  const node = ((element: any): InputWithWrapperState);\n\n  // Do not assign value if it is already set. This prevents user text input\n  // from being lost during SSR hydration.\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    const type = props.type;\n    const isButton = type === 'submit' || type === 'reset';\n\n    // Avoid setting value attribute on submit/reset inputs as it overrides the\n    // default value provided by the browser. See: #12872\n    if (isButton && (props.value === undefined || props.value === null)) {\n      return;\n    }\n\n    const initialValue = toString(node._wrapperState.initialValue);\n\n    // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n    if (!isHydrating) {\n      if (disableInputAttributeSyncing) {\n        const value = getToStringValue(props.value);\n\n        // When not syncing the value attribute, the value property points\n        // directly to the React prop. Only assign it if it exists.\n        if (value != null) {\n          // Always assign on buttons so that it is possible to assign an\n          // empty string to clear button text.\n          //\n          // Otherwise, do not re-assign the value property if is empty. This\n          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\n          // prematurely marking required inputs as invalid. Equality is compared\n          // to the current value in case the browser provided value is not an\n          // empty string.\n          if (isButton || value !== node.value) {\n            node.value = toString(value);\n          }\n        }\n      } else {\n        // When syncing the value attribute, the value property should use\n        // the wrapperState._initialValue property. This uses:\n        //\n        //   1. The value React property when present\n        //   2. The defaultValue React property when present\n        //   3. An empty string\n        if (initialValue !== node.value) {\n          node.value = initialValue;\n        }\n      }\n    }\n\n    if (disableInputAttributeSyncing) {\n      // When not syncing the value attribute, assign the value attribute\n      // directly from the defaultValue React property (when present)\n      const defaultValue = getToStringValue(props.defaultValue);\n      if (defaultValue != null) {\n        node.defaultValue = toString(defaultValue);\n      }\n    } else {\n      // Otherwise, the value attribute is synchronized to the property,\n      // so we assign defaultValue to the same thing as the value property\n      // assignment step above.\n      node.defaultValue = initialValue;\n    }\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  const name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the checked property\n    // never gets assigned. It must be manually set. We don't want\n    // to do this when hydrating so that existing user input isn't\n    // modified\n    if (!isHydrating) {\n      updateChecked(element, props);\n    }\n\n    // Only assign the checked attribute if it is defined. This saves\n    // a DOM write when controlling the checked attribute isn't needed\n    // (text inputs, submit/reset)\n    if (props.hasOwnProperty('defaultChecked')) {\n      node.defaultChecked = !node.defaultChecked;\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, both the checked property and\n    // attribute are assigned at the same time using defaultChecked. This uses:\n    //\n    //   1. The checked React property when present\n    //   2. The defaultChecked React property when present\n    //   3. Otherwise, false\n    node.defaultChecked = !node.defaultChecked;\n    node.defaultChecked = !!node._wrapperState.initialChecked;\n  }\n\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nexport function restoreControlledState(element: Element, props: Object) {\n  const node = ((element: any): InputWithWrapperState);\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  const name = props.name;\n  if (props.type === 'radio' && name != null) {\n    let queryRoot: Element = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = ((queryRoot.parentNode: any): Element);\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    const group = queryRoot.querySelectorAll(\n      'input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]',\n    );\n\n    for (let i = 0; i < group.length; i++) {\n      const otherNode = ((group[i]: any): HTMLInputElement);\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      const otherProps = getFiberCurrentPropsFromNode(otherNode);\n      invariant(\n        otherProps,\n        'ReactDOMInput: Mixing React and non-React radio inputs with the ' +\n          'same `name` is not supported.',\n      );\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nexport function setDefaultValue(\n  node: InputWithWrapperState,\n  type: ?string,\n  value: *,\n) {\n  if (\n    // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n    type !== 'number' ||\n    node.ownerDocument.activeElement !== node\n  ) {\n    if (value == null) {\n      node.defaultValue = toString(node._wrapperState.initialValue);\n    } else if (node.defaultValue !== toString(value)) {\n      node.defaultValue = toString(value);\n    }\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/setInnerHTML.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMTextarea.js",["815"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\n\nimport ReactControlledValuePropTypes from '../shared/ReactControlledValuePropTypes';\nimport {getCurrentFiberOwnerNameInDevOrNull} from 'react-reconciler/src/ReactCurrentFiber';\nimport {getToStringValue, toString} from './ToStringValue';\nimport type {ToStringValue} from './ToStringValue';\n\nlet didWarnValDefaultVal = false;\n\ntype TextAreaWithWrapperState = HTMLTextAreaElement & {\n  _wrapperState: {\n    initialValue: ToStringValue,\n  },\n};\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nexport function getHostProps(element: Element, props: Object) {\n  const node = ((element: any): TextAreaWithWrapperState);\n  invariant(\n    props.dangerouslySetInnerHTML == null,\n    '`dangerouslySetInnerHTML` does not make sense on <textarea>.',\n  );\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  const hostProps = {\n    ...props,\n    value: undefined,\n    defaultValue: undefined,\n    children: toString(node._wrapperState.initialValue),\n  };\n\n  return hostProps;\n}\n\nexport function initWrapperState(element: Element, props: Object) {\n  const node = ((element: any): TextAreaWithWrapperState);\n  if (__DEV__) {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props);\n    if (\n      props.value !== undefined &&\n      props.defaultValue !== undefined &&\n      !didWarnValDefaultVal\n    ) {\n      warning(\n        false,\n        '%s contains a textarea with both value and defaultValue props. ' +\n          'Textarea elements must be either controlled or uncontrolled ' +\n          '(specify either the value prop, or the defaultValue prop, but not ' +\n          'both). Decide between using a controlled or uncontrolled textarea ' +\n          'and remove one of these props. More info: ' +\n          'https://fb.me/react-controlled-components',\n        getCurrentFiberOwnerNameInDevOrNull() || 'A component',\n      );\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  let initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    let defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    let children = props.children;\n    if (children != null) {\n      if (__DEV__) {\n        warning(\n          false,\n          'Use the `defaultValue` or `value` props instead of setting ' +\n            'children on <textarea>.',\n        );\n      }\n      invariant(\n        defaultValue == null,\n        'If you supply `defaultValue` on a <textarea>, do not pass children.',\n      );\n      if (Array.isArray(children)) {\n        invariant(\n          children.length <= 1,\n          '<textarea> can only have at most one child.',\n        );\n        children = children[0];\n      }\n\n      defaultValue = children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: getToStringValue(initialValue),\n  };\n}\n\nexport function updateWrapper(element: Element, props: Object) {\n  const node = ((element: any): TextAreaWithWrapperState);\n  const value = getToStringValue(props.value);\n  const defaultValue = getToStringValue(props.defaultValue);\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    const newValue = toString(value);\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null && node.defaultValue !== newValue) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (defaultValue != null) {\n    node.defaultValue = toString(defaultValue);\n  }\n}\n\nexport function postMountWrapper(element: Element, props: Object) {\n  const node = ((element: any): TextAreaWithWrapperState);\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  const textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nexport function restoreControlledState(element: Element, props: Object) {\n  // DOM component is still mounted; update\n  updateWrapper(element, props);\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/inputValueTracking.js",["816"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ntype ValueTracker = {\n  getValue(): string,\n  setValue(value: string): void,\n  stopTracking(): void,\n};\ntype WrapperState = {_valueTracker?: ?ValueTracker};\ntype ElementWithValueTracker = HTMLInputElement & WrapperState;\n\nfunction isCheckable(elem: HTMLInputElement) {\n  const type = elem.type;\n  const nodeName = elem.nodeName;\n  return (\n    nodeName &&\n    nodeName.toLowerCase() === 'input' &&\n    (type === 'checkbox' || type === 'radio')\n  );\n}\n\nfunction getTracker(node: ElementWithValueTracker) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node: ElementWithValueTracker) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node: HTMLInputElement): string {\n  let value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node: any): ?ValueTracker {\n  const valueField = isCheckable(node) ? 'checked' : 'value';\n  const descriptor = Object.getOwnPropertyDescriptor(\n    node.constructor.prototype,\n    valueField,\n  );\n\n  let currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (\n    node.hasOwnProperty(valueField) ||\n    typeof descriptor === 'undefined' ||\n    typeof descriptor.get !== 'function' ||\n    typeof descriptor.set !== 'function'\n  ) {\n    return;\n  }\n  const {get, set} = descriptor;\n  Object.defineProperty(node, valueField, {\n    configurable: true,\n    get: function() {\n      return get.call(this);\n    },\n    set: function(value) {\n      currentValue = '' + value;\n      set.call(this, value);\n    },\n  });\n  // We could've passed this the first time\n  // but it triggers a bug in IE11 and Edge 14/15.\n  // Calling defineProperty() again should be equivalent.\n  // https://github.com/facebook/react/issues/11768\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable,\n  });\n\n  const tracker = {\n    getValue() {\n      return currentValue;\n    },\n    setValue(value) {\n      currentValue = '' + value;\n    },\n    stopTracking() {\n      detachTracker(node);\n      delete node[valueField];\n    },\n  };\n  return tracker;\n}\n\nexport function track(node: ElementWithValueTracker) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nexport function updateValueIfChanged(node: ElementWithValueTracker) {\n  if (!node) {\n    return false;\n  }\n\n  const tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  const lastValue = tracker.getValue();\n  const nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nexport function stopTracking(node: ElementWithValueTracker) {\n  const tracker = getTracker(node);\n  if (tracker) {\n    tracker.stopTracking();\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/setTextContent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/CSSPropertyOperations.js",["817","818"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {shorthandToLonghand} from './CSSShorthandProperty';\n\nimport dangerousStyleValue from './dangerousStyleValue';\nimport hyphenateStyleName from './hyphenateStyleName';\nimport warnValidStyle from './warnValidStyle';\nimport warning from 'shared/warning';\n\nimport {warnAboutShorthandPropertyCollision} from 'shared/ReactFeatureFlags';\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nexport function createDangerousStringForStyles(styles) {\n  if (__DEV__) {\n    let serialized = '';\n    let delimiter = '';\n    for (const styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      const styleValue = styles[styleName];\n      if (styleValue != null) {\n        const isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(\n          styleName,\n          styleValue,\n          isCustomProperty,\n        );\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nexport function setValueForStyles(node, styles) {\n  const style = node.style;\n  for (let styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    const isCustomProperty = styleName.indexOf('--') === 0;\n    if (__DEV__) {\n      if (!isCustomProperty) {\n        warnValidStyle(styleName, styles[styleName]);\n      }\n    }\n    const styleValue = dangerousStyleValue(\n      styleName,\n      styles[styleName],\n      isCustomProperty,\n    );\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\nfunction isValueEmpty(value) {\n  return value == null || typeof value === 'boolean' || value === '';\n}\n\n/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */\nfunction expandShorthandMap(styles) {\n  const expanded = {};\n  for (const key in styles) {\n    const longhands = shorthandToLonghand[key] || [key];\n    for (let i = 0; i < longhands.length; i++) {\n      expanded[longhands[i]] = key;\n    }\n  }\n  return expanded;\n}\n\n/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */\nexport function validateShorthandPropertyCollisionInDev(\n  styleUpdates,\n  nextStyles,\n) {\n  if (!warnAboutShorthandPropertyCollision) {\n    return;\n  }\n\n  if (!nextStyles) {\n    return;\n  }\n\n  const expandedUpdates = expandShorthandMap(styleUpdates);\n  const expandedStyles = expandShorthandMap(nextStyles);\n  const warnedAbout = {};\n  for (const key in expandedUpdates) {\n    const originalKey = expandedUpdates[key];\n    const correctOriginalKey = expandedStyles[key];\n    if (correctOriginalKey && originalKey !== correctOriginalKey) {\n      const warningKey = originalKey + ',' + correctOriginalKey;\n      if (warnedAbout[warningKey]) {\n        continue;\n      }\n      warnedAbout[warningKey] = true;\n      warning(\n        false,\n        '%s a style property during rerender (%s) when a ' +\n          'conflicting property is set (%s) can lead to styling bugs. To ' +\n          \"avoid this, don't mix shorthand and non-shorthand properties \" +\n          'for the same value; instead, replace the shorthand with ' +\n          'separate values.',\n        isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating',\n        originalKey,\n        correctOriginalKey,\n      );\n    }\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/assertValidProps.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/isCustomComponent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/possibleStandardNames.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/DOMNamespaces.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactDOMInvalidARIAHook.js",["819","820"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport warning from 'shared/warning';\n\nimport {ATTRIBUTE_NAME_CHAR} from './DOMProperty';\nimport isCustomComponent from './isCustomComponent';\nimport validAriaProperties from './validAriaProperties';\n\nconst warnedProperties = {};\nconst rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nconst rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    const ariaName = 'aria-' + name.slice(4).toLowerCase();\n    const correctName = validAriaProperties.hasOwnProperty(ariaName)\n      ? ariaName\n      : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(\n        false,\n        'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',\n        name,\n      );\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(\n        false,\n        'Invalid ARIA attribute `%s`. Did you mean `%s`?',\n        name,\n        correctName,\n      );\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    const lowerCasedName = name.toLowerCase();\n    const standardName = validAriaProperties.hasOwnProperty(lowerCasedName)\n      ? lowerCasedName\n      : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(\n        false,\n        'Unknown ARIA attribute `%s`. Did you mean `%s`?',\n        name,\n        standardName,\n      );\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  const invalidProps = [];\n\n  for (const key in props) {\n    const isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  const unknownPropString = invalidProps\n    .map(prop => '`' + prop + '`')\n    .join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(\n      false,\n      'Invalid aria prop %s on <%s> tag. ' +\n        'For details, see https://fb.me/invalid-aria-prop',\n      unknownPropString,\n      type,\n    );\n  } else if (invalidProps.length > 1) {\n    warning(\n      false,\n      'Invalid aria props %s on <%s> tag. ' +\n        'For details, see https://fb.me/invalid-aria-prop',\n      unknownPropString,\n      type,\n    );\n  }\n}\n\nexport function validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactDOMNullInputValuePropHook.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/ChangeEventPlugin.js",["821"],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SelectEventPlugin.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/checkPassiveEvents.js",["822"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\nimport {enableEventAPI} from 'shared/ReactFeatureFlags';\n\nexport let passiveBrowserEventsSupported = false;\n\n// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif (enableEventAPI && canUseDOM) {\n  try {\n    const options = {};\n    // $FlowFixMe: Ignore Flow complaining about needing a value\n    Object.defineProperty(options, 'passive', {\n      get: function() {\n        passiveBrowserEventsSupported = true;\n      },\n    });\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n  } catch (e) {\n    passiveBrowserEventsSupported = false;\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/EventListener.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventTarget.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/reflection.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/EnterLeaveEventPlugin.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/BeforeInputEventPlugin.js",["823","824"],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SimpleEventPlugin.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/DOMEventResponderSystem.js",["825","826","827","828","829","830","831","832","833"],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/DOMTopLevelEventTypes.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactCurrentFiber.js",["834","835","836","837"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  HostRoot,\n  HostPortal,\n  HostText,\n  Fragment,\n  ContextProvider,\n  ContextConsumer,\n} from 'shared/ReactWorkTags';\nimport describeComponentFrame from 'shared/describeComponentFrame';\nimport getComponentName from 'shared/getComponentName';\n\nconst ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\ntype LifeCyclePhase = 'render' | 'getChildContext';\n\nfunction describeFiber(fiber: Fiber): string {\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostPortal:\n    case HostText:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n      return '';\n    default:\n      const owner = fiber._debugOwner;\n      const source = fiber._debugSource;\n      const name = getComponentName(fiber.type);\n      let ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner.type);\n      }\n      return describeComponentFrame(name, source, ownerName);\n  }\n}\n\nexport function getStackByFiberInDevAndProd(workInProgress: Fiber): string {\n  let info = '';\n  let node = workInProgress;\n  do {\n    info += describeFiber(node);\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nexport let current: Fiber | null = null;\nexport let phase: LifeCyclePhase | null = null;\n\nexport function getCurrentFiberOwnerNameInDevOrNull(): string | null {\n  if (__DEV__) {\n    if (current === null) {\n      return null;\n    }\n    const owner = current._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner.type);\n    }\n  }\n  return null;\n}\n\nexport function getCurrentFiberStackInDev(): string {\n  if (__DEV__) {\n    if (current === null) {\n      return '';\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackByFiberInDevAndProd(current);\n  }\n  return '';\n}\n\nexport function resetCurrentFiber() {\n  if (__DEV__) {\n    ReactDebugCurrentFrame.getCurrentStack = null;\n    current = null;\n    phase = null;\n  }\n}\n\nexport function setCurrentFiber(fiber: Fiber) {\n  if (__DEV__) {\n    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\n    current = fiber;\n    phase = null;\n  }\n}\n\nexport function setCurrentPhase(lifeCyclePhase: LifeCyclePhase | null) {\n  if (__DEV__) {\n    phase = lifeCyclePhase;\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/ReactBrowserEventEmitter.js",["838"],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactDOMUnknownPropertyHook.js",["839","840","841"],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberReconciler.js",["842","843","844","845","846"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {\n  Instance,\n  TextInstance,\n  Container,\n  PublicInstance,\n} from './ReactFiberHostConfig';\nimport type {ReactNodeList} from 'shared/ReactTypes';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport {\n  findCurrentHostFiber,\n  findCurrentHostFiberWithNoPortals,\n} from 'react-reconciler/reflection';\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport {HostComponent, ClassComponent} from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {getPublicInstance} from './ReactFiberHostConfig';\nimport {\n  findCurrentUnmaskedContext,\n  processChildContext,\n  emptyContextObject,\n  isContextProvider as isLegacyContextProvider,\n} from './ReactFiberContext';\nimport {createFiberRoot} from './ReactFiberRoot';\nimport {injectInternals} from './ReactFiberDevToolsHook';\nimport {\n  computeUniqueAsyncExpiration,\n  requestCurrentTime,\n  computeExpirationForFiber,\n  scheduleWork,\n  flushRoot,\n  batchedUpdates,\n  unbatchedUpdates,\n  flushSync,\n  flushControlled,\n  deferredUpdates,\n  syncUpdates,\n  interactiveUpdates,\n  flushInteractiveUpdates,\n  flushPassiveEffects,\n} from './ReactFiberScheduler';\nimport {createUpdate, enqueueUpdate} from './ReactUpdateQueue';\nimport ReactFiberInstrumentation from './ReactFiberInstrumentation';\nimport {\n  getStackByFiberInDevAndProd,\n  phase as ReactCurrentFiberPhase,\n  current as ReactCurrentFiberCurrent,\n} from './ReactCurrentFiber';\nimport {StrictMode} from './ReactTypeOfMode';\nimport {Sync} from './ReactFiberExpirationTime';\n\ntype OpaqueRoot = FiberRoot;\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\ntype BundleType = 0 | 1;\n\ntype DevToolsConfig = {|\n  bundleType: BundleType,\n  version: string,\n  rendererPackageName: string,\n  // Note: this actually *does* depend on Fiber internal fields.\n  // Used by \"inspect clicked DOM element\" in React DevTools.\n  findFiberByHostInstance?: (instance: Instance | TextInstance) => Fiber,\n  // Used by RN in-app inspector.\n  // This API is unfortunately RN-specific.\n  // TODO: Change it to accept Fiber instead and type it properly.\n  getInspectorDataForViewTag?: (tag: number) => Object,\n|};\n\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(\n  parentComponent: ?React$Component<any, any>,\n): Object {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction scheduleRootUpdate(\n  current: Fiber,\n  element: ReactNodeList,\n  expirationTime: ExpirationTime,\n  callback: ?Function,\n) {\n  if (__DEV__) {\n    if (\n      ReactCurrentFiberPhase === 'render' &&\n      ReactCurrentFiberCurrent !== null &&\n      !didWarnAboutNestedUpdates\n    ) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack(\n        false,\n        'Render methods should be a pure function of props and state; ' +\n          'triggering nested component updates from render is not allowed. ' +\n          'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' +\n          'Check the render method of %s.',\n        getComponentName(ReactCurrentFiberCurrent.type) || 'Unknown',\n      );\n    }\n  }\n  // 创建一个 update，就是内部有几个属性的对象\n  const update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    warningWithoutStack(\n      typeof callback === 'function',\n      'render(...): Expected the last optional `callback` argument to be a ' +\n        'function. Instead received: %s.',\n      callback,\n    );\n    update.callback = callback;\n  }\n\n  flushPassiveEffects();\n  // 把 update 入队，内部就是一些创建或者获取 queue（链表结构），然后给链表添加一个节点的操作\n  enqueueUpdate(current, update);\n  scheduleWork(current, expirationTime);\n\n  return expirationTime;\n}\n\nexport function updateContainerAtExpirationTime(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  expirationTime: ExpirationTime,\n  callback: ?Function,\n) {\n  // TODO: If this is a nested container, this won't be the root.\n  // 和之前一样\n  const current = container.current;\n\n  if (__DEV__) {\n    if (ReactFiberInstrumentation.debugTool) {\n      if (current.alternate === null) {\n        ReactFiberInstrumentation.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n  // 获取 context 并赋值，这里肯定取不到值得，因为 parentComponent 为 null\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current, element, expirationTime, callback);\n}\n\nfunction findHostInstance(component: Object): PublicInstance | null {\n  const fiber = getInstance(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(\n        false,\n        'Argument appears to not be a ReactComponent. Keys: %s',\n        Object.keys(component),\n      );\n    }\n  }\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(\n  component: Object,\n  methodName: string,\n): PublicInstance | null {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(\n          false,\n          'Argument appears to not be a ReactComponent. Keys: %s',\n          Object.keys(component),\n        );\n      }\n    }\n    const hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    if (hostFiber.mode & StrictMode) {\n      const componentName = getComponentName(fiber.type) || 'Component';\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        if (fiber.mode & StrictMode) {\n          warningWithoutStack(\n            false,\n            '%s is deprecated in StrictMode. ' +\n              '%s was passed an instance of %s which is inside StrictMode. ' +\n              'Instead, add a ref directly to the element you want to reference.' +\n              '\\n%s' +\n              '\\n\\nLearn more about using refs safely here:' +\n              '\\nhttps://fb.me/react-strict-mode-find-node',\n            methodName,\n            methodName,\n            componentName,\n            getStackByFiberInDevAndProd(hostFiber),\n          );\n        } else {\n          warningWithoutStack(\n            false,\n            '%s is deprecated in StrictMode. ' +\n              '%s was passed an instance of %s which renders StrictMode children. ' +\n              'Instead, add a ref directly to the element you want to reference.' +\n              '\\n%s' +\n              '\\n\\nLearn more about using refs safely here:' +\n              '\\nhttps://fb.me/react-strict-mode-find-node',\n            methodName,\n            methodName,\n            componentName,\n            getStackByFiberInDevAndProd(hostFiber),\n          );\n        }\n      }\n    }\n    return hostFiber.stateNode;\n  }\n  return findHostInstance(component);\n}\n\nexport function createContainer(\n  containerInfo: Container,\n  isConcurrent: boolean,\n  hydrate: boolean,\n): OpaqueRoot {\n  return createFiberRoot(containerInfo, isConcurrent, hydrate);\n}\n\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): ExpirationTime {\n  // 取出容器的 fiber 对象，也就是 fiber root\n  const current = container.current;\n  // 计算时间\n  const currentTime = requestCurrentTime();\n  // expirationTime 代表优先级，数字越大优先级越高\n  // sync 的数字是最大的，所以优先级也是最高的\n  const expirationTime = computeExpirationForFiber(currentTime, current);\n  return updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback,\n  );\n}\n\nexport {\n  flushRoot,\n  computeUniqueAsyncExpiration,\n  batchedUpdates,\n  unbatchedUpdates,\n  deferredUpdates,\n  syncUpdates,\n  interactiveUpdates,\n  flushInteractiveUpdates,\n  flushControlled,\n  flushSync,\n  flushPassiveEffects,\n};\n\nexport function getPublicRootInstance(\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  const containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nexport {findHostInstance};\n\nexport {findHostInstanceWithWarning};\n\nexport function findHostInstanceWithNoPortals(\n  fiber: Fiber,\n): PublicInstance | null {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber: Fiber): boolean {\n  return shouldSuspendImpl(fiber);\n}\n\nlet overrideHookState = null;\nlet overrideProps = null;\nlet scheduleUpdate = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithSetImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    idx: number,\n    value: any,\n  ) => {\n    if (idx >= path.length) {\n      return value;\n    }\n    const key = path[idx];\n    const updated = Array.isArray(obj) ? obj.slice() : {...obj};\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    value: any,\n  ): Object | Array<any> => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  // Support DevTools editable values for useState and useReducer.\n  overrideHookState = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n    value: any,\n  ) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n    if (currentHook !== null) {\n      flushPassiveEffects();\n\n      const newState = copyWithSet(currentHook.memoizedState, path, value);\n      currentHook.memoizedState = newState;\n      currentHook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      scheduleWork(fiber, Sync);\n    }\n  };\n\n  // Support DevTools props for function components, forwardRef, memo, host components, etc.\n  overrideProps = (fiber: Fiber, path: Array<string | number>, value: any) => {\n    flushPassiveEffects();\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    scheduleWork(fiber, Sync);\n  };\n\n  scheduleUpdate = (fiber: Fiber) => {\n    flushPassiveEffects();\n    scheduleWork(fiber, Sync);\n  };\n\n  setSuspenseHandler = (newShouldSuspendImpl: Fiber => boolean) => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nexport function injectIntoDevTools(devToolsConfig: DevToolsConfig): boolean {\n  const {findFiberByHostInstance} = devToolsConfig;\n  const {ReactCurrentDispatcher} = ReactSharedInternals;\n\n  return injectInternals({\n    ...devToolsConfig,\n    overrideHookState,\n    overrideProps,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | null {\n      const hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findFiberByHostInstance(instance: Instance | TextInstance): Fiber | null {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n      return findFiberByHostInstance(instance);\n    },\n  });\n}\n","/Users/wxj/locality/my-debug/src/react/packages/shared/describeComponentFrame.js",["847"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nexport default function(\n  name: null | string,\n  source: any,\n  ownerName: null | string,\n) {\n  let sourceInfo = '';\n  if (source) {\n    let path = source.fileName;\n    let fileName = path.replace(BEFORE_SLASH_RE, '');\n    if (__DEV__) {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        const match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          const pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/sanitizeURL.js",["848","849"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {disableJavaScriptURLs} from 'shared/ReactFeatureFlags';\n\nlet ReactDebugCurrentFrame = ((null: any): {getStackAddendum(): string});\nif (__DEV__) {\n  ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n}\n\n// A javascript: URL can contain leading C0 control or \\u0020 SPACE,\n// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n\n/* eslint-disable max-len */\nconst isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n\nlet didWarn = false;\n\nfunction sanitizeURL(url: string) {\n  if (disableJavaScriptURLs) {\n    invariant(\n      !isJavaScriptProtocol.test(url),\n      'React has blocked a javascript: URL as a security precaution.%s',\n      __DEV__ ? ReactDebugCurrentFrame.getStackAddendum() : '',\n    );\n  } else if (__DEV__ && !didWarn && isJavaScriptProtocol.test(url)) {\n    didWarn = true;\n    warning(\n      false,\n      'A future version of React will block javascript: URLs as a security precaution. ' +\n        'Use event handlers instead if you can. If you need to generate unsafe HTML try ' +\n        'using dangerouslySetInnerHTML instead. React was passed %s.',\n      JSON.stringify(url),\n    );\n  }\n}\n\nexport default sanitizeURL;\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/ReactControlledValuePropTypes.js",["850","851"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nlet ReactDebugCurrentFrame = null;\n\nconst ReactControlledValuePropTypes = {\n  checkPropTypes: null,\n};\n\nif (__DEV__) {\n  ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n  const hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true,\n  };\n\n  const propTypes = {\n    value: function(props, propName, componentName) {\n      if (\n        hasReadOnlyValue[props.type] ||\n        props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        props[propName] == null\n      ) {\n        return null;\n      }\n      return new Error(\n        'You provided a `value` prop to a form field without an ' +\n          '`onChange` handler. This will render a read-only field. If ' +\n          'the field should be mutable use `defaultValue`. Otherwise, ' +\n          'set either `onChange` or `readOnly`.',\n      );\n    },\n    checked: function(props, propName, componentName) {\n      if (\n        props.onChange ||\n        props.readOnly ||\n        props.disabled ||\n        props[propName] == null\n      ) {\n        return null;\n      }\n      return new Error(\n        'You provided a `checked` prop to a form field without an ' +\n          '`onChange` handler. This will render a read-only field. If ' +\n          'the field should be mutable use `defaultChecked`. Otherwise, ' +\n          'set either `onChange` or `readOnly`.',\n      );\n    },\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function(tagName, props) {\n    checkPropTypes(\n      propTypes,\n      props,\n      'prop',\n      tagName,\n      ReactDebugCurrentFrame.getStackAddendum,\n    );\n  };\n}\n\nexport default ReactControlledValuePropTypes;\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ToStringValue.js",["852","853","854"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport opaque type ToStringValue =\n  | boolean\n  | number\n  | Object\n  | string\n  | null\n  | void;\n\n// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nexport function toString(value: ToStringValue): string {\n  return '' + (value: any);\n}\n\nexport function getToStringValue(value: mixed): ToStringValue {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'object':\n    case 'string':\n    case 'undefined':\n      return value;\n    default:\n      // function, symbol are assigned as empty strings\n      return '';\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/createMicrosoftUnsafeLocalFunction.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/CSSShorthandProperty.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/dangerousStyleValue.js",["855"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isUnitlessNumber} from './CSSProperty';\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  const isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (\n    !isCustomProperty &&\n    typeof value === 'number' &&\n    value !== 0 &&\n    !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])\n  ) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nexport default dangerousStyleValue;\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/hyphenateStyleName.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/warnValidStyle.js",["856","857","858","859","860"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport warning from 'shared/warning';\n\nlet warnValidStyle = () => {};\n\nif (__DEV__) {\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  const badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n  const msPattern = /^-ms-/;\n  const hyphenPattern = /-(.)/g;\n\n  // style values shouldn't contain a semicolon\n  const badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  const warnedStyleNames = {};\n  const warnedStyleValues = {};\n  let warnedForNaNValue = false;\n  let warnedForInfinityValue = false;\n\n  const camelize = function(string) {\n    return string.replace(hyphenPattern, function(_, character) {\n      return character.toUpperCase();\n    });\n  };\n\n  const warnHyphenatedStyleName = function(name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(\n      false,\n      'Unsupported style property %s. Did you mean %s?',\n      name,\n      // As Andi Smith suggests\n      // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n      // is converted to lowercase `ms`.\n      camelize(name.replace(msPattern, 'ms-')),\n    );\n  };\n\n  const warnBadVendoredStyleName = function(name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(\n      false,\n      'Unsupported vendor-prefixed style property %s. Did you mean %s?',\n      name,\n      name.charAt(0).toUpperCase() + name.slice(1),\n    );\n  };\n\n  const warnStyleValueWithSemicolon = function(name, value) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(\n      false,\n      \"Style property values shouldn't contain a semicolon. \" +\n        'Try \"%s: %s\" instead.',\n      name,\n      value.replace(badStyleValueWithSemicolonPattern, ''),\n    );\n  };\n\n  const warnStyleValueIsNaN = function(name, value) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(\n      false,\n      '`NaN` is an invalid value for the `%s` css style property.',\n      name,\n    );\n  };\n\n  const warnStyleValueIsInfinity = function(name, value) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(\n      false,\n      '`Infinity` is an invalid value for the `%s` css style property.',\n      name,\n    );\n  };\n\n  warnValidStyle = function(name, value) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value);\n      }\n    }\n  };\n}\n\nexport default warnValidStyle;\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/validAriaProperties.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/voidElementTags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/isEventSupported.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/isTextInputElement.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/getActiveElement.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactInputSelection.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/shallowEqual.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberTreeReflection.js",["861","862","863","864"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\n\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport getComponentName from 'shared/getComponentName';\nimport {\n  ClassComponent,\n  HostComponent,\n  HostRoot,\n  HostPortal,\n  HostText,\n} from 'shared/ReactWorkTags';\nimport {NoEffect, Placement} from 'shared/ReactSideEffectTags';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nconst MOUNTING = 1;\nconst MOUNTED = 2;\nconst UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber: Fiber): number {\n  let node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nexport function isFiberMounted(fiber: Fiber): boolean {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nexport function isMounted(component: React$Component<any, any>): boolean {\n  if (__DEV__) {\n    const owner = (ReactCurrentOwner.current: any);\n    if (owner !== null && owner.tag === ClassComponent) {\n      const ownerFiber: Fiber = owner;\n      const instance = ownerFiber.stateNode;\n      warningWithoutStack(\n        instance._warnedAboutRefsInRender,\n        '%s is accessing isMounted inside its render() function. ' +\n          'render() should be a pure function of props and state. It should ' +\n          'never access something that requires stale data from the previous ' +\n          'render, such as refs. Move this logic to componentDidMount and ' +\n          'componentDidUpdate instead.',\n        getComponentName(ownerFiber.type) || 'A component',\n      );\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  const fiber: ?Fiber = getInstance(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    'Unable to find node on an unmounted component.',\n  );\n}\n\nexport function findCurrentFiberUsingSlowPath(fiber: Fiber): Fiber | null {\n  let alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    const state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      'Unable to find node on an unmounted component.',\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  let a: Fiber = fiber;\n  let b: Fiber = alternate;\n  while (true) {\n    let parentA = a.return;\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n    let parentB = parentA.alternate;\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      const nextParent = parentA.return;\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      }\n      // If there's no parent, we're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child = child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        child = parentB.child;\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child = child.sibling;\n        }\n        invariant(\n          didFindChild,\n          'Child was not found in either parent set. This indicates a bug ' +\n            'in React related to the return pointer. Please file an issue.',\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    'Unable to find node on an unmounted component.',\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nexport function findCurrentHostFiber(parent: Fiber): Fiber | null {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  let node: Fiber = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nexport function findCurrentHostFiberWithNoPortals(parent: Fiber): Fiber | null {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  let node: Fiber = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticMouseEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticPointerEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/FallbackCompositionState.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticFocusEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticDragEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticTouchEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticKeyboardEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticWheelEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventCharCode.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactErrorUtils.js",["865","866","867","868","869","870","871","872","873","874","875","876","877","878","879","880","881","882"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\nimport invokeGuardedCallbackImpl from './invokeGuardedCallbackImpl';\n\n// Used by Fiber to simulate a try-catch.\nlet hasError: boolean = false;\nlet caughtError: mixed = null;\n\n// Used by event system to capture/rethrow the first error.\nlet hasRethrowError: boolean = false;\nlet rethrowError: mixed = null;\n\nconst reporter = {\n  onError(error: mixed) {\n    hasError = true;\n    caughtError = error;\n  },\n};\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nexport function invokeGuardedCallback<A, B, C, D, E, F, Context>(\n  name: string | null,\n  func: (a: A, b: B, c: C, d: D, e: E, f: F) => mixed,\n  context: Context,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n): void {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl.apply(reporter, arguments);\n}\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nexport function invokeGuardedCallbackAndCatchFirstError<\n  A,\n  B,\n  C,\n  D,\n  E,\n  F,\n  Context,\n>(\n  name: string | null,\n  func: (a: A, b: B, c: C, d: D, e: E, f: F) => void,\n  context: Context,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n): void {\n  invokeGuardedCallback.apply(this, arguments);\n  if (hasError) {\n    const error = clearCaughtError();\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\nexport function rethrowCaughtError() {\n  if (hasRethrowError) {\n    const error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\n\nexport function hasCaughtError() {\n  return hasError;\n}\n\nexport function clearCaughtError() {\n  if (hasError) {\n    const error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(\n      false,\n      'clearCaughtError was called but no error was captured. This error ' +\n        'is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getVendorPrefixedEventName.js",["883"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  const prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nconst vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd'),\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nconst prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nlet style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  const prefixMap = vendorPrefixes[eventName];\n\n  for (const styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\n    }\n  }\n\n  return eventName;\n}\n\nexport default getVendorPrefixedEventName;\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberContext.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberRoot.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberDevToolsHook.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberScheduler.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberInstrumentation.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactTypeOfMode.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactUpdateQueue.js",["884"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  enterDisallowedContextReadInDEV,\n  exitDisallowedContextReadInDEV,\n} from './ReactFiberNewContext';\nimport {Callback, ShouldCapture, DidCapture} from 'shared/ReactSideEffectTags';\nimport {ClassComponent} from 'shared/ReactWorkTags';\n\nimport {\n  debugRenderPhaseSideEffects,\n  debugRenderPhaseSideEffectsForStrictMode,\n} from 'shared/ReactFeatureFlags';\n\nimport {StrictMode} from './ReactTypeOfMode';\n\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nexport type Update<State> = {\n  expirationTime: ExpirationTime,\n\n  tag: 0 | 1 | 2 | 3,\n  payload: any,\n  callback: (() => mixed) | null,\n\n  next: Update<State> | null,\n  nextEffect: Update<State> | null,\n};\n\nexport type UpdateQueue<State> = {\n  baseState: State,\n\n  firstUpdate: Update<State> | null,\n  lastUpdate: Update<State> | null,\n\n  firstCapturedUpdate: Update<State> | null,\n  lastCapturedUpdate: Update<State> | null,\n\n  firstEffect: Update<State> | null,\n  lastEffect: Update<State> | null,\n\n  firstCapturedEffect: Update<State> | null,\n  lastCapturedEffect: Update<State> | null,\n};\n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nlet hasForceUpdate = false;\n\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function createUpdateQueue<State>(baseState: State): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    baseState,\n    // 链表头\n    firstUpdate: null,\n    // 链表尾\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue<State>(\n  currentQueue: UpdateQueue<State>,\n): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n\nexport function createUpdate(expirationTime: ExpirationTime): Update<*> {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    // setState 的第一二个参数\n    payload: null,\n    callback: null,\n    // 用于在队列中找到下一个节点\n    next: null,\n    nextEffect: null,\n  };\n}\n\nfunction appendUpdateToQueue<State>(\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nexport function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {\n  // Update queues are created lazily.\n  // 获取 fiber 的镜像\n  const alternate = fiber.alternate;\n  let queue1;\n  let queue2;\n  // 第一次 render 的时候肯定是没有这个镜像的，所以进第一个条件\n  if (alternate === null) {\n    // There's only one fiber.\n    // 一开始也没这个 queue，所以需要创建一次\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      // UpdateQueue 是一个链表组成的队列\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    // 以下就是在判断 q1、q2 存不存在了，不存在的话就赋值一遍\n    // clone 的意义也是为了节省开销\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState,\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  // 获取队列操作完毕以后，就开始入队了\n  // 以下的代码很简单，熟悉链表的应该清楚链表添加一个节点的逻辑\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list — we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  if (__DEV__) {\n    if (\n      fiber.tag === ClassComponent &&\n      (currentlyProcessingQueue === queue1 ||\n        (queue2 !== null && currentlyProcessingQueue === queue2)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warningWithoutStack(\n        false,\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nexport function enqueueCapturedUpdate<State>(\n  workInProgress: Fiber,\n  update: Update<State>,\n) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  let workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(\n      workInProgress.memoizedState,\n    );\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(\n      workInProgress,\n      workInProgressQueue,\n    );\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n): UpdateQueue<State> {\n  const current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n  prevState: State,\n  nextProps: any,\n  instance: any,\n): any {\n  switch (update.tag) {\n    case ReplaceState: {\n      const payload = update.payload;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            payload.call(instance, prevState, nextProps);\n          }\n        }\n        const nextState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          exitDisallowedContextReadInDEV();\n        }\n        return nextState;\n      }\n      // State object\n      return payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.effectTag =\n        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      const payload = update.payload;\n      let partialState;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            payload.call(instance, prevState, nextProps);\n          }\n        }\n        partialState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          exitDisallowedContextReadInDEV();\n        }\n      } else {\n        // Partial state object\n        partialState = payload;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nexport function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  props: any,\n  instance: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  hasForceUpdate = false;\n  // 获取的 queue 是在 WorkInProgress 上被拷贝的那份\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  let newBaseState = queue.baseState;\n  let newFirstUpdate = null;\n  let newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  let update = queue.firstUpdate;\n  let resultState = newBaseState;\n  // 遍历链表\n  while (update !== null) {\n    const updateExpirationTime = update.expirationTime;\n    // 判断优先级，是否需要跳过这个更新\n    if (updateExpirationTime < renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime < updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      // 获取 state\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance,\n      );\n      // 处理 callback\n      const callback = update.callback;\n      if (callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  // CapturedUpdate 不需要去关注\n  let newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    const updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime < renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime < updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance,\n      );\n      const callback = update.callback;\n      if (callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n\n  // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(\n    typeof callback === 'function',\n    'Invalid argument passed as callback. Expected a function. Instead ' +\n      'received: %s',\n    callback,\n  );\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nexport function checkHasForceUpdateAfterProcessing(): boolean {\n  return hasForceUpdate;\n}\n\nexport function commitUpdateQueue<State>(\n  finishedWork: Fiber,\n  finishedQueue: UpdateQueue<State>,\n  instance: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects<State>(\n  effect: Update<State> | null,\n  instance: any,\n): void {\n  while (effect !== null) {\n    const callback = effect.callback;\n    if (callback !== null) {\n      effect.callback = null;\n      callCallback(callback, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberExpirationTime.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticCompositionEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticAnimationEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticInputEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticClipboardEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticUIEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/SyntheticTransitionEvent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHostConfig.js",["885"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\n\n// We expect that our Rollup, Jest, and Flow configurations\n// always shim this module with the corresponding host config\n// (either provided by a renderer, or a generic shim for npm).\n//\n// We should never resolve to this file, but it exists to make\n// sure that if we *do* accidentally break the configuration,\n// the failure isn't silent.\n\n// invariant(false, 'This module must be shimmed by a specific renderer.');\nexport * from './forks/ReactFiberHostConfig.dom';\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/CSSProperty.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/shared/omittedCloseTags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMSelection.js",["886","887","888"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getNodeForCharacterOffset from './getNodeForCharacterOffset';\nimport {TEXT_NODE} from '../shared/HTMLNodeType';\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nexport function getOffsets(outerNode) {\n  const {ownerDocument} = outerNode;\n  const win = (ownerDocument && ownerDocument.defaultView) || window;\n  const selection = win.getSelection && win.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  const {anchorNode, anchorOffset, focusNode, focusOffset} = selection;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(\n    outerNode,\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n  );\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nexport function getModernOffsetsFromPoints(\n  outerNode,\n  anchorNode,\n  anchorOffset,\n  focusNode,\n  focusOffset,\n) {\n  let length = 0;\n  let start = -1;\n  let end = -1;\n  let indexWithinAnchor = 0;\n  let indexWithinFocus = 0;\n  let node = outerNode;\n  let parentNode = null;\n\n  outer: while (true) {\n    let next = null;\n\n    while (true) {\n      if (\n        node === anchorNode &&\n        (anchorOffset === 0 || node.nodeType === TEXT_NODE)\n      ) {\n        start = length + anchorOffset;\n      }\n      if (\n        node === focusNode &&\n        (focusOffset === 0 || node.nodeType === TEXT_NODE)\n      ) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end,\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nexport function setOffsets(node, offsets) {\n  const doc = node.ownerDocument || document;\n  const win = (doc && doc.defaultView) || window;\n\n  // Edge fails with \"Object expected\" in some scenarios.\n  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n  // fails when pasting 100+ items)\n  if (!win.getSelection) {\n    return;\n  }\n\n  const selection = win.getSelection();\n  const length = node.textContent.length;\n  let start = Math.min(offsets.start, length);\n  let end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    let temp = end;\n    end = start;\n    start = temp;\n  }\n\n  const startMarker = getNodeForCharacterOffset(node, start);\n  const endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (\n      selection.rangeCount === 1 &&\n      selection.anchorNode === startMarker.node &&\n      selection.anchorOffset === startMarker.offset &&\n      selection.focusNode === endMarker.node &&\n      selection.focusOffset === endMarker.offset\n    ) {\n      return;\n    }\n    const range = doc.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/shared/ReactSideEffectTags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventModifierState.js",["889"],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/events/getEventKey.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/invokeGuardedCallbackImpl.js",["890","891","892","893","894","895","896","897","898","899","900","901","902"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\n\nlet invokeGuardedCallbackImpl = function<A, B, C, D, E, F, Context>(\n  name: string | null,\n  func: (a: A, b: B, c: C, d: D, e: E, f: F) => mixed,\n  context: Context,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n) {\n  const funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n};\n\nif (__DEV__) {\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.dispatchEvent === 'function' &&\n    typeof document !== 'undefined' &&\n    typeof document.createEvent === 'function'\n  ) {\n    const fakeNode = document.createElement('react');\n\n    const invokeGuardedCallbackDev = function<A, B, C, D, E, F, Context>(\n      name: string | null,\n      func: (a: A, b: B, c: C, d: D, e: E, f: F) => mixed,\n      context: Context,\n      a: A,\n      b: B,\n      c: C,\n      d: D,\n      e: E,\n      f: F,\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== 'undefined',\n        'The `document` global was defined when React was initialized, but is not ' +\n          'defined anymore. This can happen in a test environment if a component ' +\n          'schedules an update from an asynchronous callback, but the test has already ' +\n          'finished running. To solve this, you can either unmount the component at ' +\n          'the end of your test (and ensure that any asynchronous operations get ' +\n          'canceled in `componentWillUnmount`), or you can change the test itself ' +\n          'to be asynchronous.',\n      );\n      const evt = document.createEvent('Event');\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      let didError = true;\n\n      // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n      let windowEvent = window.event;\n\n      // Keeps track of the descriptor of window.event to restore it after event\n      // dispatching: https://github.com/facebook/react/issues/13688\n      const windowEventDescriptor = Object.getOwnPropertyDescriptor(\n        window,\n        'event',\n      );\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      const funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n\n        // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n        if (\n          typeof window.event !== 'undefined' &&\n          window.hasOwnProperty('event')\n        ) {\n          window.event = windowEvent;\n        }\n\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      let error;\n      // Use this to track whether the error event is ever called.\n      let didSetError = false;\n      let isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {\n              // Ignore.\n            }\n          }\n        }\n      }\n\n      // Create a fake event type.\n      const evtType = `react-${name ? name : 'invokeguardedcallback'}`;\n\n      // Attach our event handlers\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (windowEventDescriptor) {\n        Object.defineProperty(window, 'event', windowEventDescriptor);\n      }\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            'An error was thrown inside one of your components, but React ' +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              'your browser. Try triggering the error in production mode, ' +\n              'or switching to a modern browser. If you suspect that this is ' +\n              'actually an issue with React, please file an issue.',\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              'the actual error object in development. ' +\n              'See https://fb.me/react-crossorigin-error for more information.',\n          );\n        }\n        this.onError(error);\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', handleWindowError);\n    };\n\n    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\n  }\n}\n\nexport default invokeGuardedCallbackImpl;\n","/Users/wxj/locality/my-debug/src/react/packages/shared/objectIs.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberStack.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactDebugFiberPerf.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiber.js",["903"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement, Source} from 'shared/ReactElementType';\nimport type {\n  ReactFragment,\n  ReactPortal,\n  RefObject,\n  ReactEventComponent,\n  ReactEventTarget,\n} from 'shared/ReactTypes';\nimport type {WorkTag} from 'shared/ReactWorkTags';\nimport type {TypeOfMode} from './ReactTypeOfMode';\nimport type {SideEffectTag} from 'shared/ReactSideEffectTags';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {UpdateQueue} from './ReactUpdateQueue';\nimport type {ContextDependencyList} from './ReactFiberNewContext';\nimport type {HookType} from './ReactFiberHooks';\n\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {enableProfilerTimer, enableEventAPI} from 'shared/ReactFeatureFlags';\nimport {NoEffect} from 'shared/ReactSideEffectTags';\nimport {\n  IndeterminateComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ForwardRef,\n  Fragment,\n  Mode,\n  ContextProvider,\n  ContextConsumer,\n  Profiler,\n  SuspenseComponent,\n  FunctionComponent,\n  MemoComponent,\n  LazyComponent,\n  EventComponent,\n  EventTarget,\n} from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\n\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook';\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  NoContext,\n  ConcurrentMode,\n  ProfileMode,\n  StrictMode,\n} from './ReactTypeOfMode';\nimport {\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_EVENT_COMPONENT_TYPE,\n  REACT_EVENT_TARGET_TYPE,\n} from 'shared/ReactSymbols';\n\nlet hasBadMapPolyfill;\n\nif (__DEV__) {\n  hasBadMapPolyfill = false;\n  try {\n    const nonExtensibleObject = Object.preventExtensions({});\n    const testMap = new Map([[nonExtensibleObject, null]]);\n    const testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\nexport type Fiber = {|\n  // These first fields are conceptually members of an Instance. This used to\n  // be split into a separate type and intersected with the other Fiber fields,\n  // but until Flow fixes its intersection bugs, we've merged them into a\n  // single type.\n\n  // An Instance is shared between all versions of a component. We can easily\n  // break this out into a separate object to avoid copying so much to the\n  // alternate versions of the tree. We put this on a single object for now to\n  // minimize the number of objects created during the initial render.\n\n  // Tag identifying the type of fiber.\n  tag: WorkTag,\n\n  // Unique identifier of this child.\n  key: null | string,\n\n  // The value of element.type which is used to preserve the identity during\n  // reconciliation of this child.\n  elementType: any,\n\n  // The resolved function/class/ associated with this fiber.\n  type: any,\n\n  // The local state associated with this fiber.\n  stateNode: any,\n\n  // Conceptual aliases\n  // parent : Instance -> return The parent happens to be the same as the\n  // return fiber since we've merged the fiber and instance.\n\n  // Remaining fields belong to Fiber\n\n  // The Fiber to return to after finishing processing this one.\n  // This is effectively the parent, but there can be multiple parents (two)\n  // so this is only the parent of the thing we're currently processing.\n  // It is conceptually the same as the return address of a stack frame.\n  // 以上三个属性用来构建 fiber tree\n  return: Fiber | null,\n\n  // Singly Linked List Tree Structure.\n  child: Fiber | null,\n  sibling: Fiber | null,\n  index: number,\n\n  // The ref last used to attach this node.\n  // I'll avoid adding an owner field for prod and model that as functions.\n  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}) | RefObject,\n\n  // Input is the data coming into process this fiber. Arguments. Props.\n  pendingProps: any, // This type will be more specific once we overload the tag.\n  memoizedProps: any, // The props used to create the output.\n\n  // A queue of state updates and callbacks.\n  // 用来存放 update，也就是用来记录改变状态的\n  updateQueue: UpdateQueue<any> | null,\n\n  // The state used to create the output\n  memoizedState: any,\n\n  // A linked-list of contexts that this fiber depends on\n  contextDependencies: ContextDependencyList | null,\n\n  // Bitfield that describes properties about the fiber and its subtree. E.g.\n  // the ConcurrentMode flag indicates whether the subtree should be async-by-\n  // default. When a fiber is created, it inherits the mode of its\n  // parent. Additional flags can be set at creation time, but after that the\n  // value should remain unchanged throughout the fiber's lifetime, particularly\n  // before its child fibers are created.\n  mode: TypeOfMode,\n\n  // Effect\n  // 这个属性很有意思，用来打标记的，用于告知这个节点上要做些什么 DOM 操作\n  // 你可以在后续的代码中看到很多关于 tag 的位运算\n  effectTag: SideEffectTag,\n\n  // Singly linked list fast path to the next fiber with side-effects.\n  nextEffect: Fiber | null,\n\n  // The first and last fiber with side-effect within this subtree. This allows\n  // us to reuse a slice of the linked list when we reuse the work done within\n  // this fiber.\n  firstEffect: Fiber | null,\n  lastEffect: Fiber | null,\n\n  // Represents a time in the future by which this work should be completed.\n  // Does not include work found in its subtree.\n  expirationTime: ExpirationTime,\n\n  // This is used to quickly determine if a subtree has no pending changes.\n  childExpirationTime: ExpirationTime,\n\n  // This is a pooled version of a Fiber. Every fiber that gets updated will\n  // eventually have a pair. There are cases when we can clean up pairs to save\n  // memory if we need to.\n  // 一般来说我们应用中会有 2 个 fiber tree\n  // 一个是 old tree，一个是 workInProgress tree\n  // 前者是已经渲染好的 DOM 树对应的 fiber tree\n  // 后者是正在执行更新中的 fiber tree，还能便于中断后恢复\n  // 两颗树还是相互引用的，便于共享内部的一些属性\n  // 当更新结束以后，workInProgress tree 会变成 old tree\n  // 这样的做法称之为 double buffering\n  alternate: Fiber | null,\n\n  // Time spent rendering this Fiber and its descendants for the current update.\n  // This tells us how well the tree makes use of sCU for memoization.\n  // It is reset to 0 each time we render and only updated when we don't bailout.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualDuration?: number,\n\n  // If the Fiber is currently active in the \"render\" phase,\n  // This marks the time at which the work began.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualStartTime?: number,\n\n  // Duration of the most recent render time for this Fiber.\n  // This value is not updated when we bailout for memoization purposes.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  selfBaseDuration?: number,\n\n  // Sum of base times for all descedents of this Fiber.\n  // This value bubbles up during the \"complete\" phase.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  treeBaseDuration?: number,\n\n  // Conceptual aliases\n  // workInProgress : Fiber ->  alternate The alternate used for reuse happens\n  // to be the same as work in progress.\n  // __DEV__ only\n  _debugID?: number,\n  _debugSource?: Source | null,\n  _debugOwner?: Fiber | null,\n  _debugIsCurrentlyTiming?: boolean,\n\n  // Used to verify that the order of hooks does not change between renders.\n  _debugHookTypes?: Array<HookType> | null,\n|};\n\nlet debugCounter;\n\nif (__DEV__) {\n  debugCounter = 1;\n}\n\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  // 对于 FiberNode 中的属性，我们当下只需要以下几点\n  // stateNode 保存了每个节点的 DOM 信息\n  // return、child、sibling、index 组成了单链表树结构\n  // return 代表父 fiber，child 代表子 fiber、sibling 代表下一个兄弟节点，和链表中的 next 一个含义\n  // index 代表了当前 fiber 的索引\n  // 另外还有一个 alternate 属性很重要，这个属性代表了一个更新中的 fiber，这部分的内容后面会涉及到\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.contextDependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  if (__DEV__) {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    this._debugHookTypes = null;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component: Function) {\n  const prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nexport function isSimpleFunctionComponent(type: any) {\n  return (\n    typeof type === 'function' &&\n    !shouldConstruct(type) &&\n    type.defaultProps === undefined\n  );\n}\n\nexport function resolveLazyComponentTag(Component: Function): WorkTag {\n  if (typeof Component === 'function') {\n    return shouldConstruct(Component) ? ClassComponent : FunctionComponent;\n  } else if (Component !== undefined && Component !== null) {\n    const $$typeof = Component.$$typeof;\n    if ($$typeof === REACT_FORWARD_REF_TYPE) {\n      return ForwardRef;\n    }\n    if ($$typeof === REACT_MEMO_TYPE) {\n      return MemoComponent;\n    }\n  }\n  return IndeterminateComponent;\n}\n\n// This is used to create an alternate fiber to do work on.\nexport function createWorkInProgress(\n  current: Fiber,\n  pendingProps: any,\n  expirationTime: ExpirationTime,\n): Fiber {\n  let workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode,\n    );\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    if (__DEV__) {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n      workInProgress._debugHookTypes = current._debugHookTypes;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  workInProgress.expirationTime = current.expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.contextDependencies = current.contextDependencies;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  return workInProgress;\n}\n\nexport function createHostRootFiber(isConcurrent: boolean): Fiber {\n  let mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point–\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nexport function createFiberFromTypeAndProps(\n  type: any, // React$ElementType\n  key: null | string,\n  pendingProps: any,\n  owner: null | Fiber,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n): Fiber {\n  let fiber;\n\n  let fiberTag = IndeterminateComponent;\n  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n  let resolvedType = type;\n  if (typeof type === 'function') {\n    if (shouldConstruct(type)) {\n      fiberTag = ClassComponent;\n    }\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key,\n        );\n      case REACT_CONCURRENT_MODE_TYPE:\n        return createFiberFromMode(\n          pendingProps,\n          mode | ConcurrentMode | StrictMode,\n          expirationTime,\n          key,\n        );\n      case REACT_STRICT_MODE_TYPE:\n        return createFiberFromMode(\n          pendingProps,\n          mode | StrictMode,\n          expirationTime,\n          key,\n        );\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_SUSPENSE_TYPE:\n        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);\n      default: {\n        if (typeof type === 'object' && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n              fiberTag = ContextProvider;\n              break getTag;\n            case REACT_CONTEXT_TYPE:\n              // This is a consumer\n              fiberTag = ContextConsumer;\n              break getTag;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = ForwardRef;\n              break getTag;\n            case REACT_MEMO_TYPE:\n              fiberTag = MemoComponent;\n              break getTag;\n            case REACT_LAZY_TYPE:\n              fiberTag = LazyComponent;\n              resolvedType = null;\n              break getTag;\n            case REACT_EVENT_COMPONENT_TYPE:\n              if (enableEventAPI) {\n                return createFiberFromEventComponent(\n                  type,\n                  pendingProps,\n                  mode,\n                  expirationTime,\n                  key,\n                );\n              }\n              break;\n            case REACT_EVENT_TARGET_TYPE:\n              if (enableEventAPI) {\n                return createFiberFromEventTarget(\n                  type,\n                  pendingProps,\n                  mode,\n                  expirationTime,\n                  key,\n                );\n              }\n              break;\n          }\n        }\n        let info = '';\n        if (__DEV__) {\n          if (\n            type === undefined ||\n            (typeof type === 'object' &&\n              type !== null &&\n              Object.keys(type).length === 0)\n          ) {\n            info +=\n              ' You likely forgot to export your component from the file ' +\n              \"it's defined in, or you might have mixed up default and \" +\n              'named imports.';\n          }\n          const ownerName = owner ? getComponentName(owner.type) : null;\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(\n          false,\n          'Element type is invalid: expected a string (for built-in ' +\n            'components) or a class/function (for composite components) ' +\n            'but got: %s.%s',\n          type == null ? type : typeof type,\n          info,\n        );\n      }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.elementType = type;\n  fiber.type = resolvedType;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nexport function createFiberFromElement(\n  element: ReactElement,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n): Fiber {\n  let owner = null;\n  if (__DEV__) {\n    owner = element._owner;\n  }\n  const type = element.type;\n  const key = element.key;\n  const pendingProps = element.props;\n  const fiber = createFiberFromTypeAndProps(\n    type,\n    key,\n    pendingProps,\n    owner,\n    mode,\n    expirationTime,\n  );\n  if (__DEV__) {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n  return fiber;\n}\n\nexport function createFiberFromFragment(\n  elements: ReactFragment,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n  key: null | string,\n): Fiber {\n  const fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nexport function createFiberFromEventComponent(\n  eventComponent: ReactEventComponent,\n  pendingProps: any,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n  key: null | string,\n): Fiber {\n  const fiber = createFiber(EventComponent, pendingProps, key, mode);\n  fiber.elementType = eventComponent;\n  fiber.type = eventComponent;\n  fiber.stateNode = {\n    context: null,\n    props: pendingProps,\n    rootInstance: null,\n    state: null,\n  };\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nexport function createFiberFromEventTarget(\n  eventTarget: ReactEventTarget,\n  pendingProps: any,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n  key: null | string,\n): Fiber {\n  const fiber = createFiber(EventTarget, pendingProps, key, mode);\n  fiber.elementType = eventTarget;\n  fiber.type = eventTarget;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(\n  pendingProps: any,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n  key: null | string,\n): Fiber {\n  if (__DEV__) {\n    if (\n      typeof pendingProps.id !== 'string' ||\n      typeof pendingProps.onRender !== 'function'\n    ) {\n      warningWithoutStack(\n        false,\n        'Profiler must specify an \"id\" string and \"onRender\" function as props',\n      );\n    }\n  }\n\n  const fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  // TODO: The Profiler fiber shouldn't have a type. It has a tag.\n  fiber.elementType = REACT_PROFILER_TYPE;\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromMode(\n  pendingProps: any,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n  key: null | string,\n): Fiber {\n  const fiber = createFiber(Mode, pendingProps, key, mode);\n\n  // TODO: The Mode fiber shouldn't have a type. It has a tag.\n  const type =\n    (mode & ConcurrentMode) === NoContext\n      ? REACT_STRICT_MODE_TYPE\n      : REACT_CONCURRENT_MODE_TYPE;\n  fiber.elementType = type;\n  fiber.type = type;\n\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nexport function createFiberFromSuspense(\n  pendingProps: any,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n  key: null | string,\n) {\n  const fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n\n  // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.\n  const type = REACT_SUSPENSE_TYPE;\n  fiber.elementType = type;\n  fiber.type = type;\n\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nexport function createFiberFromText(\n  content: string,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n): Fiber {\n  const fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nexport function createFiberFromHostInstanceForDeletion(): Fiber {\n  const fiber = createFiber(HostComponent, null, null, NoContext);\n  // TODO: These should not need a type.\n  fiber.elementType = 'DELETED';\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nexport function createFiberFromPortal(\n  portal: ReactPortal,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n): Fiber {\n  const pendingProps = portal.children !== null ? portal.children : [];\n  const fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation,\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nexport function assignFiberPropertiesInDEV(\n  target: Fiber | null,\n  source: Fiber,\n): Fiber {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.elementType = source.elementType;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.contextDependencies = source.contextDependencies;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.childExpirationTime = source.childExpirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  target._debugHookTypes = source._debugHookTypes;\n  return target;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberNewContext.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/maxSigned31BitInt.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/SchedulerWithReactIntegration.js",["904","905","906","907","908","909","910","911","912","913"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\n\nimport {disableYielding} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\n\nconst {\n  unstable_runWithPriority: Scheduler_runWithPriority,\n  unstable_scheduleCallback: Scheduler_scheduleCallback,\n  unstable_cancelCallback: Scheduler_cancelCallback,\n  unstable_shouldYield: Scheduler_shouldYield,\n  unstable_now: Scheduler_now,\n  unstable_getCurrentPriorityLevel: Scheduler_getCurrentPriorityLevel,\n  unstable_ImmediatePriority: Scheduler_ImmediatePriority,\n  unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,\n  unstable_NormalPriority: Scheduler_NormalPriority,\n  unstable_LowPriority: Scheduler_LowPriority,\n  unstable_IdlePriority: Scheduler_IdlePriority,\n} = Scheduler;\n\nexport opaque type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;\nexport type SchedulerCallback = (isSync: boolean) => SchedulerCallback | null;\n\ntype SchedulerCallbackOptions = {\n  timeout?: number,\n};\n\nconst fakeCallbackNode = {};\n\n// Except for NoPriority, these correspond to Scheduler priorities. We use\n// ascending numbers so we can compare them like numbers. They start at 90 to\n// avoid clashing with Scheduler's priorities.\nexport const ImmediatePriority: ReactPriorityLevel = 99;\nexport const UserBlockingPriority: ReactPriorityLevel = 98;\nexport const NormalPriority: ReactPriorityLevel = 97;\nexport const LowPriority: ReactPriorityLevel = 96;\nexport const IdlePriority: ReactPriorityLevel = 95;\n// NoPriority is the absence of priority. Also React-only.\nexport const NoPriority: ReactPriorityLevel = 90;\n\nexport const now = Scheduler_now;\nexport const shouldYield = disableYielding\n  ? () => false // Never yield when `disableYielding` is on\n  : Scheduler_shouldYield;\n\nlet immediateQueue: Array<SchedulerCallback> | null = null;\nlet immediateQueueCallbackNode: mixed | null = null;\nlet isFlushingImmediate: boolean = false;\n\nexport function getCurrentPriorityLevel(): ReactPriorityLevel {\n  switch (Scheduler_getCurrentPriorityLevel()) {\n    case Scheduler_ImmediatePriority:\n      return ImmediatePriority;\n    case Scheduler_UserBlockingPriority:\n      return UserBlockingPriority;\n    case Scheduler_NormalPriority:\n      return NormalPriority;\n    case Scheduler_LowPriority:\n      return LowPriority;\n    case Scheduler_IdlePriority:\n      return IdlePriority;\n    default:\n      invariant(false, 'Unknown priority level.');\n  }\n}\n\nfunction reactPriorityToSchedulerPriority(reactPriorityLevel) {\n  switch (reactPriorityLevel) {\n    case ImmediatePriority:\n      return Scheduler_ImmediatePriority;\n    case UserBlockingPriority:\n      return Scheduler_UserBlockingPriority;\n    case NormalPriority:\n      return Scheduler_NormalPriority;\n    case LowPriority:\n      return Scheduler_LowPriority;\n    case IdlePriority:\n      return Scheduler_IdlePriority;\n    default:\n      invariant(false, 'Unknown priority level.');\n  }\n}\n\nexport function runWithPriority<T>(\n  reactPriorityLevel: ReactPriorityLevel,\n  fn: () => T,\n): T {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_runWithPriority(priorityLevel, fn);\n}\n\nexport function scheduleCallback(\n  reactPriorityLevel: ReactPriorityLevel,\n  callback: SchedulerCallback,\n  options: SchedulerCallbackOptions | void | null,\n) {\n  if (reactPriorityLevel === ImmediatePriority) {\n    // Push this callback into an internal queue. We'll flush these either in\n    // the next tick, or earlier if something calls `flushImmediateQueue`.\n    if (immediateQueue === null) {\n      immediateQueue = [callback];\n      // Flush the queue in the next tick, at the earliest.\n      immediateQueueCallbackNode = Scheduler_scheduleCallback(\n        Scheduler_ImmediatePriority,\n        flushImmediateQueueImpl,\n      );\n    } else {\n      // Push onto existing queue. Don't need to schedule a callback because\n      // we already scheduled one when we created the queue.\n      immediateQueue.push(callback);\n    }\n    return fakeCallbackNode;\n  }\n  // Otherwise pass through to Scheduler.\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_scheduleCallback(priorityLevel, callback, options);\n}\n\nexport function cancelCallback(callbackNode: mixed) {\n  if (callbackNode !== fakeCallbackNode) {\n    Scheduler_cancelCallback(callbackNode);\n  }\n}\n\nexport function flushImmediateQueue() {\n  if (immediateQueueCallbackNode !== null) {\n    Scheduler_cancelCallback(immediateQueueCallbackNode);\n  }\n  flushImmediateQueueImpl();\n}\n\nfunction flushImmediateQueueImpl() {\n  if (!isFlushingImmediate && immediateQueue !== null) {\n    // Prevent re-entrancy.\n    isFlushingImmediate = true;\n    let i = 0;\n    try {\n      const isSync = true;\n      for (; i < immediateQueue.length; i++) {\n        let callback = immediateQueue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      immediateQueue = null;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (immediateQueue !== null) {\n        immediateQueue = immediateQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      Scheduler_scheduleCallback(\n        Scheduler_ImmediatePriority,\n        flushImmediateQueue,\n      );\n      throw error;\n    } finally {\n      isFlushingImmediate = false;\n    }\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberScheduler.new.js",["914","915","916"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {\n  ReactPriorityLevel,\n  SchedulerCallback,\n} from './SchedulerWithReactIntegration';\nimport type {Interaction} from 'scheduler/src/Tracing';\n\nimport {\n  warnAboutDeprecatedLifecycles,\n  enableUserTimingAPI,\n  enableSuspenseServerRenderer,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  enableProfilerTimer,\n  disableYielding,\n  enableSchedulerTracing,\n} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\n\nimport {\n  scheduleCallback,\n  cancelCallback,\n  getCurrentPriorityLevel,\n  runWithPriority,\n  shouldYield,\n  now,\n  ImmediatePriority,\n  UserBlockingPriority,\n  NormalPriority,\n  LowPriority,\n  IdlePriority,\n  flushImmediateQueue,\n} from './SchedulerWithReactIntegration';\n\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\n\nimport {\n  prepareForCommit,\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n} from './ReactFiberHostConfig';\n\nimport {createWorkInProgress, assignFiberPropertiesInDEV} from './ReactFiber';\nimport {NoContext, ConcurrentMode, ProfileMode} from './ReactTypeOfMode';\nimport {\n  HostRoot,\n  ClassComponent,\n  SuspenseComponent,\n  DehydratedSuspenseComponent,\n  FunctionComponent,\n  ForwardRef,\n  MemoComponent,\n  SimpleMemoComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Update,\n  PlacementAndUpdate,\n  Deletion,\n  Ref,\n  ContentReset,\n  Snapshot,\n  Callback,\n  Passive,\n  Incomplete,\n  HostEffectMask,\n} from 'shared/ReactSideEffectTags';\nimport {\n  NoWork,\n  Sync,\n  Never,\n  msToExpirationTime,\n  expirationTimeToMs,\n  computeInteractiveExpiration,\n  computeAsyncExpiration,\n  inferPriorityFromExpirationTime,\n  LOW_PRIORITY_EXPIRATION,\n} from './ReactFiberExpirationTime';\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork';\nimport {completeWork} from './ReactFiberCompleteWork';\nimport {\n  throwException,\n  unwindWork,\n  unwindInterruptedWork,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberUnwindWork';\nimport {\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\n  commitLifeCycles as commitLayoutEffectOnFiber,\n  commitPassiveHookEffects,\n  commitPlacement,\n  commitWork,\n  commitDeletion,\n  commitDetachRef,\n  commitAttachRef,\n  commitResetTextContent,\n} from './ReactFiberCommitWork';\nimport {enqueueUpdate} from './ReactUpdateQueue';\n// TODO: Ahaha Andrew is bad at spellling\nimport {resetContextDependences as resetContextDependencies} from './ReactFiberNewContext';\nimport {resetHooks, ContextOnlyDispatcher} from './ReactFiberHooks';\nimport {createCapturedValue} from './ReactCapturedValue';\n\nimport {\n  recordCommitTime,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n} from './ReactProfilerTimer';\n\n// DEV stuff\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {\n  phase as ReactCurrentDebugFiberPhaseInDEV,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {\n  recordEffect,\n  recordScheduleUpdate,\n  startRequestCallbackTimer,\n  stopRequestCallbackTimer,\n  startWorkTimer,\n  stopWorkTimer,\n  stopFailedWorkTimer,\n  startWorkLoopTimer,\n  stopWorkLoopTimer,\n  startCommitTimer,\n  stopCommitTimer,\n  startCommitSnapshotEffectsTimer,\n  stopCommitSnapshotEffectsTimer,\n  startCommitHostEffectsTimer,\n  stopCommitHostEffectsTimer,\n  startCommitLifeCyclesTimer,\n  stopCommitLifeCyclesTimer,\n} from './ReactDebugFiberPerf';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {onCommitRoot} from './ReactFiberDevToolsHook';\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  ReactShouldWarnActingUpdates,\n} = ReactSharedInternals;\n\ntype WorkPhase = 0 | 1 | 2 | 3 | 4 | 5;\nconst NotWorking = 0;\nconst BatchedPhase = 1;\nconst LegacyUnbatchedPhase = 2;\nconst FlushSyncPhase = 3;\nconst RenderPhase = 4;\nconst CommitPhase = 5;\n\ntype RootExitStatus = 0 | 1 | 2 | 3;\nconst RootIncomplete = 0;\nconst RootErrored = 1;\nconst RootSuspended = 2;\nconst RootCompleted = 3;\n\nexport type Thenable = {\n  then(resolve: () => mixed, reject?: () => mixed): Thenable | void,\n};\n\n// The phase of work we're currently in\nlet workPhase: WorkPhase = NotWorking;\n// The root we're working on\nlet workInProgressRoot: FiberRoot | null = null;\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n// The expiration time we're rendering\nlet renderExpirationTime: ExpirationTime = NoWork;\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\nlet workInProgressRootAbsoluteTimeoutMs: number = -1;\n\nlet nextEffect: Fiber | null = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\nlet rootDoesHavePassiveEffects: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet pendingPassiveEffectsExpirationTime: ExpirationTime = NoWork;\n\nlet rootsWithPendingDiscreteUpdates: Map<\n  FiberRoot,\n  ExpirationTime,\n> | null = null;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount: number = 0;\n\nlet interruptedBy: Fiber | null = null;\n\n// Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\nlet currentEventTime: ExpirationTime = NoWork;\n\nexport function requestCurrentTime() {\n  if (workPhase === RenderPhase || workPhase === CommitPhase) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\n\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n): ExpirationTime {\n  if ((fiber.mode & ConcurrentMode) === NoContext) {\n    return Sync;\n  }\n\n  if (workPhase === RenderPhase) {\n    // Use whatever time we're already rendering\n    return renderExpirationTime;\n  }\n\n  // Compute an expiration time based on the Scheduler priority.\n  let expirationTime;\n  const priorityLevel = getCurrentPriorityLevel();\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      expirationTime = Sync;\n      break;\n    case UserBlockingPriority:\n      // TODO: Rename this to computeUserBlockingExpiration\n      expirationTime = computeInteractiveExpiration(currentTime);\n      break;\n    case NormalPriority:\n    case LowPriority: // TODO: Handle LowPriority\n      // TODO: Rename this to... something better.\n      expirationTime = computeAsyncExpiration(currentTime);\n      break;\n    case IdlePriority:\n      expirationTime = Never;\n      break;\n    default:\n      invariant(false, 'Expected a valid priority level');\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\nlet lastUniqueAsyncExpiration = NoWork;\nexport function computeUniqueAsyncExpiration(): ExpirationTime {\n  const currentTime = requestCurrentTime();\n  let result = computeAsyncExpiration(currentTime);\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result -= 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return result;\n}\n\nexport function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  checkForNestedUpdates();\n  warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n  if (root === null) {\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n\n  root.pingTime = NoWork;\n\n  checkForInterruption(fiber, expirationTime);\n  recordScheduleUpdate();\n\n  if (expirationTime === Sync) {\n    if (workPhase === LegacyUnbatchedPhase) {\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n      // root inside of batchedUpdates should be synchronous, but layout updates\n      // should be deferred until the end of the batch.\n      let callback = renderRoot(root, Sync, true);\n      while (callback !== null) {\n        callback = callback(true);\n      }\n    } else {\n      scheduleCallbackForRoot(root, ImmediatePriority, Sync);\n      if (workPhase === NotWorking) {\n        // Flush the synchronous work now, wnless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initated\n        // updates, to preserve historical behavior of sync mode.\n        flushImmediateQueue();\n      }\n    }\n  } else {\n    // TODO: computeExpirationForFiber also reads the priority. Pass the\n    // priority as an argument to that function and this one.\n    const priorityLevel = getCurrentPriorityLevel();\n    if (priorityLevel === UserBlockingPriority) {\n      // This is the result of a discrete event. Track the lowest priority\n      // discrete update per root so we can flush them early, if needed.\n      if (rootsWithPendingDiscreteUpdates === null) {\n        rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n      } else {\n        const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n        if (\n          lastDiscreteTime === undefined ||\n          lastDiscreteTime > expirationTime\n        ) {\n          rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n        }\n      }\n    }\n    scheduleCallbackForRoot(root, priorityLevel, expirationTime);\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber;\n\n// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  let node = fiber.return;\n  let root = null;\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    // Update the first and last pending expiration times in this root\n    const firstPendingTime = root.firstPendingTime;\n    if (expirationTime > firstPendingTime) {\n      root.firstPendingTime = expirationTime;\n    }\n    const lastPendingTime = root.lastPendingTime;\n    if (lastPendingTime === NoWork || expirationTime < lastPendingTime) {\n      root.lastPendingTime = expirationTime;\n    }\n  }\n\n  return root;\n}\n\n// Use this function, along with runRootCallback, to ensure that only a single\n// callback per root is scheduled. It's still possible to call renderRoot\n// directly, but scheduling via this function helps avoid excessive callbacks.\n// It works by storing the callback node and expiration time on the root. When a\n// new callback comes in, it compares the expiration time to determine if it\n// should cancel the previous one. It also relies on commitRoot scheduling a\n// callback to render the next level, because that means we don't need a\n// separate callback per expiration time.\nfunction scheduleCallbackForRoot(\n  root: FiberRoot,\n  priorityLevel: ReactPriorityLevel,\n  expirationTime: ExpirationTime,\n) {\n  const existingCallbackExpirationTime = root.callbackExpirationTime;\n  if (existingCallbackExpirationTime < expirationTime) {\n    // New callback has higher priority than the existing one.\n    const existingCallbackNode = root.callbackNode;\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n    root.callbackExpirationTime = expirationTime;\n    const options =\n      expirationTime === Sync\n        ? null\n        : {timeout: expirationTimeToMs(expirationTime)};\n    root.callbackNode = scheduleCallback(\n      priorityLevel,\n      runRootCallback.bind(\n        null,\n        root,\n        renderRoot.bind(null, root, expirationTime),\n      ),\n      options,\n    );\n    if (\n      enableUserTimingAPI &&\n      expirationTime !== Sync &&\n      workPhase !== RenderPhase &&\n      workPhase !== CommitPhase\n    ) {\n      // Scheduled an async callback, and we're not already working. Add an\n      // entry to the flamegraph that shows we're waiting for a callback\n      // to fire.\n      startRequestCallbackTimer();\n    }\n  }\n\n  const timeoutHandle = root.timeoutHandle;\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  // Add the current set of interactions to the pending set associated with\n  // this root.\n  schedulePendingInteraction(root, expirationTime);\n}\n\nfunction runRootCallback(root, callback, isSync) {\n  const prevCallbackNode = root.callbackNode;\n  let continuation = null;\n  try {\n    continuation = callback(isSync);\n    if (continuation !== null) {\n      return runRootCallback.bind(null, root, continuation);\n    } else {\n      return null;\n    }\n  } finally {\n    // If the callback exits without returning a continuation, remove the\n    // corresponding callback node from the root. Unless the callback node\n    // has changed, which implies that it was already cancelled by a high\n    // priority update.\n    if (continuation === null && prevCallbackNode === root.callbackNode) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n    }\n  }\n}\n\nexport function flushRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  if (workPhase === RenderPhase || workPhase === CommitPhase) {\n    invariant(\n      false,\n      'work.commit(): Cannot commit while already rendering. This likely ' +\n        'means you attempted to commit from inside a lifecycle method.',\n    );\n  }\n  scheduleCallback(\n    ImmediatePriority,\n    renderRoot.bind(null, root, expirationTime),\n  );\n  flushImmediateQueue();\n}\n\nexport function flushInteractiveUpdates() {\n  if (workPhase === RenderPhase || workPhase === CommitPhase) {\n    // Can't synchronously flush interactive updates if React is already\n    // working. This is currently a no-op.\n    // TODO: Should we fire a warning? This happens if you synchronously invoke\n    // an input event inside an effect, like with `element.click()`.\n    return;\n  }\n  flushPendingDiscreteUpdates();\n}\n\nfunction resolveLocksOnRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  const firstBatch = root.firstBatch;\n  if (\n    firstBatch !== null &&\n    firstBatch._defer &&\n    firstBatch._expirationTime >= expirationTime\n  ) {\n    root.finishedWork = root.current.alternate;\n    root.pendingCommitExpirationTime = expirationTime;\n    scheduleCallback(NormalPriority, () => {\n      firstBatch._onComplete();\n      return null;\n    });\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function deferredUpdates<A>(fn: () => A): A {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\n\nexport function interactiveUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  if (workPhase === NotWorking) {\n    // TODO: Remove this call. Instead of doing this automatically, the caller\n    // should explicitly call flushInteractiveUpdates.\n    flushPendingDiscreteUpdates();\n  }\n  return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c));\n}\n\nexport function syncUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      scheduleCallback(\n        ImmediatePriority,\n        renderRoot.bind(null, root, expirationTime),\n      );\n    });\n    // Now flush the immediate queue.\n    flushImmediateQueue();\n  }\n}\n\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\n  if (workPhase !== NotWorking) {\n    // We're already working, or inside a batch, so batchedUpdates is a no-op.\n    return fn(a);\n  }\n  workPhase = BatchedPhase;\n  try {\n    return fn(a);\n  } finally {\n    workPhase = NotWorking;\n    // Flush the immediate callbacks that were scheduled during this batch\n    flushImmediateQueue();\n  }\n}\n\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  if (workPhase !== BatchedPhase && workPhase !== FlushSyncPhase) {\n    // We're not inside batchedUpdates or flushSync, so unbatchedUpdates is\n    // a no-op.\n    return fn(a);\n  }\n  const prevWorkPhase = workPhase;\n  workPhase = LegacyUnbatchedPhase;\n  try {\n    return fn(a);\n  } finally {\n    workPhase = prevWorkPhase;\n  }\n}\n\nexport function flushSync<A, R>(fn: A => R, a: A): R {\n  if (workPhase === RenderPhase || workPhase === CommitPhase) {\n    invariant(\n      false,\n      'flushSync was called from inside a lifecycle method. It cannot be ' +\n        'called when React is already rendering.',\n    );\n  }\n  const prevWorkPhase = workPhase;\n  workPhase = FlushSyncPhase;\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    workPhase = prevWorkPhase;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    flushImmediateQueue();\n  }\n}\n\nexport function flushControlled(fn: () => mixed): void {\n  const prevWorkPhase = workPhase;\n  workPhase = BatchedPhase;\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    workPhase = prevWorkPhase;\n    if (workPhase === NotWorking) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushImmediateQueue();\n    }\n  }\n}\n\nfunction prepareFreshStack(root, expirationTime) {\n  root.pendingCommitExpirationTime = NoWork;\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null, expirationTime);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootAbsoluteTimeoutMs = -1;\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n}\n\nfunction renderRoot(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n  isSync: boolean,\n): SchedulerCallback | null {\n  invariant(\n    workPhase !== RenderPhase && workPhase !== CommitPhase,\n    'Should not already be working.',\n  );\n\n  if (enableUserTimingAPI && expirationTime !== Sync) {\n    const didExpire = isSync;\n    const timeoutMs = expirationTimeToMs(expirationTime);\n    stopRequestCallbackTimer(didExpire, timeoutMs);\n  }\n\n  if (root.firstPendingTime < expirationTime) {\n    // If there's no work left at this expiration time, exit immediately. This\n    // happens when multiple callbacks are scheduled for a single root, but an\n    // earlier callback flushes the work of a later one.\n    return null;\n  }\n\n  if (root.pendingCommitExpirationTime === expirationTime) {\n    // There's already a pending commit at this expiration time.\n    root.pendingCommitExpirationTime = NoWork;\n    return commitRoot.bind(null, root, expirationTime);\n  }\n\n  flushPassiveEffects();\n\n  // If the root or expiration time have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n    prepareFreshStack(root, expirationTime);\n    startWorkOnPendingInteraction(root, expirationTime);\n  }\n\n  // If we have a work-in-progress fiber, it means there's still work to do\n  // in this root.\n  if (workInProgress !== null) {\n    const prevWorkPhase = workPhase;\n    workPhase = RenderPhase;\n    let prevDispatcher = ReactCurrentDispatcher.current;\n    if (prevDispatcher === null) {\n      // The React isomorphic package does not include a default dispatcher.\n      // Instead the first renderer will lazily attach one, in order to give\n      // nicer error messages.\n      prevDispatcher = ContextOnlyDispatcher;\n    }\n    ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n    let prevInteractions: Set<Interaction> | null = null;\n    if (enableSchedulerTracing) {\n      prevInteractions = __interactionsRef.current;\n      __interactionsRef.current = root.memoizedInteractions;\n    }\n\n    startWorkLoopTimer(workInProgress);\n\n    // TODO: Fork renderRoot into renderRootSync and renderRootAsync\n    if (isSync) {\n      if (expirationTime !== Sync) {\n        // An async update expired. There may be other expired updates on\n        // this root. We should render all the expired work in a\n        // single batch.\n        const currentTime = requestCurrentTime();\n        if (currentTime < expirationTime) {\n          // Restart at the current time.\n          workPhase = prevWorkPhase;\n          resetContextDependencies();\n          ReactCurrentDispatcher.current = prevDispatcher;\n          if (enableSchedulerTracing) {\n            __interactionsRef.current = ((prevInteractions: any): Set<\n              Interaction,\n            >);\n          }\n          return renderRoot.bind(null, root, currentTime);\n        }\n      }\n    } else {\n      // Since we know we're in a React event, we can clear the current\n      // event time. The next update will compute a new event time.\n      currentEventTime = NoWork;\n    }\n\n    do {\n      try {\n        if (isSync) {\n          workLoopSync();\n        } else {\n          workLoop();\n        }\n        break;\n      } catch (thrownValue) {\n        // Reset module-level state that was set during the render phase.\n        resetContextDependencies();\n        resetHooks();\n\n        const sourceFiber = workInProgress;\n        if (sourceFiber === null || sourceFiber.return === null) {\n          // Expected to be working on a non-root fiber. This is a fatal error\n          // because there's no ancestor that can handle it; the root is\n          // supposed to capture all errors that weren't caught by an error\n          // boundary.\n          prepareFreshStack(root, expirationTime);\n          workPhase = prevWorkPhase;\n          throw thrownValue;\n        }\n\n        if (enableProfilerTimer && sourceFiber.mode & ProfileMode) {\n          // Record the time spent rendering before an error was thrown. This\n          // avoids inaccurate Profiler durations in the case of a\n          // suspended render.\n          stopProfilerTimerIfRunningAndRecordDelta(sourceFiber, true);\n        }\n\n        const returnFiber = sourceFiber.return;\n        throwException(\n          root,\n          returnFiber,\n          sourceFiber,\n          thrownValue,\n          renderExpirationTime,\n        );\n        workInProgress = completeUnitOfWork(sourceFiber);\n      }\n    } while (true);\n\n    workPhase = prevWorkPhase;\n    resetContextDependencies();\n    ReactCurrentDispatcher.current = prevDispatcher;\n    if (enableSchedulerTracing) {\n      __interactionsRef.current = ((prevInteractions: any): Set<Interaction>);\n    }\n\n    if (workInProgress !== null) {\n      // There's still work left over. Return a continuation.\n      stopInterruptedWorkLoopTimer();\n      if (expirationTime !== Sync) {\n        startRequestCallbackTimer();\n      }\n      return renderRoot.bind(null, root, expirationTime);\n    }\n  }\n\n  // We now have a consistent tree. The next step is either to commit it, or, if\n  // something suspended, wait to commit it after a timeout.\n  stopFinishedWorkLoopTimer();\n\n  const isLocked = resolveLocksOnRoot(root, expirationTime);\n  if (isLocked) {\n    // This root has a lock that prevents it from committing. Exit. If we begin\n    // work on the root again, without any intervening updates, it will finish\n    // without doing additional work.\n    return null;\n  }\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  switch (workInProgressRootExitStatus) {\n    case RootIncomplete: {\n      invariant(false, 'Should have a work-in-progress.');\n    }\n    // Flow knows about invariant, so it compains if I add a break statement,\n    // but eslint doesn't know about invariant, so it complains if I do.\n    // eslint-disable-next-line no-fallthrough\n    case RootErrored: {\n      // An error was thrown. First check if there is lower priority work\n      // scheduled on this root.\n      const lastPendingTime = root.lastPendingTime;\n      if (root.lastPendingTime < expirationTime) {\n        // There's lower priority work. Before raising the error, try rendering\n        // at the lower priority to see if it fixes it. Use a continuation to\n        // maintain the existing priority and position in the queue.\n        return renderRoot.bind(null, root, lastPendingTime);\n      }\n      if (!isSync) {\n        // If we're rendering asynchronously, it's possible the error was\n        // caused by tearing due to a mutation during an event. Try rendering\n        // one more time without yiedling to events.\n        prepareFreshStack(root, expirationTime);\n        scheduleCallback(\n          ImmediatePriority,\n          renderRoot.bind(null, root, expirationTime),\n        );\n        return null;\n      }\n      // If we're already rendering synchronously, commit the root in its\n      // errored state.\n      return commitRoot.bind(null, root, expirationTime);\n    }\n    case RootSuspended: {\n      const lastPendingTime = root.lastPendingTime;\n      if (root.lastPendingTime < expirationTime) {\n        // There's lower priority work. It might be unsuspended. Try rendering\n        // at that level.\n        return renderRoot.bind(null, root, lastPendingTime);\n      }\n      if (!isSync) {\n        const msUntilTimeout = computeMsUntilTimeout(\n          root,\n          workInProgressRootAbsoluteTimeoutMs,\n        );\n        if (msUntilTimeout > 0) {\n          // The render is suspended, it hasn't timed out, and there's no lower\n          // priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root, expirationTime),\n            msUntilTimeout,\n          );\n          return null;\n        }\n      }\n      // The work expired. Commit immediately.\n      return commitRoot.bind(null, root, expirationTime);\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      return commitRoot.bind(null, root, expirationTime);\n    }\n    default: {\n      invariant(false, 'Unknown root exit status.');\n    }\n  }\n}\n\nexport function renderDidSuspend(\n  root: FiberRoot,\n  absoluteTimeoutMs: number,\n  // TODO: Don't need this argument anymore\n  suspendedTime: ExpirationTime,\n) {\n  if (\n    absoluteTimeoutMs >= 0 &&\n    workInProgressRootAbsoluteTimeoutMs < absoluteTimeoutMs\n  ) {\n    workInProgressRootAbsoluteTimeoutMs = absoluteTimeoutMs;\n    if (workInProgressRootExitStatus === RootIncomplete) {\n      workInProgressRootExitStatus = RootSuspended;\n    }\n  }\n}\n\nexport function renderDidError() {\n  if (\n    workInProgressRootExitStatus === RootIncomplete ||\n    workInProgressRootExitStatus === RootSuspended\n  ) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n}\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction workLoop() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n\n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoContext) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\nfunction completeUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  workInProgress = unitOfWork;\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = workInProgress.alternate;\n    const returnFiber = workInProgress.return;\n\n    // Check if the work completed or if something threw.\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next;\n      if (\n        !enableProfilerTimer ||\n        (workInProgress.mode & ProfileMode) === NoContext\n      ) {\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        startProfilerTimer(workInProgress);\n        next = completeWork(current, workInProgress, renderExpirationTime);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress);\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        return next;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if needed,\n        // by doing multiple passes over the effect list. We don't want to\n        // schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        const effectTag = workInProgress.effectTag;\n\n        // Skip both NoWork and PerformedWork tags when creating the effect\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\n        // committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime);\n\n      // Because this fiber did not complete, don't reset its expiration time.\n\n      if (\n        enableProfilerTimer &&\n        (workInProgress.mode & ProfileMode) !== NoContext\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n\n    const siblingFiber = workInProgress.sibling;\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      return siblingFiber;\n    }\n    // Otherwise, return to the parent\n    workInProgress = returnFiber;\n  } while (workInProgress !== null);\n\n  // We've reached the root.\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n  return null;\n}\n\nfunction resetChildExpirationTime(completedWork: Fiber) {\n  if (\n    renderExpirationTime !== Never &&\n    completedWork.childExpirationTime === Never\n  ) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoContext) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n    const shouldBubbleActualDurations =\n      completedWork.alternate === null ||\n      completedWork.child !== completedWork.alternate.child;\n\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root, expirationTime) {\n  runWithPriority(\n    ImmediatePriority,\n    commitRootImpl.bind(null, root, expirationTime),\n  );\n  // If there are passive effects, schedule a callback to flush them. This goes\n  // outside commitRootImpl so that it inherits the priority of the render.\n  if (rootWithPendingPassiveEffects !== null) {\n    const priorityLevel = getCurrentPriorityLevel();\n    scheduleCallback(priorityLevel, () => {\n      flushPassiveEffects();\n      return null;\n    });\n  }\n  return null;\n}\n\nfunction commitRootImpl(root, expirationTime) {\n  flushPassiveEffects();\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  invariant(\n    workPhase !== RenderPhase && workPhase !== CommitPhase,\n    'Should not already be working.',\n  );\n  const finishedWork = root.current.alternate;\n  invariant(finishedWork !== null, 'Should have a work-in-progress root.');\n\n  // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n\n  startCommitTimer();\n\n  // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n  const updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n  const childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n  const firstPendingTimeBeforeCommit =\n    childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit\n      ? childExpirationTimeBeforeCommit\n      : updateExpirationTimeBeforeCommit;\n  root.firstPendingTime = firstPendingTimeBeforeCommit;\n  if (firstPendingTimeBeforeCommit < root.lastPendingTime) {\n    // This usually means we've finished all the work, but it can also happen\n    // when something gets downprioritized during render, like a hidden tree.\n    root.lastPendingTime = firstPendingTimeBeforeCommit;\n  }\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {\n    // This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  }\n\n  // Get the list of effects.\n  let firstEffect;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if it\n    // had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  if (firstEffect !== null) {\n    const prevWorkPhase = workPhase;\n    workPhase = CommitPhase;\n    let prevInteractions: Set<Interaction> | null = null;\n    if (enableSchedulerTracing) {\n      prevInteractions = __interactionsRef.current;\n      __interactionsRef.current = root.memoizedInteractions;\n    }\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    startCommitHostEffectsTimer();\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitMutationEffects, null);\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    startCommitLifeCyclesTimer();\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitLayoutEffects,\n          null,\n          root,\n          expirationTime,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitLifeCyclesTimer();\n\n    nextEffect = null;\n\n    if (enableSchedulerTracing) {\n      __interactionsRef.current = ((prevInteractions: any): Set<Interaction>);\n    }\n    workPhase = prevWorkPhase;\n  } else {\n    // No effects.\n    root.current = finishedWork;\n    // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n  } else {\n    if (enableSchedulerTracing) {\n      // If there are no passive effects, then we can complete the pending\n      // interactions. Otherwise, we'll wait until after the passive effects\n      // are flushed.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  // Check if there's remaining work on this root\n  const remainingExpirationTime = root.firstPendingTime;\n  if (remainingExpirationTime !== NoWork) {\n    const currentTime = requestCurrentTime();\n    const priorityLevel = inferPriorityFromExpirationTime(\n      currentTime,\n      remainingExpirationTime,\n    );\n    scheduleCallbackForRoot(root, priorityLevel, remainingExpirationTime);\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  onCommitRoot(finishedWork.stateNode);\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if (workPhase === LegacyUnbatchedPhase) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushImmediateQueue();\n  return null;\n}\n\nfunction commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    if ((nextEffect.effectTag & Snapshot) !== NoEffect) {\n      setCurrentDebugFiberInDEV(nextEffect);\n      recordEffect();\n\n      const current = nextEffect.alternate;\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n\n      resetCurrentDebugFiberInDEV();\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitMutationEffects() {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every possible\n    // bitmap value, we remove the secondary effects from the effect tag and\n    // switch on that value.\n    let primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n        // and isMounted is deprecated anyway so we should be able to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(nextEffect);\n        break;\n      }\n    }\n\n    // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n    recordEffect();\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitLayoutEffects(\n  root: FiberRoot,\n  committedExpirationTime: ExpirationTime,\n) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(\n        root,\n        current,\n        nextEffect,\n        committedExpirationTime,\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    if (effectTag & Passive) {\n      rootDoesHavePassiveEffects = true;\n    }\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n\n  let prevInteractions: Set<Interaction> | null = null;\n  if (enableSchedulerTracing) {\n    prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n  }\n\n  invariant(\n    workPhase !== RenderPhase && workPhase !== CommitPhase,\n    'Cannot flush passive effects while already rendering.',\n  );\n  const prevWorkPhase = workPhase;\n  workPhase = CommitPhase;\n\n  // Note: This currently assumes there are no passive effects on the root\n  // fiber, because the root is not part of its own effect list. This could\n  // change in the future.\n  let effect = root.current.firstEffect;\n  while (effect !== null) {\n    if (__DEV__) {\n      setCurrentDebugFiberInDEV(effect);\n      invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n      if (hasCaughtError()) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        const error = clearCaughtError();\n        captureCommitPhaseError(effect, error);\n      }\n      resetCurrentDebugFiberInDEV();\n    } else {\n      try {\n        commitPassiveHookEffects(effect);\n      } catch (error) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        captureCommitPhaseError(effect, error);\n      }\n    }\n    effect = effect.nextEffect;\n  }\n\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = ((prevInteractions: any): Set<Interaction>);\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  workPhase = prevWorkPhase;\n  flushImmediateQueue();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error: mixed) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(\n  rootFiber: Fiber,\n  sourceFiber: Fiber,\n  error: mixed,\n) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n  if (root !== null) {\n    scheduleCallbackForRoot(root, ImmediatePriority, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n      if (\n        typeof ctor.getDerivedStateFromError === 'function' ||\n        (typeof instance.componentDidCatch === 'function' &&\n          !isAlreadyFailedLegacyErrorBoundary(instance))\n      ) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(\n          fiber,\n          errorInfo,\n          // TODO: This is always sync\n          Sync,\n        );\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n        if (root !== null) {\n          scheduleCallbackForRoot(root, ImmediatePriority, Sync);\n        }\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n}\n\nexport function pingSuspendedRoot(\n  root: FiberRoot,\n  thenable: Thenable,\n  suspendedTime: ExpirationTime,\n) {\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. Restart from the root. Don't need to schedule a ping because\n    // we're already working on this tree.\n    prepareFreshStack(root, renderExpirationTime);\n    return;\n  }\n\n  const lastPendingTime = root.lastPendingTime;\n  if (lastPendingTime < suspendedTime) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const pingTime = root.pingTime;\n  if (pingTime !== NoWork && pingTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  }\n\n  // Mark the time at which this ping was scheduled.\n  root.pingTime = suspendedTime;\n\n  const currentTime = requestCurrentTime();\n  const priorityLevel = inferPriorityFromExpirationTime(\n    currentTime,\n    suspendedTime,\n  );\n  scheduleCallbackForRoot(root, priorityLevel, suspendedTime);\n}\n\nexport function retryTimedOutBoundary(boundaryFiber: Fiber) {\n  // The boundary fiber (a Suspense component) previously timed out and was\n  // rendered in its fallback state. One of the promises that suspended it has\n  // resolved, which means at least part of the tree was likely unblocked. Try\n  // rendering again, at a new expiration time.\n  const currentTime = requestCurrentTime();\n  const retryTime = computeExpirationForFiber(currentTime, boundaryFiber);\n  // TODO: Special case idle priority?\n  const priorityLevel = inferPriorityFromExpirationTime(currentTime, retryTime);\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n  if (root !== null) {\n    scheduleCallbackForRoot(root, priorityLevel, retryTime);\n  }\n}\n\nexport function resolveRetryThenable(boundaryFiber: Fiber, thenable: Thenable) {\n  let retryCache: WeakSet<Thenable> | Set<Thenable> | null;\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n      case DehydratedSuspenseComponent:\n        retryCache = boundaryFiber.memoizedState;\n        break;\n      default:\n        invariant(\n          false,\n          'Pinged unknown suspense boundary type. ' +\n            'This is probably a bug in React.',\n        );\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber);\n}\n\nexport function inferStartTimeFromExpirationTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(root.firstPendingTime);\n  // TODO: Track this on the root instead. It's more accurate, doesn't rely on\n  // assumptions about priority, and isn't coupled to Scheduler details.\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction computeMsUntilTimeout(root, absoluteTimeoutMs) {\n  if (disableYielding) {\n    // Timeout immediately when yielding is disabled.\n    return 0;\n  }\n\n  // Find the earliest uncommitted expiration time in the tree, including\n  // work that is suspended. The timeout threshold cannot be longer than\n  // the overall expiration.\n  const earliestExpirationTimeMs = expirationTimeToMs(root.firstPendingTime);\n  if (earliestExpirationTimeMs < absoluteTimeoutMs) {\n    absoluteTimeoutMs = earliestExpirationTimeMs;\n  }\n\n  // Subtract the current time from the absolute timeout to get the number\n  // of milliseconds until the timeout. In other words, convert an absolute\n  // timestamp to a relative time. This is the value that is passed\n  // to `setTimeout`.\n  let msUntilTimeout = absoluteTimeoutMs - now();\n  return msUntilTimeout < 0 ? 0 : msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(\n      false,\n      'Maximum update depth exceeded. This can happen when a component ' +\n        'repeatedly calls setState inside componentWillUpdate or ' +\n        'componentDidUpdate. React limits the number of nested updates to ' +\n        'prevent infinite loops.',\n    );\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      warning(\n        false,\n        'Maximum update depth exceeded. This can happen when a component ' +\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\n          'have a dependency array, or one of the dependencies changes on ' +\n          'every render.',\n      );\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(\n  fiberThatReceivedUpdate: Fiber,\n  updateExpirationTime: ExpirationTime,\n) {\n  if (\n    enableUserTimingAPI &&\n    workInProgressRoot !== null &&\n    updateExpirationTime > renderExpirationTime\n  ) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n    if (\n      tag !== HostRoot &&\n      tag !== ClassComponent &&\n      tag !== FunctionComponent &&\n      tag !== ForwardRef &&\n      tag !== MemoComponent &&\n      tag !== SimpleMemoComponent\n    ) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n    warningWithoutStack(\n      false,\n      \"Can't perform a React state update on an unmounted component. This \" +\n        'is a no-op, but it indicates a memory leak in your application. To ' +\n        'fix, cancel all subscriptions and asynchronous tasks in %s.%s',\n      tag === ClassComponent\n        ? 'the componentWillUnmount method'\n        : 'a useEffect cleanup function',\n      getStackByFiberInDevAndProd(fiber),\n    );\n  }\n}\n\nlet beginWork;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\n      dummyFiber,\n      unitOfWork,\n    );\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (\n        originalError !== null &&\n        typeof originalError === 'object' &&\n        typeof originalError.then === 'function'\n      ) {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      }\n\n      // Keep this code in sync with renderRoot; any changes here must have\n      // corresponding changes there.\n      resetContextDependencies();\n      resetHooks();\n\n      // Unwind the failed stack frame\n      unwindInterruptedWork(unitOfWork);\n\n      // Restore the original properties of the fiber.\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      }\n\n      // Run beginWork again.\n      invokeGuardedCallback(\n        null,\n        originalBeginWork,\n        null,\n        current,\n        unitOfWork,\n        expirationTime,\n      );\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInGetChildContext = false;\nfunction warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent) {\n      switch (ReactCurrentDebugFiberPhaseInDEV) {\n        case 'getChildContext':\n          if (didWarnAboutUpdateInGetChildContext) {\n            return;\n          }\n          warningWithoutStack(\n            false,\n            'setState(...): Cannot call setState() inside getChildContext()',\n          );\n          didWarnAboutUpdateInGetChildContext = true;\n          break;\n        case 'render':\n          if (didWarnAboutUpdateInRender) {\n            return;\n          }\n          warningWithoutStack(\n            false,\n            'Cannot update during an existing state transition (such as ' +\n              'within `render`). Render methods should be a pure function of ' +\n              'props and state.',\n          );\n          didWarnAboutUpdateInRender = true;\n          break;\n      }\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      workPhase === NotWorking &&\n      ReactShouldWarnActingUpdates.current === false\n    ) {\n      warningWithoutStack(\n        false,\n        'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nfunction schedulePendingInteraction(root, expirationTime) {\n  // This is called when work is scheduled on a root. It sets up a pending\n  // interaction, which is completed once the work commits.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const interactions = __interactionsRef.current;\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction startWorkOnPendingInteraction(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n  const interactions: Set<Interaction> = new Set();\n  root.pendingInteractionMap.forEach(\n    (scheduledInteractions, scheduledExpirationTime) => {\n      if (scheduledExpirationTime >= expirationTime) {\n        scheduledInteractions.forEach(interaction =>\n          interactions.add(interaction),\n        );\n      }\n    },\n  );\n\n  // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like renderRoot() without having to\n  // recalculate it. We will also use it in commitWork() to pass to any Profiler\n  // onRender() hooks. This also provides DevTools with a way to access it when\n  // the onCommitRoot() hook is called.\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case– leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach(\n      (scheduledInteractions, scheduledExpirationTime) => {\n        // Only decrement the pending interaction count if we're done.\n        // If there's still work at the current priority,\n        // That indicates that we are waiting for suspense data.\n        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n          pendingInteractionMap.delete(scheduledExpirationTime);\n\n          scheduledInteractions.forEach(interaction => {\n            interaction.__count--;\n\n            if (subscriber !== null && interaction.__count === 0) {\n              try {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              } catch (error) {\n                // If the subscriber throws, rethrow it in a separate task\n                scheduleCallback(ImmediatePriority, () => {\n                  throw error;\n                });\n              }\n            }\n          });\n        }\n      },\n    );\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberScheduler.old.js",["917","918","919","920","921","922","923"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {Batch, FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {Interaction} from 'scheduler/src/Tracing';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nimport {\n  __interactionsRef,\n  __subscriberRef,\n  unstable_wrap as Scheduler_tracing_wrap,\n} from 'scheduler/tracing';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Update,\n  Snapshot,\n  PlacementAndUpdate,\n  Deletion,\n  ContentReset,\n  Callback,\n  DidCapture,\n  Ref,\n  Incomplete,\n  HostEffectMask,\n  Passive,\n} from 'shared/ReactSideEffectTags';\nimport {\n  ClassComponent,\n  HostComponent,\n  ContextProvider,\n  ForwardRef,\n  FunctionComponent,\n  HostPortal,\n  HostRoot,\n  MemoComponent,\n  SimpleMemoComponent,\n  SuspenseComponent,\n  DehydratedSuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  enableSchedulerTracing,\n  enableProfilerTimer,\n  enableUserTimingAPI,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  warnAboutDeprecatedLifecycles,\n  enableSuspenseServerRenderer,\n  disableYielding,\n} from 'shared/ReactFeatureFlags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nimport ReactFiberInstrumentation from './ReactFiberInstrumentation';\nimport {\n  getStackByFiberInDevAndProd,\n  phase as ReactCurrentFiberPhase,\n  resetCurrentFiber,\n  setCurrentFiber,\n} from './ReactCurrentFiber';\nimport {\n  prepareForCommit,\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n} from './ReactFiberHostConfig';\nimport {\n  markPendingPriorityLevel,\n  markCommittedPriorityLevels,\n  markSuspendedPriorityLevel,\n  markPingedPriorityLevel,\n  hasLowerPriorityWork,\n  isPriorityLevelSuspended,\n  findEarliestOutstandingPriorityLevel,\n  didExpireAtExpirationTime,\n} from './ReactFiberPendingPriority';\nimport {\n  recordEffect,\n  recordScheduleUpdate,\n  startRequestCallbackTimer,\n  stopRequestCallbackTimer,\n  startWorkTimer,\n  stopWorkTimer,\n  stopFailedWorkTimer,\n  startWorkLoopTimer,\n  stopWorkLoopTimer,\n  startCommitTimer,\n  stopCommitTimer,\n  startCommitSnapshotEffectsTimer,\n  stopCommitSnapshotEffectsTimer,\n  startCommitHostEffectsTimer,\n  stopCommitHostEffectsTimer,\n  startCommitLifeCyclesTimer,\n  stopCommitLifeCyclesTimer,\n} from './ReactDebugFiberPerf';\nimport {createWorkInProgress, assignFiberPropertiesInDEV} from './ReactFiber';\nimport {onCommitRoot} from './ReactFiberDevToolsHook';\nimport {\n  NoWork,\n  Sync,\n  Never,\n  msToExpirationTime,\n  expirationTimeToMs,\n  computeAsyncExpiration,\n  computeInteractiveExpiration,\n  LOW_PRIORITY_EXPIRATION,\n} from './ReactFiberExpirationTime';\nimport {ConcurrentMode, ProfileMode} from './ReactTypeOfMode';\nimport {enqueueUpdate, resetCurrentlyProcessingQueue} from './ReactUpdateQueue';\nimport {createCapturedValue} from './ReactCapturedValue';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n  popContext as popLegacyContext,\n} from './ReactFiberContext';\nimport {popProvider, resetContextDependences} from './ReactFiberNewContext';\nimport {resetHooks} from './ReactFiberHooks';\nimport {popHostContext, popHostContainer} from './ReactFiberHostContext';\nimport {\n  recordCommitTime,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n} from './ReactProfilerTimer';\nimport {\n  checkThatStackIsEmpty,\n  resetStackAfterFatalErrorInDev,\n} from './ReactFiberStack';\nimport {beginWork} from './ReactFiberBeginWork';\nimport {completeWork} from './ReactFiberCompleteWork';\nimport {\n  throwException,\n  unwindWork,\n  unwindInterruptedWork,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberUnwindWork';\nimport {\n  commitBeforeMutationLifeCycles,\n  commitResetTextContent,\n  commitPlacement,\n  commitDeletion,\n  commitWork,\n  commitLifeCycles,\n  commitAttachRef,\n  commitDetachRef,\n  commitPassiveHookEffects,\n} from './ReactFiberCommitWork';\nimport {ContextOnlyDispatcher} from './ReactFiberHooks';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nconst {\n  unstable_scheduleCallback: scheduleCallback,\n  unstable_cancelCallback: cancelCallback,\n  unstable_shouldYield: shouldYield,\n  unstable_now: now,\n  unstable_getCurrentPriorityLevel: getCurrentPriorityLevel,\n  unstable_NormalPriority: NormalPriority,\n} = Scheduler;\n\nexport type Thenable = {\n  then(resolve: () => mixed, reject?: () => mixed): void | Thenable,\n};\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  ReactShouldWarnActingUpdates,\n} = ReactSharedInternals;\n\nlet didWarnAboutStateTransition;\nlet didWarnSetStateChildContext;\nlet warnAboutUpdateOnUnmounted;\nlet warnAboutInvalidUpdates;\n\nif (enableSchedulerTracing) {\n  // Provide explicit error message when production+profiling bundle of e.g. react-dom\n  // is used with production (non-profiling) bundle of scheduler/tracing\n  invariant(\n    __interactionsRef != null && __interactionsRef.current != null,\n    'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) ' +\n      'without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. ' +\n      'Your bundler might have a setting for aliasing both modules. ' +\n      'Learn more at http://fb.me/react-profiling',\n  );\n}\n\nif (__DEV__) {\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  const didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function(fiber: Fiber, isClass: boolean) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warningWithoutStack(\n      false,\n      \"Can't perform a React state update on an unmounted component. This \" +\n        'is a no-op, but it indicates a memory leak in your application. To ' +\n        'fix, cancel all subscriptions and asynchronous tasks in %s.%s',\n      isClass\n        ? 'the componentWillUnmount method'\n        : 'a useEffect cleanup function',\n      getStackByFiberInDevAndProd(fiber),\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function(instance: React$Component<any>) {\n    switch (ReactCurrentFiberPhase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warningWithoutStack(\n          false,\n          'setState(...): Cannot call setState() inside getChildContext()',\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warningWithoutStack(\n          false,\n          'Cannot update during an existing state transition (such as within ' +\n            '`render`). Render methods should be a pure function of props and state.',\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Used to ensure computeUniqueAsyncExpiration is monotonically decreasing.\nlet lastUniqueAsyncExpiration: number = Sync - 1;\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nlet expirationContext: ExpirationTime = NoWork;\n\nlet isWorking: boolean = false;\n\n// The next work in progress fiber that we're currently working on.\nlet nextUnitOfWork: Fiber | null = null;\nlet nextRoot: FiberRoot | null = null;\n// The time at which we're currently rendering work.\nlet nextRenderExpirationTime: ExpirationTime = NoWork;\nlet nextLatestAbsoluteTimeoutMs: number = -1;\nlet nextRenderDidError: boolean = false;\n\n// The next fiber with an effect that we're currently committing.\nlet nextEffect: Fiber | null = null;\n\nlet isCommitting: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet passiveEffectCallbackHandle: * = null;\nlet passiveEffectCallback: * = null;\n\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\n// Used for performance tracking.\nlet interruptedBy: Fiber | null = null;\n\nlet stashedWorkInProgressProperties;\nlet replayUnitOfWork;\nlet mayReplayFailedUnitOfWork;\nlet isReplayingFailedUnitOfWork;\nlet originalReplayError;\nlet rethrowOriginalError;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  mayReplayFailedUnitOfWork = true;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = (\n    failedUnitOfWork: Fiber,\n    thrownValue: mixed,\n    isYieldy: boolean,\n  ) => {\n    if (\n      thrownValue !== null &&\n      typeof thrownValue === 'object' &&\n      typeof thrownValue.then === 'function'\n    ) {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warningWithoutStack(\n        false,\n        'Could not replay rendering after an error. This is likely a bug in React. ' +\n          'Please file an issue.',\n      );\n      return;\n    }\n    assignFiberPropertiesInDEV(\n      failedUnitOfWork,\n      stashedWorkInProgressProperties,\n    );\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelLegacyContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent: {\n        const Component = failedUnitOfWork.type;\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(failedUnitOfWork);\n        }\n        break;\n      }\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback(null, workLoop, null, isYieldy);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      const replayError = clearCaughtError();\n      if (replayError != null && thrownValue != null) {\n        try {\n          // Reading the expando property is intentionally\n          // inside `try` because it might be a getter or Proxy.\n          if (replayError._suppressLogging) {\n            // Also suppress logging for the original error.\n            (thrownValue: any)._suppressLogging = true;\n          }\n        } catch (inner) {\n          // Ignore.\n        }\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = () => {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  // nextUnitOfWork：下一个需要执行的 fiber 节点\n  if (nextUnitOfWork !== null) {\n    // 往上找 fiber 节点\n    let interruptedWork = nextUnitOfWork.return;\n    // 如果存在父节点的话，就清掉父节点的 valueStack\n    // valueStack 因为之前代码里没见过，所以去网上查了点资料\n    // 发现这个数组应该是用来存储数据的\n    // 这个做法应该是为了重头开始一个新的任务。因为打断一个任务的时候\n    // 被打断的任务可能已经改变一部分节点的数据，这时候新的任务开始时\n    // 不应该被之前的任务所影响，需要清掉之前任务的影响。\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n  // 重置变量\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestAbsoluteTimeoutMs = -1;\n  nextRenderDidError = false;\n  nextUnitOfWork = null;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    if (__DEV__) {\n      setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    let primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted\n        // does and isMounted is deprecated anyway so we should be able\n        // to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(nextEffect);\n        break;\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  if (__DEV__) {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    if (__DEV__) {\n      setCurrentFiber(nextEffect);\n    }\n\n    const effectTag = nextEffect.effectTag;\n    if (effectTag & Snapshot) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current, nextEffect);\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  if (__DEV__) {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitAllLifeCycles(\n  finishedRoot: FiberRoot,\n  committedExpirationTime: ExpirationTime,\n) {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n  }\n  while (nextEffect !== null) {\n    if (__DEV__) {\n      setCurrentFiber(nextEffect);\n    }\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitLifeCycles(\n        finishedRoot,\n        current,\n        nextEffect,\n        committedExpirationTime,\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    if (effectTag & Passive) {\n      rootWithPendingPassiveEffects = finishedRoot;\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n  if (__DEV__) {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitPassiveEffects(root: FiberRoot, firstEffect: Fiber): void {\n  rootWithPendingPassiveEffects = null;\n  passiveEffectCallbackHandle = null;\n  passiveEffectCallback = null;\n\n  // Set this to true to prevent re-entrancy\n  const previousIsRendering = isRendering;\n  isRendering = true;\n\n  let effect = firstEffect;\n  do {\n    if (__DEV__) {\n      setCurrentFiber(effect);\n    }\n\n    if (effect.effectTag & Passive) {\n      let didError = false;\n      let error;\n      if (__DEV__) {\n        isInPassiveEffectDEV = true;\n        invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n        isInPassiveEffectDEV = false;\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n        }\n      } else {\n        try {\n          commitPassiveHookEffects(effect);\n        } catch (e) {\n          didError = true;\n          error = e;\n        }\n      }\n      if (didError) {\n        captureCommitPhaseError(effect, error);\n      }\n    }\n    effect = effect.nextEffect;\n  } while (effect !== null);\n  if (__DEV__) {\n    resetCurrentFiber();\n  }\n\n  isRendering = previousIsRendering;\n\n  // Check if work was scheduled by one of the effects\n  const rootExpirationTime = root.expirationTime;\n  if (rootExpirationTime !== NoWork) {\n    requestWork(root, rootExpirationTime);\n  }\n  // Flush any sync work that was scheduled by effects\n  if (!isBatchingUpdates && !isRendering) {\n    performSyncWork();\n  }\n\n  if (__DEV__) {\n    if (rootWithPendingPassiveEffects === root) {\n      nestedPassiveEffectCountDEV++;\n    } else {\n      nestedPassiveEffectCountDEV = 0;\n    }\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction flushPassiveEffects() {\n  const didFlushEffects = passiveEffectCallback !== null;\n  if (passiveEffectCallbackHandle !== null) {\n    cancelCallback(passiveEffectCallbackHandle);\n  }\n  if (passiveEffectCallback !== null) {\n    // We call the scheduled callback instead of commitPassiveEffects directly\n    // to ensure tracing works correctly.\n    passiveEffectCallback();\n  }\n  return didFlushEffects;\n}\n\nfunction commitRoot(root: FiberRoot, finishedWork: Fiber): void {\n  isWorking = true;\n  isCommitting = true;\n  startCommitTimer();\n\n  invariant(\n    root.current !== finishedWork,\n    'Cannot commit the same tree as before. This is probably a bug ' +\n      'related to the return field. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n  const committedExpirationTime = root.pendingCommitExpirationTime;\n  invariant(\n    committedExpirationTime !== NoWork,\n    'Cannot commit an incomplete root. This error is likely caused by a ' +\n      'bug in React. Please file an issue.',\n  );\n  root.pendingCommitExpirationTime = NoWork;\n\n  // Update the pending priority levels to account for the work that we are\n  // about to commit. This needs to happen before calling the lifecycles, since\n  // they may schedule additional updates.\n  const updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n  const childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n  const earliestRemainingTimeBeforeCommit =\n    childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit\n      ? childExpirationTimeBeforeCommit\n      : updateExpirationTimeBeforeCommit;\n  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);\n\n  let prevInteractions: Set<Interaction> = (null: any);\n  if (enableSchedulerTracing) {\n    // Restore any pending interactions at this point,\n    // So that cascading work triggered during the render phase will be accounted for.\n    prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n  }\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner.current = null;\n\n  let firstEffect;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    let didError = false;\n    let error;\n    if (__DEV__) {\n      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    } else {\n      try {\n        commitBeforeMutationLifecycles();\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n    }\n    if (didError) {\n      invariant(\n        nextEffect !== null,\n        'Should have next effect. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    let didError = false;\n    let error;\n    if (__DEV__) {\n      invokeGuardedCallback(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    } else {\n      try {\n        commitAllHostEffects();\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n    }\n    if (didError) {\n      invariant(\n        nextEffect !== null,\n        'Should have next effect. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    let didError = false;\n    let error;\n    if (__DEV__) {\n      invokeGuardedCallback(\n        null,\n        commitAllLifeCycles,\n        null,\n        root,\n        committedExpirationTime,\n      );\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    } else {\n      try {\n        commitAllLifeCycles(root, committedExpirationTime);\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n    }\n    if (didError) {\n      invariant(\n        nextEffect !== null,\n        'Should have next effect. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n      captureCommitPhaseError(nextEffect, error);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {\n    // This commit included a passive effect. These do not need to fire until\n    // after the next paint. Schedule an callback to fire them in an async\n    // event. To ensure serial execution, the callback will be flushed early if\n    // we enter rootWithPendingPassiveEffects commit phase before then.\n    let callback = commitPassiveEffects.bind(null, root, firstEffect);\n    if (enableSchedulerTracing) {\n      // TODO: Avoid this extra callback by mutating the tracing ref directly,\n      // like we do at the beginning of commitRoot. I've opted not to do that\n      // here because that code is still in flux.\n      callback = Scheduler_tracing_wrap(callback);\n    }\n    passiveEffectCallbackHandle = scheduleCallback(NormalPriority, callback);\n    passiveEffectCallback = callback;\n  }\n\n  isCommitting = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  onCommitRoot(finishedWork.stateNode);\n  if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n    ReactFiberInstrumentation.debugTool.onCommitWork(finishedWork);\n  }\n\n  const updateExpirationTimeAfterCommit = finishedWork.expirationTime;\n  const childExpirationTimeAfterCommit = finishedWork.childExpirationTime;\n  const earliestRemainingTimeAfterCommit =\n    childExpirationTimeAfterCommit > updateExpirationTimeAfterCommit\n      ? childExpirationTimeAfterCommit\n      : updateExpirationTimeAfterCommit;\n  if (earliestRemainingTimeAfterCommit === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  onCommit(root, earliestRemainingTimeAfterCommit);\n\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = prevInteractions;\n\n    let subscriber;\n\n    try {\n      subscriber = __subscriberRef.current;\n      if (subscriber !== null && root.memoizedInteractions.size > 0) {\n        const threadID = computeThreadID(\n          committedExpirationTime,\n          root.interactionThreadID,\n        );\n        subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n      }\n    } catch (error) {\n      // It's not safe for commitRoot() to throw.\n      // Store the error for now and we'll re-throw in finishRendering().\n      if (!hasUnhandledError) {\n        hasUnhandledError = true;\n        unhandledError = error;\n      }\n    } finally {\n      // Clear completed interactions from the pending Map.\n      // Unless the render was suspended or cascading work was scheduled,\n      // In which case– leave pending interactions until the subsequent render.\n      const pendingInteractionMap = root.pendingInteractionMap;\n      pendingInteractionMap.forEach(\n        (scheduledInteractions, scheduledExpirationTime) => {\n          // Only decrement the pending interaction count if we're done.\n          // If there's still work at the current priority,\n          // That indicates that we are waiting for suspense data.\n          if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n            pendingInteractionMap.delete(scheduledExpirationTime);\n\n            scheduledInteractions.forEach(interaction => {\n              interaction.__count--;\n\n              if (subscriber !== null && interaction.__count === 0) {\n                try {\n                  subscriber.onInteractionScheduledWorkCompleted(interaction);\n                } catch (error) {\n                  // It's not safe for commitRoot() to throw.\n                  // Store the error for now and we'll re-throw in finishRendering().\n                  if (!hasUnhandledError) {\n                    hasUnhandledError = true;\n                    unhandledError = error;\n                  }\n                }\n              }\n            });\n          }\n        },\n      );\n    }\n  }\n}\n\nfunction resetChildExpirationTime(\n  workInProgress: Fiber,\n  renderTime: ExpirationTime,\n) {\n  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    // We're in profiling mode.\n    // Let's use this same traversal to update the render durations.\n    let actualDuration = workInProgress.actualDuration;\n    let treeBaseDuration = workInProgress.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0.\n    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration.\n    // If the fiber has not been cloned though, (meaning no work was done),\n    // Then this value will reflect the amount of time spent working on a previous render.\n    // In that case it should not bubble.\n    // We determine whether it was cloned by comparing the child pointer.\n    const shouldBubbleActualDurations =\n      workInProgress.alternate === null ||\n      workInProgress.child !== workInProgress.alternate.child;\n\n    let child = workInProgress.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    workInProgress.actualDuration = actualDuration;\n    workInProgress.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = workInProgress.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      child = child.sibling;\n    }\n  }\n\n  workInProgress.childExpirationTime = newChildExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress: Fiber): Fiber | null {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    const current = workInProgress.alternate;\n    if (__DEV__) {\n      setCurrentFiber(workInProgress);\n    }\n\n    const returnFiber = workInProgress.return;\n    const siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      if (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n        // Don't replay if it fails during completion phase.\n        mayReplayFailedUnitOfWork = false;\n      }\n      // This fiber completed.\n      // Remember we're completing this unit so we can find a boundary if it fails.\n      nextUnitOfWork = workInProgress;\n      if (enableProfilerTimer) {\n        if (workInProgress.mode & ProfileMode) {\n          startProfilerTimer(workInProgress);\n        }\n        nextUnitOfWork = completeWork(\n          current,\n          workInProgress,\n          nextRenderExpirationTime,\n        );\n        if (workInProgress.mode & ProfileMode) {\n          // Update render duration assuming we didn't error.\n          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n        }\n      } else {\n        nextUnitOfWork = completeWork(\n          current,\n          workInProgress,\n          nextRenderExpirationTime,\n        );\n      }\n      if (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n        // We're out of completion phase so replaying is fine now.\n        mayReplayFailedUnitOfWork = true;\n      }\n      stopWorkTimer(workInProgress);\n      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);\n      if (__DEV__) {\n        resetCurrentFiber();\n      }\n\n      if (nextUnitOfWork !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        return nextUnitOfWork;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        const effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n        ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        return null;\n      }\n    } else {\n      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      if (__DEV__) {\n        resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n          ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);\n        }\n\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n        ReactFiberInstrumentation.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\n// 开始组件更新\nfunction performUnitOfWork(workInProgress: Fiber): Fiber | null {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  // 获得 fiber 的替身，调和这一阶段都是在替身上完成的\n  // 然后直接看 beginWork\n  const current = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  if (__DEV__) {\n    setCurrentFiber(workInProgress);\n  }\n\n  if (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(\n      stashedWorkInProgressProperties,\n      workInProgress,\n    );\n  }\n\n  let next;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startProfilerTimer(workInProgress);\n    }\n    next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    workInProgress.memoizedProps = workInProgress.pendingProps;\n\n    if (workInProgress.mode & ProfileMode) {\n      // Record the render duration assuming we didn't bailout (or error).\n      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n    }\n  } else {\n    // 开始工作\n    next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    workInProgress.memoizedProps = workInProgress.pendingProps;\n  }\n\n  if (__DEV__) {\n    resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (__DEV__ && ReactFiberInstrumentation.debugTool) {\n    ReactFiberInstrumentation.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner.current = null;\n\n  return next;\n}\n\nfunction workLoop(isYieldy) {\n  // 对 nextUnitOfWork 循环进行判断，直到没有 nextUnitOfWork\n  if (!isYieldy) {\n    // Flush work without yielding\n    // 一开始进来 nextUnitOfWork 是 root，每次执行 performUnitOfWork 后\n    // 都会生成下一个工作单元\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until there's a higher priority event\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\n// 开始渲染整颗树，这个函数在异步模式下可能会被多次执行，因为在异步模式下\n// 可以打断任务。打断也就意味着每次都得回到 root 再开始从上往下循环\nfunction renderRoot(root: FiberRoot, isYieldy: boolean): void {\n  invariant(\n    !isWorking,\n    'renderRoot was called recursively. This error is likely caused ' +\n      'by a bug in React. Please file an issue.',\n  );\n\n  flushPassiveEffects();\n\n  isWorking = true;\n  const previousDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  const expirationTime = root.nextExpirationTimeToWorkOn;\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (\n    expirationTime !== nextRenderExpirationTime ||\n    root !== nextRoot ||\n    nextUnitOfWork === null\n  ) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    // 获取下一个需要工作的单元\n    nextUnitOfWork = createWorkInProgress(\n      nextRoot.current,\n      null,\n      nextRenderExpirationTime,\n    );\n    root.pendingCommitExpirationTime = NoWork;\n\n    if (enableSchedulerTracing) {\n      // Determine which interactions this batch of work currently includes,\n      // So that we can accurately attribute time spent working on it,\n      // And so that cascading work triggered during the render phase will be associated with it.\n      const interactions: Set<Interaction> = new Set();\n      root.pendingInteractionMap.forEach(\n        (scheduledInteractions, scheduledExpirationTime) => {\n          if (scheduledExpirationTime >= expirationTime) {\n            scheduledInteractions.forEach(interaction =>\n              interactions.add(interaction),\n            );\n          }\n        },\n      );\n\n      // Store the current set of interactions on the FiberRoot for a few reasons:\n      // We can re-use it in hot functions like renderRoot() without having to recalculate it.\n      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.\n      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.\n      root.memoizedInteractions = interactions;\n\n      if (interactions.size > 0) {\n        const subscriber = __subscriberRef.current;\n        if (subscriber !== null) {\n          const threadID = computeThreadID(\n            expirationTime,\n            root.interactionThreadID,\n          );\n          try {\n            subscriber.onWorkStarted(interactions, threadID);\n          } catch (error) {\n            // Work thrown by an interaction tracing subscriber should be rethrown,\n            // But only once it's safe (to avoid leaving the scheduler in an invalid state).\n            // Store the error for now and we'll re-throw in finishRendering().\n            if (!hasUnhandledError) {\n              hasUnhandledError = true;\n              unhandledError = error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let prevInteractions: Set<Interaction> = (null: any);\n  if (enableSchedulerTracing) {\n    // We're about to start new traced work.\n    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.\n    prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n  }\n\n  let didFatal = false;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      // 循环更新节点\n      workLoop(isYieldy);\n    } catch (thrownValue) {\n      resetContextDependences();\n      resetHooks();\n\n      // Reset in case completion throws.\n      // This is only used in DEV and when replaying is on.\n      let mayReplay;\n      if (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n        mayReplay = mayReplayFailedUnitOfWork;\n        mayReplayFailedUnitOfWork = true;\n      }\n\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        if (enableProfilerTimer && nextUnitOfWork.mode & ProfileMode) {\n          // Record the time spent rendering before an error was thrown.\n          // This avoids inaccurate Profiler durations in the case of a suspended render.\n          stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork, true);\n        }\n\n        if (__DEV__) {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          (resetCurrentlyProcessingQueue: any)();\n        }\n\n        if (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          if (mayReplay) {\n            const failedUnitOfWork: Fiber = nextUnitOfWork;\n            replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n          }\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        invariant(\n          nextUnitOfWork !== null,\n          'Failed to replay rendering after an error. This ' +\n            'is likely caused by a bug in React. Please file an issue ' +\n            'with a reproducing case to help us find it.',\n        );\n\n        const sourceFiber: Fiber = nextUnitOfWork;\n        let returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n        } else {\n          throwException(\n            root,\n            returnFiber,\n            sourceFiber,\n            thrownValue,\n            nextRenderExpirationTime,\n          );\n          nextUnitOfWork = completeUnitOfWork(sourceFiber);\n          continue;\n        }\n      }\n    }\n    break;\n  } while (true);\n\n  if (enableSchedulerTracing) {\n    // Traced work is done for now; restore the previous interactions.\n    __interactionsRef.current = prevInteractions;\n  }\n\n  // We're done performing work. Time to clean up.\n  isWorking = false;\n  ReactCurrentDispatcher.current = previousDispatcher;\n  resetContextDependences();\n  resetHooks();\n\n  // Yield back to main thread.\n  if (didFatal) {\n    const didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    if (__DEV__) {\n      resetStackAfterFatalErrorInDev();\n    }\n    // `nextRoot` points to the in-progress root. A non-null value indicates\n    // that we're in the middle of an async render. Set it to null to indicate\n    // there's no more work to be done in the current batch.\n    nextRoot = null;\n    onFatal(root);\n    return;\n  }\n\n  if (nextUnitOfWork !== null) {\n    // There's still remaining async work in this tree, but we ran out of time\n    // in the current frame. Yield back to the renderer. Unless we're\n    // interrupted by a higher priority update, we'll continue later from where\n    // we left off.\n    const didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n    interruptedBy = null;\n    onYield(root);\n    return;\n  }\n\n  // We completed the whole tree.\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  const rootWorkInProgress = root.current.alternate;\n  invariant(\n    rootWorkInProgress !== null,\n    'Finished root should have a work-in-progress. This error is likely ' +\n      'caused by a bug in React. Please file an issue.',\n  );\n\n  // `nextRoot` points to the in-progress root. A non-null value indicates\n  // that we're in the middle of an async render. Set it to null to indicate\n  // there's no more work to be done in the current batch.\n  nextRoot = null;\n  interruptedBy = null;\n\n  if (nextRenderDidError) {\n    // There was an error\n    if (hasLowerPriorityWork(root, expirationTime)) {\n      // There's lower priority work. If so, it may have the effect of fixing\n      // the exception that was just thrown. Exit without committing. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve. React will restart at the lower\n      // priority level.\n      markSuspendedPriorityLevel(root, expirationTime);\n      const suspendedExpirationTime = expirationTime;\n      const rootExpirationTime = root.expirationTime;\n      onSuspend(\n        root,\n        rootWorkInProgress,\n        suspendedExpirationTime,\n        rootExpirationTime,\n        -1, // Indicates no timeout\n      );\n      return;\n    } else if (\n      // There's no lower priority work, but we're rendering asynchronously.\n      // Synchronously attempt to render the same level one more time. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve.\n      !root.didError &&\n      isYieldy\n    ) {\n      root.didError = true;\n      const suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime);\n      const rootExpirationTime = (root.expirationTime = Sync);\n      onSuspend(\n        root,\n        rootWorkInProgress,\n        suspendedExpirationTime,\n        rootExpirationTime,\n        -1, // Indicates no timeout\n      );\n      return;\n    }\n  }\n\n  if (isYieldy && nextLatestAbsoluteTimeoutMs !== -1) {\n    // The tree was suspended.\n    const suspendedExpirationTime = expirationTime;\n    markSuspendedPriorityLevel(root, suspendedExpirationTime);\n\n    // Find the earliest uncommitted expiration time in the tree, including\n    // work that is suspended. The timeout threshold cannot be longer than\n    // the overall expiration.\n    const earliestExpirationTime = findEarliestOutstandingPriorityLevel(\n      root,\n      expirationTime,\n    );\n    const earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {\n      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;\n    }\n\n    // Subtract the current time from the absolute timeout to get the number\n    // of milliseconds until the timeout. In other words, convert an absolute\n    // timestamp to a relative time. This is the value that is passed\n    // to `setTimeout`.\n    const currentTimeMs = expirationTimeToMs(requestCurrentTime());\n    let msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;\n    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;\n\n    // TODO: Account for the Just Noticeable Difference\n\n    const rootExpirationTime = root.expirationTime;\n    onSuspend(\n      root,\n      rootWorkInProgress,\n      suspendedExpirationTime,\n      rootExpirationTime,\n      msUntilTimeout,\n    );\n    return;\n  }\n\n  // Ready to commit.\n  onComplete(root, rootWorkInProgress, expirationTime);\n}\n\nfunction captureCommitPhaseError(sourceFiber: Fiber, value: mixed) {\n  const expirationTime = Sync;\n  let fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n        const ctor = fiber.type;\n        const instance = fiber.stateNode;\n        if (\n          typeof ctor.getDerivedStateFromError === 'function' ||\n          (typeof instance.componentDidCatch === 'function' &&\n            !isAlreadyFailedLegacyErrorBoundary(instance))\n        ) {\n          const errorInfo = createCapturedValue(value, sourceFiber);\n          const update = createClassErrorUpdate(\n            fiber,\n            errorInfo,\n            expirationTime,\n          );\n          enqueueUpdate(fiber, update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot: {\n        const errorInfo = createCapturedValue(value, sourceFiber);\n        const update = createRootErrorUpdate(fiber, errorInfo, expirationTime);\n        enqueueUpdate(fiber, update);\n        scheduleWork(fiber, expirationTime);\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    const rootFiber = sourceFiber;\n    const errorInfo = createCapturedValue(value, rootFiber);\n    const update = createRootErrorUpdate(rootFiber, errorInfo, expirationTime);\n    enqueueUpdate(rootFiber, update);\n    scheduleWork(rootFiber, expirationTime);\n  }\n}\n\nfunction computeThreadID(\n  expirationTime: ExpirationTime,\n  interactionThreadID: number,\n): number {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + interactionThreadID;\n}\n\n// Creates a unique async expiration time.\nfunction computeUniqueAsyncExpiration(): ExpirationTime {\n  const currentTime = requestCurrentTime();\n  let result = computeAsyncExpiration(currentTime);\n  if (result >= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result = lastUniqueAsyncExpiration - 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return lastUniqueAsyncExpiration;\n}\n\nfunction computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) {\n  let expirationTime;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & ConcurrentMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // If we're in the middle of rendering a tree, do not update at the same\n      // expiration time that is already rendering.\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n        expirationTime -= 1;\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (\n      lowestPriorityPendingInteractiveExpirationTime === NoWork ||\n      expirationTime < lowestPriorityPendingInteractiveExpirationTime\n    ) {\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\nfunction renderDidSuspend(\n  root: FiberRoot,\n  absoluteTimeoutMs: number,\n  suspendedTime: ExpirationTime,\n) {\n  // Schedule the timeout.\n  if (\n    absoluteTimeoutMs >= 0 &&\n    nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs\n  ) {\n    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;\n  }\n}\n\nfunction renderDidError() {\n  nextRenderDidError = true;\n}\n\nfunction inferStartTimeFromExpirationTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time. First, find the earliest\n  // uncommitted expiration time in the tree, including work that is suspended.\n  // Then subtract the offset used to compute an async update's expiration time.\n  // This will cause high priority (interactive) work to expire earlier than\n  // necessary, but we can account for this by adjusting for the Just\n  // Noticeable Difference.\n  const earliestExpirationTime = findEarliestOutstandingPriorityLevel(\n    root,\n    expirationTime,\n  );\n  const earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction pingSuspendedRoot(\n  root: FiberRoot,\n  thenable: Thenable,\n  pingTime: ExpirationTime,\n) {\n  // A promise that previously suspended React from committing has resolved.\n  // If React is still suspended, try again at the previous level (pingTime).\n\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (nextRoot !== null && nextRenderExpirationTime === pingTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. Restart from the root.\n    nextRoot = null;\n  } else {\n    // Confirm that the root is still suspended at this level. Otherwise exit.\n    if (isPriorityLevelSuspended(root, pingTime)) {\n      // Ping at the original level\n      markPingedPriorityLevel(root, pingTime);\n      const rootExpirationTime = root.expirationTime;\n      if (rootExpirationTime !== NoWork) {\n        requestWork(root, rootExpirationTime);\n      }\n    }\n  }\n}\n\nfunction retryTimedOutBoundary(boundaryFiber: Fiber) {\n  const currentTime = requestCurrentTime();\n  const retryTime = computeExpirationForFiber(currentTime, boundaryFiber);\n  const root = scheduleWorkToRoot(boundaryFiber, retryTime);\n  if (root !== null) {\n    markPendingPriorityLevel(root, retryTime);\n    const rootExpirationTime = root.expirationTime;\n    if (rootExpirationTime !== NoWork) {\n      requestWork(root, rootExpirationTime);\n    }\n  }\n}\n\nfunction resolveRetryThenable(boundaryFiber: Fiber, thenable: Thenable) {\n  // The boundary fiber (a Suspense component) previously timed out and was\n  // rendered in its fallback state. One of the promises that suspended it has\n  // resolved, which means at least part of the tree was likely unblocked. Try\n  // rendering again, at a new expiration time.\n\n  let retryCache: WeakSet<Thenable> | Set<Thenable> | null;\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n      case DehydratedSuspenseComponent:\n        retryCache = boundaryFiber.memoizedState;\n        break;\n      default:\n        invariant(\n          false,\n          'Pinged unknown suspense boundary type. ' +\n            'This is probably a bug in React.',\n        );\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber);\n}\n\nfunction scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null {\n  // 用于记录调度器的状态\n  recordScheduleUpdate();\n\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent) {\n      const instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  // Update the source fiber's expiration time\n  // expirationTime 越大说明优先级越高\n  // 以下两个 if 判断是在把 fiber 的优先级设置的更高\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  // 获取 fiber 的父节点，Root Fiber 是没有 return 属性的\n  let node = fiber.return;\n  let root = null;\n  // 判断这时候 fiber 是否为 Root Fiber\n  if (node === null && fiber.tag === HostRoot) {\n    // 取出 Fiber Root\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n      // 下面的判断都是在将低优先级设置为高的优先级\n      // 最后判断是否获得了 Root Fiber\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  // 这部分内容是 React Profiler 相关的，DevTool 相关的内容\n  // 可以方便找出你的 React 应用的性能瓶颈\n  // 这部分内容不在此介绍\n  if (enableSchedulerTracing) {\n    if (root !== null) {\n      const interactions = __interactionsRef.current;\n      if (interactions.size > 0) {\n        const pendingInteractionMap = root.pendingInteractionMap;\n        const pendingInteractions = pendingInteractionMap.get(expirationTime);\n        if (pendingInteractions != null) {\n          interactions.forEach(interaction => {\n            if (!pendingInteractions.has(interaction)) {\n              // Update the pending async work count for previously unscheduled interaction.\n              interaction.__count++;\n            }\n\n            pendingInteractions.add(interaction);\n          });\n        } else {\n          pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n          // Update the pending async work count for the current interactions.\n          interactions.forEach(interaction => {\n            interaction.__count++;\n          });\n        }\n\n        const subscriber = __subscriberRef.current;\n        if (subscriber !== null) {\n          const threadID = computeThreadID(\n            expirationTime,\n            root.interactionThreadID,\n          );\n          subscriber.onWorkScheduled(interactions, threadID);\n        }\n      }\n    }\n  }\n  return root;\n}\n\n// in a test-like environment, we want to warn if dispatchAction() is\n// called outside of a TestUtils.act(...)/batchedUpdates/render call.\n// so we have a a step counter for when we descend/ascend from\n// act() calls, and test on it for when to warn\n// It's a tuple with a single value. Look for shared/createAct to\n// see how we change the value inside act() calls\n\nexport function warnIfNotCurrentlyActingUpdatesInDev(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      isBatchingUpdates === false &&\n      isRendering === false &&\n      ReactShouldWarnActingUpdates.current === false\n    ) {\n      warningWithoutStack(\n        false,\n        'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see in the browser.\" +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nfunction scheduleWork (fiber: Fiber, expirationTime: ExpirationTime) {\n  // 获取 fiber root\n  const root = scheduleWorkToRoot(fiber, expirationTime);\n  if (root === null) {\n    if (__DEV__) {\n      switch (fiber.tag) {\n        case ClassComponent:\n          warnAboutUpdateOnUnmounted(fiber, true);\n          break;\n        case FunctionComponent:\n        case ForwardRef:\n        case MemoComponent:\n        case SimpleMemoComponent:\n          warnAboutUpdateOnUnmounted(fiber, false);\n          break;\n      }\n    }\n    return;\n  }\n  // 这个分支表示高优先级任务打断低优先级任务\n  // 这种情况发生于以下场景：有一个优先级较低的任务（必然是异步任务）没有执行完，\n  // 执行权交给了浏览器，然后再交还给 JS 的时候有一个新的高优先级任务进来了\n  // 这时候需要去执行高优先级任务，所以需要打断低优先级任务\n  if (\n    !isWorking &&\n    nextRenderExpirationTime !== NoWork &&\n    expirationTime > nextRenderExpirationTime\n  ) {\n    // This is an interruption. (Used for performance tracking.)\n    // 记录被谁打断的\n    interruptedBy = fiber;\n    // 重置 stack，具体来说应该是 valueStack\n    resetStack();\n  }\n  markPendingPriorityLevel(root, expirationTime);\n  if (\n    // If we're in the render phase, we don't need to schedule this root\n    // for an update, because we'll do it before we exit...\n    !isWorking ||\n    isCommitting ||\n    // ...unless this is a different root than the one we're rendering.\n    nextRoot !== root\n  ) {\n    const rootExpirationTime = root.expirationTime;\n    requestWork(root, rootExpirationTime);\n  }\n  // 在某些生命周期函数中 setState 会造成无限循环\n  // 这里是告知你的代码触发无限循环了\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    // Reset this back to zero so subsequent updates don't throw.\n    nestedUpdateCount = 0;\n    invariant(\n      false,\n      'Maximum update depth exceeded. This can happen when a ' +\n        'component repeatedly calls setState inside ' +\n        'componentWillUpdate or componentDidUpdate. React limits ' +\n        'the number of nested updates to prevent infinite loops.',\n    );\n  }\n  if (__DEV__) {\n    if (\n      isInPassiveEffectDEV &&\n      nestedPassiveEffectCountDEV > NESTED_PASSIVE_UPDATE_LIMIT\n    ) {\n      nestedPassiveEffectCountDEV = 0;\n      warning(\n        false,\n        'Maximum update depth exceeded. This can happen when a ' +\n          'component calls setState inside useEffect, but ' +\n          \"useEffect either doesn't have a dependency array, or \" +\n          'one of the dependencies changes on every render.',\n      );\n    }\n  }\n}\n\nfunction deferredUpdates<A>(fn: () => A): A {\n  const currentTime = requestCurrentTime();\n  const previousExpirationContext = expirationContext;\n  const previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  expirationContext = computeAsyncExpiration(currentTime);\n  isBatchingInteractiveUpdates = false;\n  try {\n    return fn();\n  } finally {\n    expirationContext = previousExpirationContext;\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n  }\n}\n\nfunction syncUpdates<A, B, C0, D, R>(\n  fn: (A, B, C0, D) => R,\n  a: A,\n  b: B,\n  c: C0,\n  d: D,\n): R {\n  const previousExpirationContext = expirationContext;\n  expirationContext = Sync;\n  try {\n    return fn(a, b, c, d);\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nlet firstScheduledRoot: FiberRoot | null = null;\nlet lastScheduledRoot: FiberRoot | null = null;\n\nlet callbackExpirationTime: ExpirationTime = NoWork;\nlet callbackID: *;\nlet isRendering: boolean = false;\nlet nextFlushedRoot: FiberRoot | null = null;\nlet nextFlushedExpirationTime: ExpirationTime = NoWork;\nlet lowestPriorityPendingInteractiveExpirationTime: ExpirationTime = NoWork;\nlet hasUnhandledError: boolean = false;\nlet unhandledError: mixed | null = null;\n\nlet isBatchingUpdates: boolean = false;\nlet isUnbatchingUpdates: boolean = false;\nlet isBatchingInteractiveUpdates: boolean = false;\n\nlet completedBatches: Array<Batch> | null = null;\n\nlet originalStartTimeMs: number = now();\nlet currentRendererTime: ExpirationTime = msToExpirationTime(\n  originalStartTimeMs,\n);\nlet currentSchedulerTime: ExpirationTime = currentRendererTime;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet lastCommittedRootDuringThisBatch: FiberRoot | null = null;\n\n// Similar, but for useEffect infinite loops. These are DEV-only.\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveEffectCountDEV;\nlet isInPassiveEffectDEV;\nif (__DEV__) {\n  nestedPassiveEffectCountDEV = 0;\n  isInPassiveEffectDEV = false;\n}\n\nfunction recomputeCurrentRendererTime() {\n  const currentTimeMs = now() - originalStartTimeMs;\n  currentRendererTime = msToExpirationTime(currentTimeMs);\n}\n\nfunction scheduleCallbackWithExpirationTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n) {\n  // 判断上一个 callback 是否执行完毕\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    // 当前任务如果优先级小于上个任务就退出\n    if (expirationTime < callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      // 否则的话就取消上个 callback\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelCallback(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    // 没有需要执行的上一个 callback，开始定时器，这个函数用于 devtool\n    startRequestCallbackTimer();\n  }\n\n  callbackExpirationTime = expirationTime;\n  // 当前 performance.now() 和程序刚执行时的 performance.now() 相减\n  const currentMs = now() - originalStartTimeMs;\n  const expirationTimeMs = expirationTimeToMs(expirationTime);\n  // 毫秒相减，优先级越大，算出来的值越小，可以自己模拟一下\n  // 这个值在后面会和 performance.now() 相加再算出一个 expirationTime\n  const timeout = expirationTimeMs - currentMs;\n  // 获取优先级，这个优先级有五个，但是这个优先级其实在 scheduleCallback 函数中压根没用到\n  const priorityLevel = getCurrentPriorityLevel();\n  callbackID = scheduleCallback(priorityLevel, performAsyncWork, {timeout});\n}\n\n// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and\n// onYield is called upon exiting. We use these in lieu of returning a tuple.\n// I've also chosen not to inline them into renderRoot because these will\n// eventually be lifted into the renderer.\nfunction onFatal(root) {\n  root.finishedWork = null;\n}\n\nfunction onComplete(\n  root: FiberRoot,\n  finishedWork: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  root.pendingCommitExpirationTime = expirationTime;\n  root.finishedWork = finishedWork;\n}\n\nfunction onSuspend(\n  root: FiberRoot,\n  finishedWork: Fiber,\n  suspendedExpirationTime: ExpirationTime,\n  rootExpirationTime: ExpirationTime,\n  msUntilTimeout: number,\n): void {\n  root.expirationTime = rootExpirationTime;\n  if (msUntilTimeout === 0 && (disableYielding || !shouldYield())) {\n    // Don't wait an additional tick. Commit the tree immediately.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n  } else if (msUntilTimeout > 0) {\n    // Wait `msUntilTimeout` milliseconds before committing.\n    root.timeoutHandle = scheduleTimeout(\n      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),\n      msUntilTimeout,\n    );\n  }\n}\n\nfunction onYield(root) {\n  root.finishedWork = null;\n}\n\nfunction onTimeout(root, finishedWork, suspendedExpirationTime) {\n  // The root timed out. Commit it.\n  root.pendingCommitExpirationTime = suspendedExpirationTime;\n  root.finishedWork = finishedWork;\n  // Read the current time before entering the commit phase. We can be\n  // certain this won't cause tearing related to batching of event updates\n  // because we're at the top of a timer event.\n  recomputeCurrentRendererTime();\n  currentSchedulerTime = currentRendererTime;\n  flushRoot(root, suspendedExpirationTime);\n}\n\nfunction onCommit(root, expirationTime) {\n  root.expirationTime = expirationTime;\n  root.finishedWork = null;\n}\n\nfunction requestCurrentTime() {\n  // requestCurrentTime is called by the scheduler to compute an expiration\n  // time.\n  //\n  // Expiration times are computed by adding to the current time (the start\n  // time). However, if two updates are scheduled within the same event, we\n  // should treat their start times as simultaneous, even if the actual clock\n  // time has advanced between the first and second call.\n\n  // In other words, because expiration times determine how updates are batched,\n  // we want all updates of like priority that occur within the same event to\n  // receive the same expiration time. Otherwise we get tearing.\n  //\n  // We keep track of two separate times: the current \"renderer\" time and the\n  // current \"scheduler\" time. The renderer time can be updated whenever; it\n  // only exists to minimize the calls performance.now.\n  //\n  // But the scheduler time can only be updated if there's no pending work, or\n  // if we know for certain that we're not in the middle of an event.\n\n  if (isRendering) {\n    // We're already rendering. Return the most recently read time.\n    return currentSchedulerTime;\n  }\n  // Check if there's pending work.\n  findHighestPriorityRoot();\n  if (\n    nextFlushedExpirationTime === NoWork ||\n    nextFlushedExpirationTime === Never\n  ) {\n    // If there's no pending work, or if the pending work is offscreen, we can\n    // read the current time without risk of tearing.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  // There's already pending work. We might be in the middle of a browser\n  // event. If we were to read the current time, it could cause multiple updates\n  // within the same event to receive different expiration times, leading to\n  // tearing. Return the last read time. During the next idle callback, the\n  // time will be updated.\n  return currentSchedulerTime;\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root: FiberRoot, expirationTime: ExpirationTime) {\n  // 将 root 加入调度中\n  addRootToSchedule(root, expirationTime);\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n  // 判断是否需要批量更新\n  // 当我们触发事件回调时，其实回调会被 batchedUpdates 函数封装一次\n  // 这个函数会把 isBatchingUpdates 设为 true，也就是说我们在事件回调函数内部\n  // 调用 setState 不会马上触发 state 的更新及渲染，只是单纯创建了一个 updater，然后在这个分支 return 了\n  // 只有当整个事件回调函数执行完毕后恢复 isBatchingUpdates 的值，并且执行 performSyncWork\n  // 想必很多人知道在类似 setTimeout 中使用 setState 以后 state 会马上更新，如果你想在定时器回调中也实现批量更新，\n  // 就可以使用 batchedUpdates 将你需要的代码封装一下\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    // 判断是否不需要批量更新\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, false);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  // 判断优先级是同步还是异步，异步的话需要调度\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    // 函数核心是实现了 requestIdleCallback 的 polyfill 版本\n    // 因为这个函数浏览器的兼容性很差\n    // 具体作用可以查看 MDN 文档 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\n    // 这个函数可以让浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，\n    // 而且不会对像动画和用户交互这样延迟敏感的事件产生影响\n    scheduleCallbackWithExpirationTime(root, expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root: FiberRoot, expirationTime: ExpirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  // 判断 root 是否调度过\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    // root 没有调度过\n    root.expirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    // root 已经调度过，判断是否需要更新优先级\n    const remainingExpirationTime = root.expirationTime;\n    if (expirationTime > remainingExpirationTime) {\n      // Update the priority.\n      root.expirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  let highestPriorityWork = NoWork;\n  let highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    let previousScheduledRoot = lastScheduledRoot;\n    let root = firstScheduledRoot;\n    while (root !== null) {\n      const remainingExpirationTime = root.expirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        invariant(\n          previousScheduledRoot !== null && lastScheduledRoot !== null,\n          'Should have a previous and last root. This error is likely ' +\n            'caused by a bug in React. Please file an issue.',\n        );\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          const next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (remainingExpirationTime > highestPriorityWork) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        if (highestPriorityWork === Sync) {\n          // Sync is highest priority by definition so\n          // we can stop searching.\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(didTimeout) {\n  // 判断任务是否过期\n  if (didTimeout) {\n    // The callback timed out. That means at least one update has expired.\n    // Iterate through the root schedule. If they contain expired work, set\n    // the next render expiration time to the current time. This has the effect\n    // of flushing all expired work in a single batch, instead of flushing each\n    // level one at a time.\n    if (firstScheduledRoot !== null) {\n      recomputeCurrentRendererTime();\n      let root: FiberRoot = firstScheduledRoot;\n      do {\n        didExpireAtExpirationTime(root, currentRendererTime);\n        // The root schedule is circular, so this is never null.\n        root = (root.nextScheduledRoot: any);\n      } while (root !== firstScheduledRoot);\n    }\n  }\n\n  // Keep working on roots until there's no more work, or until there's a higher\n  // priority event.\n  // 找到优先级最高的节点\n  findHighestPriorityRoot();\n  // 判断是否可以打断\n  if (disableYielding) {\n    // Just do it all\n    // 不可以打断，把任务执行到底\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n      findHighestPriorityRoot();\n    }\n  } else {\n    // 可以打断\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableUserTimingAPI) {\n      const didExpire = nextFlushedExpirationTime > currentRendererTime;\n      const timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n    // 判断当前不需要打断且当前帧还有时间\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      !(shouldYield() && currentRendererTime > nextFlushedExpirationTime)\n    ) {\n      performWorkOnRoot(\n        nextFlushedRoot,\n        nextFlushedExpirationTime,\n        currentRendererTime > nextFlushedExpirationTime,\n      );\n      findHighestPriorityRoot();\n      recomputeCurrentRendererTime();\n      currentSchedulerTime = currentRendererTime;\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  callbackExpirationTime = NoWork;\n  callbackID = null;\n\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(\n      ((nextFlushedRoot: any): FiberRoot),\n      nextFlushedExpirationTime,\n    );\n  }\n\n  // Clean-up.\n  finishRendering();\n}\n\nfunction performSyncWork() {\n  performWork(Sync);\n}\n\nfunction performWork(minExpirationTime: ExpirationTime) {\n  // Keep working on roots until there's no more work, or until there's a higher\n  // priority event.\n  // 这个函数内部逻辑和 performAsyncWork 差不多\n  // 反正最后都是调用 performWorkOnRoot 函数\n  findHighestPriorityRoot();\n\n  while (\n    nextFlushedRoot !== null &&\n    nextFlushedExpirationTime !== NoWork &&\n    minExpirationTime <= nextFlushedExpirationTime\n  ) {\n    performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n    findHighestPriorityRoot();\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(\n      ((nextFlushedRoot: any): FiberRoot),\n      nextFlushedExpirationTime,\n    );\n  }\n\n  // Clean-up.\n  finishRendering();\n}\n\nfunction flushRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  invariant(\n    !isRendering,\n    'work.commit(): Cannot commit while already rendering. This likely ' +\n      'means you attempted to commit from inside a lifecycle method.',\n  );\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, false);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n  lastCommittedRootDuringThisBatch = null;\n\n  if (__DEV__) {\n    if (rootWithPendingPassiveEffects === null) {\n      nestedPassiveEffectCountDEV = 0;\n    }\n  }\n\n  if (completedBatches !== null) {\n    const batches = completedBatches;\n    completedBatches = null;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    const error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n  isYieldy: boolean,\n) {\n  invariant(\n    !isRendering,\n    'performWorkOnRoot was called recursively. This error is likely caused ' +\n      'by a bug in React. Please file an issue.',\n  );\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (!isYieldy) {\n    // 不可打断任务\n    // Flush work without yielding.\n    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer\n    // may want to perform some work without yielding, but also without\n    // requiring the root to complete (by triggering placeholders).\n    // 判断是否存在已完成的 finishedWork，存在话就完成它\n    let finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      const timeoutHandle = root.timeoutHandle;\n      if (timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(timeoutHandle);\n      }\n      // 否则就去渲染成 DOM\n      renderRoot(root, isYieldy);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // 可打断任务\n    // Flush async work.\n    let finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      const timeoutHandle = root.timeoutHandle;\n      if (timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(timeoutHandle);\n      }\n      renderRoot(root, isYieldy);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Check the if we should yield one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = finishedWork;\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(\n  root: FiberRoot,\n  finishedWork: Fiber,\n  expirationTime: ExpirationTime,\n): void {\n  // Check if there's a batch that matches this expiration time.\n  const firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime >= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.expirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n\n  // Check if this is a nested update (a sync update scheduled during the\n  // commit phase).\n  if (root === lastCommittedRootDuringThisBatch) {\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    lastCommittedRootDuringThisBatch = root;\n    nestedUpdateCount = 0;\n  }\n  commitRoot(root, finishedWork);\n}\n\nfunction onUncaughtError(error: mixed) {\n  invariant(\n    nextFlushedRoot !== null,\n    'Should be working on a root. This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n  );\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.expirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  const previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  if (isBatchingUpdates && !isUnbatchingUpdates) {\n    isUnbatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isUnbatchingUpdates = false;\n    }\n  }\n  return fn(a);\n}\n\n// TODO: Batching should be implemented at the renderer level, not within\n// the reconciler.\nfunction flushSync<A, R>(fn: (a: A) => R, a: A): R {\n  invariant(\n    !isRendering,\n    'flushSync was called from inside a lifecycle method. It cannot be ' +\n      'called when React is already rendering.',\n  );\n  const previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return syncUpdates(fn, a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    performSyncWork();\n  }\n}\n\nfunction interactiveUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b, c);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (\n    !isBatchingUpdates &&\n    !isRendering &&\n    lowestPriorityPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n  const previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  const previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b, c);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates() {\n  if (\n    !isRendering &&\n    lowestPriorityPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\nfunction flushControlled(fn: () => mixed): void {\n  const previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    syncUpdates(fn);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nexport {\n  requestCurrentTime,\n  computeExpirationForFiber,\n  captureCommitPhaseError,\n  onUncaughtError,\n  renderDidSuspend,\n  renderDidError,\n  pingSuspendedRoot,\n  retryTimedOutBoundary,\n  resolveRetryThenable,\n  markLegacyErrorBoundaryAsFailed,\n  isAlreadyFailedLegacyErrorBoundary,\n  scheduleWork,\n  flushRoot,\n  batchedUpdates,\n  unbatchedUpdates,\n  flushSync,\n  flushControlled,\n  deferredUpdates,\n  syncUpdates,\n  interactiveUpdates,\n  flushInteractiveUpdates,\n  computeUniqueAsyncExpiration,\n  flushPassiveEffects,\n  inferStartTimeFromExpirationTime,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/getNodeForCharacterOffset.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberCompleteWork.js",["924","925","926","927","928","929","930","931","932","933","934","935","936","937","938"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {\n  Instance,\n  Type,\n  Props,\n  Container,\n  ChildSet,\n} from './ReactFiberHostConfig';\n\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ContextProvider,\n  ContextConsumer,\n  ForwardRef,\n  Fragment,\n  Mode,\n  Profiler,\n  SuspenseComponent,\n  DehydratedSuspenseComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  EventComponent,\n  EventTarget,\n} from 'shared/ReactWorkTags';\nimport {\n  Placement,\n  Ref,\n  Update,\n  NoEffect,\n  DidCapture,\n  Deletion,\n} from 'shared/ReactSideEffectTags';\nimport invariant from 'shared/invariant';\n\nimport {\n  createInstance,\n  createTextInstance,\n  appendInitialChild,\n  finalizeInitialChildren,\n  prepareUpdate,\n  supportsMutation,\n  supportsPersistence,\n  cloneInstance,\n  cloneHiddenInstance,\n  cloneHiddenTextInstance,\n  createContainerChildSet,\n  appendChildToContainerChildSet,\n  finalizeContainerChildren,\n  handleEventComponent,\n  handleEventTarget,\n} from './ReactFiberHostConfig';\nimport {\n  getRootHostContainer,\n  popHostContext,\n  getHostContext,\n  popHostContainer,\n} from './ReactFiberHostContext';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext';\nimport {popProvider} from './ReactFiberNewContext';\nimport {\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  skipPastDehydratedSuspenseInstance,\n  popHydrationState,\n} from './ReactFiberHydrationContext';\nimport {\n  enableSuspenseServerRenderer,\n  enableEventAPI,\n} from 'shared/ReactFeatureFlags';\n\nfunction markUpdate(workInProgress: Fiber) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef(workInProgress: Fiber) {\n  workInProgress.effectTag |= Ref;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\nif (supportsMutation) {\n  // Mutation mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function(workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    const instance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    const updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext,\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = (updatePayload: any);\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === SuspenseComponent) {\n        if ((node.effectTag & Update) !== NoEffect) {\n          // Need to toggle the visibility of the primary children.\n          const newIsHidden = node.memoizedState !== null;\n          if (newIsHidden) {\n            const primaryChildParent = node.child;\n            if (primaryChildParent !== null) {\n              if (primaryChildParent.child !== null) {\n                primaryChildParent.child.return = primaryChildParent;\n                appendAllChildren(\n                  parent,\n                  primaryChildParent,\n                  true,\n                  newIsHidden,\n                );\n              }\n              const fallbackChildParent = primaryChildParent.sibling;\n              if (fallbackChildParent !== null) {\n                fallbackChildParent.return = node;\n                node = fallbackChildParent;\n                continue;\n              }\n            }\n          }\n        }\n        if (node.child !== null) {\n          // Continue traversing like normal\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  const appendAllChildrenToContainer = function(\n    containerChildSet: ChildSet,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === SuspenseComponent) {\n        if ((node.effectTag & Update) !== NoEffect) {\n          // Need to toggle the visibility of the primary children.\n          const newIsHidden = node.memoizedState !== null;\n          if (newIsHidden) {\n            const primaryChildParent = node.child;\n            if (primaryChildParent !== null) {\n              if (primaryChildParent.child !== null) {\n                primaryChildParent.child.return = primaryChildParent;\n                appendAllChildrenToContainer(\n                  containerChildSet,\n                  primaryChildParent,\n                  true,\n                  newIsHidden,\n                );\n              }\n              const fallbackChildParent = primaryChildParent.sibling;\n              if (fallbackChildParent !== null) {\n                fallbackChildParent.return = node;\n                node = fallbackChildParent;\n                continue;\n              }\n            }\n          }\n        }\n        if (node.child !== null) {\n          // Continue traversing like normal\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      // $FlowFixMe This is correct but Flow is confused by the labeled break.\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(workInProgress: Fiber) {\n    const portalOrRoot: {\n      containerInfo: Container,\n      pendingChildren: ChildSet,\n    } =\n      workInProgress.stateNode;\n    const childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      let newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    const childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    const recyclableInstance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(\n        recyclableInstance,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      );\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    let newInstance = cloneInstance(\n      currentInstance,\n      updatePayload,\n      type,\n      oldProps,\n      newProps,\n      workInProgress,\n      childrenUnchanged,\n      recyclableInstance,\n    );\n    if (\n      finalizeInitialChildren(\n        newInstance,\n        type,\n        newProps,\n        rootContainerInstance,\n        currentHostContext,\n      )\n    ) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress,\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // Noop\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // Noop\n  };\n}\n\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      break;\n    case LazyComponent:\n      break;\n    case SimpleMemoComponent:\n    case FunctionComponent:\n      break;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      const fiberRoot = (workInProgress.stateNode: FiberRoot);\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        popHydrationState(workInProgress);\n        // This resets the hacky state to fix isMounted before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag &= ~Placement;\n      }\n      updateHostContainer(workInProgress);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      const rootContainerInstance = getRootHostContainer();\n      const type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent(\n          current,\n          workInProgress,\n          type,\n          newProps,\n          rootContainerInstance,\n        );\n\n        if (current.ref !== workInProgress.ref) {\n          markRef(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          invariant(\n            workInProgress.stateNode !== null,\n            'We must have new props for new mounts. This error is likely ' +\n              'caused by a bug in React. Please file an issue.',\n          );\n          // This can happen when we abort work.\n          break;\n        }\n\n        const currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on we want to add then top->down or\n        // bottom->up. Top->down is faster in IE11.\n        let wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            // If changes to the hydrated node needs to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          let instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n\n          appendAllChildren(instance, workInProgress, false, false);\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = instance;\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef(workInProgress);\n        }\n      }\n      break;\n    }\n    case HostText: {\n      let newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        const oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== 'string') {\n          invariant(\n            workInProgress.stateNode !== null,\n            'We must have new props for new mounts. This error is likely ' +\n              'caused by a bug in React. Please file an issue.',\n          );\n          // This can happen when we abort work.\n        }\n        const rootContainerInstance = getRootHostContainer();\n        const currentHostContext = getHostContext();\n        let wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n        }\n      }\n      break;\n    }\n    case ForwardRef:\n      break;\n    case SuspenseComponent: {\n      const nextState = workInProgress.memoizedState;\n      if ((workInProgress.effectTag & DidCapture) !== NoEffect) {\n        // Something suspended. Re-render with the fallback children.\n        workInProgress.expirationTime = renderExpirationTime;\n        // Do not reset the effect list.\n        return workInProgress;\n      }\n\n      const nextDidTimeout = nextState !== null;\n      const prevDidTimeout = current !== null && current.memoizedState !== null;\n\n      if (current === null) {\n        // In cases where we didn't find a suitable hydration boundary we never\n        // downgraded this to a DehydratedSuspenseComponent, but we still need to\n        // pop the hydration state since we might be inside the insertion tree.\n        popHydrationState(workInProgress);\n      } else if (!nextDidTimeout && prevDidTimeout) {\n        // We just switched from the fallback to the normal children. Delete\n        // the fallback.\n        // TODO: Would it be better to store the fallback fragment on\n        // the stateNode during the begin phase?\n        const currentFallbackChild: Fiber | null = (current.child: any).sibling;\n        if (currentFallbackChild !== null) {\n          // Deletions go at the beginning of the return fiber's effect list\n          const first = workInProgress.firstEffect;\n          if (first !== null) {\n            workInProgress.firstEffect = currentFallbackChild;\n            currentFallbackChild.nextEffect = first;\n          } else {\n            workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChild;\n            currentFallbackChild.nextEffect = null;\n          }\n          currentFallbackChild.effectTag = Deletion;\n        }\n      }\n\n      if (supportsPersistence) {\n        if (nextDidTimeout) {\n          // If this boundary just timed out, schedule an effect to attach a\n          // retry listener to the proimse. This flag is also used to hide the\n          // primary children.\n          workInProgress.effectTag |= Update;\n        }\n      }\n      if (supportsMutation) {\n        if (nextDidTimeout || prevDidTimeout) {\n          // If this boundary just timed out, schedule an effect to attach a\n          // retry listener to the proimse. This flag is also used to hide the\n          // primary children. In mutation mode, we also need the flag to\n          // *unhide* children that were previously hidden, so check if the\n          // is currently timed out, too.\n          workInProgress.effectTag |= Update;\n        }\n      }\n      break;\n    }\n    case Fragment:\n      break;\n    case Mode:\n      break;\n    case Profiler:\n      break;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n    case ContextConsumer:\n      break;\n    case MemoComponent:\n      break;\n    case IncompleteClassComponent: {\n      // Same as class component case. I put it down here so that the tags are\n      // sequential to ensure this switch is compiled to a jump table.\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      break;\n    }\n    case DehydratedSuspenseComponent: {\n      if (enableSuspenseServerRenderer) {\n        if (current === null) {\n          let wasHydrated = popHydrationState(workInProgress);\n          invariant(\n            wasHydrated,\n            'A dehydrated suspense component was completed without a hydrated node. ' +\n              'This is probably a bug in React.',\n          );\n          skipPastDehydratedSuspenseInstance(workInProgress);\n        } else if ((workInProgress.effectTag & DidCapture) === NoEffect) {\n          // This boundary did not suspend so it's now hydrated.\n          // To handle any future suspense cases, we're going to now upgrade it\n          // to a Suspense component. We detach it from the existing current fiber.\n          current.alternate = null;\n          workInProgress.alternate = null;\n          workInProgress.tag = SuspenseComponent;\n          workInProgress.memoizedState = null;\n          workInProgress.stateNode = null;\n        }\n      }\n      break;\n    }\n    case EventComponent: {\n      if (enableEventAPI) {\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const responder = workInProgress.type.responder;\n        // Update the props on the event component state node\n        workInProgress.stateNode.props = newProps;\n        // Update the root container, so we can properly unmount events at some point\n        workInProgress.stateNode.rootInstance = rootContainerInstance;\n        handleEventComponent(responder, rootContainerInstance);\n      }\n      break;\n    }\n    case EventTarget: {\n      if (enableEventAPI) {\n        popHostContext(workInProgress);\n        const type = workInProgress.type.type;\n        const rootContainerInstance = getRootHostContainer();\n        const shouldUpdate = handleEventTarget(\n          type,\n          newProps,\n          rootContainerInstance,\n          workInProgress,\n        );\n        if (shouldUpdate) {\n          markUpdate(workInProgress);\n        }\n      }\n      break;\n    }\n    default:\n      invariant(\n        false,\n        'Unknown unit of work tag. This error is likely caused by a bug in ' +\n          'React. Please file an issue.',\n      );\n  }\n\n  return null;\n}\n\nexport {completeWork};\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberUnwindWork.js",["939","940","941","942"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {CapturedValue} from './ReactCapturedValue';\nimport type {Update} from './ReactUpdateQueue';\nimport type {Thenable} from './ReactFiberScheduler';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\n\nimport {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';\nimport getComponentName from 'shared/getComponentName';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostPortal,\n  ContextProvider,\n  SuspenseComponent,\n  DehydratedSuspenseComponent,\n  IncompleteClassComponent,\n  EventComponent,\n  EventTarget,\n} from 'shared/ReactWorkTags';\nimport {\n  DidCapture,\n  Incomplete,\n  NoEffect,\n  ShouldCapture,\n  LifecycleEffectMask,\n} from 'shared/ReactSideEffectTags';\nimport {\n  enableSchedulerTracing,\n  enableSuspenseServerRenderer,\n  enableEventAPI,\n} from 'shared/ReactFeatureFlags';\nimport {ConcurrentMode} from './ReactTypeOfMode';\nimport {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';\n\nimport {createCapturedValue} from './ReactCapturedValue';\nimport {\n  enqueueCapturedUpdate,\n  createUpdate,\n  CaptureUpdate,\n  ForceUpdate,\n  enqueueUpdate,\n} from './ReactUpdateQueue';\nimport {logError} from './ReactFiberCommitWork';\nimport {getStackByFiberInDevAndProd} from './ReactCurrentFiber';\nimport {popHostContainer, popHostContext} from './ReactFiberHostContext';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext';\nimport {popProvider} from './ReactFiberNewContext';\nimport {\n  renderDidSuspend,\n  renderDidError,\n  onUncaughtError,\n  markLegacyErrorBoundaryAsFailed,\n  isAlreadyFailedLegacyErrorBoundary,\n  pingSuspendedRoot,\n  resolveRetryThenable,\n  inferStartTimeFromExpirationTime,\n} from './ReactFiberScheduler';\n\nimport invariant from 'shared/invariant';\nimport maxSigned31BitInt from './maxSigned31BitInt';\nimport {Sync, expirationTimeToMs} from './ReactFiberExpirationTime';\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  expirationTime: ExpirationTime,\n): Update<mixed> {\n  const update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element: null};\n  const error = errorInfo.value;\n  update.callback = () => {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  expirationTime: ExpirationTime,\n): Update<mixed> {\n  const update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n    update.payload = () => {\n      return getDerivedStateFromError(error);\n    };\n  }\n\n  const inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : '',\n      });\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          warningWithoutStack(\n            fiber.expirationTime === Sync,\n            '%s: Error boundaries should implement getDerivedStateFromError(). ' +\n              'In that method, return a state update to display an error message or fallback UI.',\n            getComponentName(fiber.type) || 'Unknown',\n          );\n        }\n      }\n    };\n  }\n  return update;\n}\n\nfunction attachPingListener(\n  root: FiberRoot,\n  renderExpirationTime: ExpirationTime,\n  thenable: Thenable,\n) {\n  // Attach a listener to the promise to \"ping\" the root and retry. But\n  // only if one does not already exist for the current render expiration\n  // time (which acts like a \"thread ID\" here).\n  let pingCache = root.pingCache;\n  let threadIDs;\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    threadIDs = new Set();\n    pingCache.set(thenable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(thenable);\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(thenable, threadIDs);\n    }\n  }\n  if (!threadIDs.has(renderExpirationTime)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(renderExpirationTime);\n    let ping = pingSuspendedRoot.bind(\n      null,\n      root,\n      thenable,\n      renderExpirationTime,\n    );\n    if (enableSchedulerTracing) {\n      ping = Schedule_tracing_wrap(ping);\n    }\n    thenable.then(ping, ping);\n  }\n}\n\nfunction throwException(\n  root: FiberRoot,\n  returnFiber: Fiber,\n  sourceFiber: Fiber,\n  value: mixed,\n  renderExpirationTime: ExpirationTime,\n) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.then === 'function'\n  ) {\n    // This is a thenable.\n    const thenable: Thenable = (value: any);\n\n    // Find the earliest timeout threshold of all the placeholders in the\n    // ancestor path. We could avoid this traversal by storing the thresholds on\n    // the stack, but we choose not to because we only hit this path if we're\n    // IO-bound (i.e. if something suspends). Whereas the stack is used even in\n    // the non-IO- bound case.\n    let workInProgress = returnFiber;\n    let earliestTimeoutMs = -1;\n    let startTimeMs = -1;\n    do {\n      if (workInProgress.tag === SuspenseComponent) {\n        const current = workInProgress.alternate;\n        if (current !== null) {\n          const currentState: SuspenseState | null = current.memoizedState;\n          if (currentState !== null) {\n            // Reached a boundary that already timed out. Do not search\n            // any further.\n            const timedOutAt = currentState.timedOutAt;\n            startTimeMs = expirationTimeToMs(timedOutAt);\n            // Do not search any further.\n            break;\n          }\n        }\n        const defaultSuspenseTimeout = 150;\n        if (\n          earliestTimeoutMs === -1 ||\n          defaultSuspenseTimeout < earliestTimeoutMs\n        ) {\n          earliestTimeoutMs = defaultSuspenseTimeout;\n        }\n      }\n      // If there is a DehydratedSuspenseComponent we don't have to do anything because\n      // if something suspends inside it, we will simply leave that as dehydrated. It\n      // will never timeout.\n      workInProgress = workInProgress.return;\n    } while (workInProgress !== null);\n\n    // Schedule the nearest Suspense to re-render the timed out view.\n    workInProgress = returnFiber;\n    do {\n      if (\n        workInProgress.tag === SuspenseComponent &&\n        shouldCaptureSuspense(workInProgress)\n      ) {\n        // Found the nearest boundary.\n\n        // Stash the promise on the boundary fiber. If the boundary times out, we'll\n        // attach another listener to flip the boundary back to its normal state.\n        const thenables: Set<Thenable> = (workInProgress.updateQueue: any);\n        if (thenables === null) {\n          const updateQueue = (new Set(): any);\n          updateQueue.add(thenable);\n          workInProgress.updateQueue = updateQueue;\n        } else {\n          thenables.add(thenable);\n        }\n\n        // If the boundary is outside of concurrent mode, we should *not*\n        // suspend the commit. Pretend as if the suspended component rendered\n        // null and keep rendering. In the commit phase, we'll schedule a\n        // subsequent synchronous update to re-render the Suspense.\n        //\n        // Note: It doesn't matter whether the component that suspended was\n        // inside a concurrent mode tree. If the Suspense is outside of it, we\n        // should *not* suspend the commit.\n        if ((workInProgress.mode & ConcurrentMode) === NoEffect) {\n          workInProgress.effectTag |= DidCapture;\n\n          // We're going to commit this fiber even though it didn't complete.\n          // But we shouldn't call any lifecycle methods or callbacks. Remove\n          // all lifecycle effect tags.\n          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);\n\n          if (sourceFiber.tag === ClassComponent) {\n            const currentSourceFiber = sourceFiber.alternate;\n            if (currentSourceFiber === null) {\n              // This is a new mount. Change the tag so it's not mistaken for a\n              // completed class component. For example, we should not call\n              // componentWillUnmount if it is deleted.\n              sourceFiber.tag = IncompleteClassComponent;\n            } else {\n              // When we try rendering again, we should not reuse the current fiber,\n              // since it's known to be in an inconsistent state. Use a force updte to\n              // prevent a bail out.\n              const update = createUpdate(Sync);\n              update.tag = ForceUpdate;\n              enqueueUpdate(sourceFiber, update);\n            }\n          }\n\n          // The source fiber did not complete. Mark it with Sync priority to\n          // indicate that it still has pending work.\n          sourceFiber.expirationTime = Sync;\n\n          // Exit without suspending.\n          return;\n        }\n\n        // Confirmed that the boundary is in a concurrent mode tree. Continue\n        // with the normal suspend path.\n\n        attachPingListener(root, renderExpirationTime, thenable);\n\n        let absoluteTimeoutMs;\n        if (earliestTimeoutMs === -1) {\n          // If no explicit threshold is given, default to an arbitrarily large\n          // value. The actual size doesn't matter because the threshold for the\n          // whole tree will be clamped to the expiration time.\n          absoluteTimeoutMs = maxSigned31BitInt;\n        } else {\n          if (startTimeMs === -1) {\n            // This suspend happened outside of any already timed-out\n            // placeholders. We don't know exactly when the update was\n            // scheduled, but we can infer an approximate start time based on\n            // the expiration time and the priority.\n            startTimeMs = inferStartTimeFromExpirationTime(\n              root,\n              renderExpirationTime,\n            );\n          }\n          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;\n        }\n\n        // Mark the earliest timeout in the suspended fiber's ancestor path.\n        // After completing the root, we'll take the largest of all the\n        // suspended fiber's timeouts and use it to compute a timeout for the\n        // whole tree.\n        renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);\n\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        return;\n      } else if (\n        enableSuspenseServerRenderer &&\n        workInProgress.tag === DehydratedSuspenseComponent\n      ) {\n        attachPingListener(root, renderExpirationTime, thenable);\n\n        // Since we already have a current fiber, we can eagerly add a retry listener.\n        let retryCache = workInProgress.memoizedState;\n        if (retryCache === null) {\n          retryCache = workInProgress.memoizedState = new PossiblyWeakSet();\n          const current = workInProgress.alternate;\n          invariant(\n            current,\n            'A dehydrated suspense boundary must commit before trying to render. ' +\n              'This is probably a bug in React.',\n          );\n          current.memoizedState = retryCache;\n        }\n        // Memoize using the boundary fiber to prevent redundant listeners.\n        if (!retryCache.has(thenable)) {\n          retryCache.add(thenable);\n          let retry = resolveRetryThenable.bind(null, workInProgress, thenable);\n          if (enableSchedulerTracing) {\n            retry = Schedule_tracing_wrap(retry);\n          }\n          thenable.then(retry, retry);\n        }\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        return;\n      }\n      // This boundary already captured during this render. Continue to the next\n      // boundary.\n      workInProgress = workInProgress.return;\n    } while (workInProgress !== null);\n    // No boundary was found. Fallthrough to error mode.\n    // TODO: Use invariant so the message is stripped in prod?\n    value = new Error(\n      (getComponentName(sourceFiber.type) || 'A React component') +\n        ' suspended while rendering, but no fallback UI was specified.\\n' +\n        '\\n' +\n        'Add a <Suspense fallback=...> component higher in the tree to ' +\n        'provide a loading indicator or placeholder to display.' +\n        getStackByFiberInDevAndProd(sourceFiber),\n    );\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  let workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        const errorInfo = value;\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        const update = createRootErrorUpdate(\n          workInProgress,\n          errorInfo,\n          renderExpirationTime,\n        );\n        enqueueCapturedUpdate(workInProgress, update);\n        return;\n      }\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n        if (\n          (workInProgress.effectTag & DidCapture) === NoEffect &&\n          (typeof ctor.getDerivedStateFromError === 'function' ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === 'function' &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          // Schedule the error boundary to re-render using updated state\n          const update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            renderExpirationTime,\n          );\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  switch (workInProgress.tag) {\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      const effectTag = workInProgress.effectTag;\n      if (effectTag & ShouldCapture) {\n        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      const effectTag = workInProgress.effectTag;\n      invariant(\n        (effectTag & DidCapture) === NoEffect,\n        'The root failed to unmount after an error. This is likely a bug in ' +\n          'React. Please file an issue.',\n      );\n      workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n      return workInProgress;\n    }\n    case HostComponent: {\n      // TODO: popHydrationState\n      popHostContext(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: {\n      const effectTag = workInProgress.effectTag;\n      if (effectTag & ShouldCapture) {\n        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n        // Captured a suspense effect. Re-render the boundary.\n        return workInProgress;\n      }\n      return null;\n    }\n    case DehydratedSuspenseComponent: {\n      if (enableSuspenseServerRenderer) {\n        // TODO: popHydrationState\n        const effectTag = workInProgress.effectTag;\n        if (effectTag & ShouldCapture) {\n          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n          // Captured a suspense effect. Re-render the boundary.\n          return workInProgress;\n        }\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    case EventComponent:\n    case EventTarget:\n      if (enableEventAPI) {\n        popHostContext(workInProgress);\n      }\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork: Fiber) {\n  switch (interruptedWork.tag) {\n    case ClassComponent: {\n      const childContextTypes = interruptedWork.type.childContextTypes;\n      if (childContextTypes !== null && childContextTypes !== undefined) {\n        popLegacyContext(interruptedWork);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(interruptedWork);\n      popTopLevelLegacyContextObject(interruptedWork);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(interruptedWork);\n      break;\n    }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nexport {\n  throwException,\n  unwindWork,\n  unwindInterruptedWork,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberCommitWork.js",["943","944","945","946","947","948","949"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Instance,\n  TextInstance,\n  SuspenseInstance,\n  Container,\n  ChildSet,\n  UpdatePayload,\n} from './ReactFiberHostConfig';\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {CapturedValue, CapturedError} from './ReactCapturedValue';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks';\nimport type {Thenable} from './ReactFiberScheduler';\n\nimport {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';\nimport {\n  enableSchedulerTracing,\n  enableProfilerTimer,\n  enableSuspenseServerRenderer,\n  enableEventAPI,\n} from 'shared/ReactFeatureFlags';\nimport {\n  FunctionComponent,\n  ForwardRef,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  Profiler,\n  SuspenseComponent,\n  DehydratedSuspenseComponent,\n  IncompleteClassComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  EventComponent,\n  EventTarget,\n} from 'shared/ReactWorkTags';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {\n  ContentReset,\n  Placement,\n  Snapshot,\n  Update,\n} from 'shared/ReactSideEffectTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport warning from 'shared/warning';\n\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {onCommitUnmount} from './ReactFiberDevToolsHook';\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {getStackByFiberInDevAndProd} from './ReactCurrentFiber';\nimport {logCapturedError} from './ReactFiberErrorLogger';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {getCommitTime} from './ReactProfilerTimer';\nimport {commitUpdateQueue} from './ReactUpdateQueue';\nimport {\n  getPublicInstance,\n  supportsMutation,\n  supportsPersistence,\n  commitMount,\n  commitUpdate,\n  resetTextContent,\n  commitTextUpdate,\n  appendChild,\n  appendChildToContainer,\n  insertBefore,\n  insertInContainerBefore,\n  removeChild,\n  removeChildFromContainer,\n  clearSuspenseBoundary,\n  clearSuspenseBoundaryFromContainer,\n  replaceContainerChildren,\n  createContainerChildSet,\n  hideInstance,\n  hideTextInstance,\n  unhideInstance,\n  unhideTextInstance,\n  unmountEventComponent,\n  commitEventTarget,\n} from './ReactFiberHostConfig';\nimport {\n  captureCommitPhaseError,\n  requestCurrentTime,\n  resolveRetryThenable,\n} from './ReactFiberScheduler';\nimport {\n  NoEffect as NoHookEffect,\n  UnmountSnapshot,\n  UnmountMutation,\n  MountMutation,\n  UnmountLayout,\n  MountLayout,\n  UnmountPassive,\n  MountPassive,\n} from './ReactHookEffectTags';\nimport {didWarnAboutReassigningProps} from './ReactFiberBeginWork';\n\nlet didWarnAboutUndefinedSnapshotBeforeUpdate: Set<mixed> | null = null;\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n\nexport function logError(boundary: Fiber, errorInfo: CapturedValue<mixed>) {\n  const source = errorInfo.source;\n  let stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  const capturedError: CapturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false,\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function(current, instance) {\n  startPhaseTimer(current, 'componentWillUnmount');\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current, instance) {\n  if (__DEV__) {\n    invokeGuardedCallback(\n      null,\n      callComponentWillUnmountWithTimer,\n      null,\n      current,\n      instance,\n    );\n    if (hasCaughtError()) {\n      const unmountError = clearCaughtError();\n      captureCommitPhaseError(current, unmountError);\n    }\n  } else {\n    try {\n      callComponentWillUnmountWithTimer(current, instance);\n    } catch (unmountError) {\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current: Fiber) {\n  const ref = current.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      if (__DEV__) {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          const refError = clearCaughtError();\n          captureCommitPhaseError(current, refError);\n        }\n      } else {\n        try {\n          ref(null);\n        } catch (refError) {\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, destroy) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, destroy, null);\n    if (hasCaughtError()) {\n      const error = clearCaughtError();\n      captureCommitPhaseError(current, error);\n    }\n  } else {\n    try {\n      destroy();\n    } catch (error) {\n      captureCommitPhaseError(current, error);\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(\n  current: Fiber | null,\n  finishedWork: Fiber,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      commitHookEffectList(UnmountSnapshot, NoHookEffect, finishedWork);\n      return;\n    }\n    case ClassComponent: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current !== null) {\n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n          const instance = finishedWork.stateNode;\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              warning(\n                instance.props === finishedWork.memoizedProps,\n                'Expected %s props to match memoized props before ' +\n                  'getSnapshotBeforeUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n              warning(\n                instance.state === finishedWork.memoizedState,\n                'Expected %s state to match memoized state before ' +\n                  'getSnapshotBeforeUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          if (__DEV__) {\n            const didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<\n              mixed,\n            >);\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              warningWithoutStack(\n                false,\n                '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' +\n                  'must be returned. You have returned undefined.',\n                getComponentName(finishedWork.type),\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          stopPhaseTimer();\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n    case EventTarget:\n      // Nothing to do for these component types\n      return;\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction commitHookEffectList(\n  unmountTag: number,\n  mountTag: number,\n  finishedWork: Fiber,\n) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & unmountTag) !== NoHookEffect) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      if ((effect.tag & mountTag) !== NoHookEffect) {\n        // Mount\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let addendum;\n            if (destroy === null) {\n              addendum =\n                ' You returned null. If your effect does not require clean ' +\n                'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum =\n                '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' +\n                'Instead, write the async function inside your effect ' +\n                'and call it immediately:\\n\\n' +\n                'useEffect(() => {\\n' +\n                '  async function fetchData() {\\n' +\n                '    // You can await here\\n' +\n                '    const response = await MyAPI.getData(someId);\\n' +\n                '    // ...\\n' +\n                '  }\\n' +\n                '  fetchData();\\n' +\n                `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\n                'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n            warningWithoutStack(\n              false,\n              'An effect function must not return anything besides a function, ' +\n                'which is used for clean-up.%s%s',\n              addendum,\n              getStackByFiberInDevAndProd(finishedWork),\n            );\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nexport function commitPassiveHookEffects(finishedWork: Fiber): void {\n  commitHookEffectList(UnmountPassive, NoHookEffect, finishedWork);\n  commitHookEffectList(NoHookEffect, MountPassive, finishedWork);\n}\n\nfunction commitLifeCycles(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedExpirationTime: ExpirationTime,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      commitHookEffectList(UnmountLayout, MountLayout, finishedWork);\n      break;\n    }\n    case ClassComponent: {\n      const instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        if (current === null) {\n          startPhaseTimer(finishedWork, 'componentDidMount');\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              warning(\n                instance.props === finishedWork.memoizedProps,\n                'Expected %s props to match memoized props before ' +\n                  'componentDidMount. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n              warning(\n                instance.state === finishedWork.memoizedState,\n                'Expected %s state to match memoized state before ' +\n                  'componentDidMount. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n          instance.componentDidMount();\n          stopPhaseTimer();\n        } else {\n          const prevProps =\n            finishedWork.elementType === finishedWork.type\n              ? current.memoizedProps\n              : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n          const prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, 'componentDidUpdate');\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              warning(\n                instance.props === finishedWork.memoizedProps,\n                'Expected %s props to match memoized props before ' +\n                  'componentDidUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n              warning(\n                instance.state === finishedWork.memoizedState,\n                'Expected %s state to match memoized state before ' +\n                  'componentDidUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate,\n          );\n          stopPhaseTimer();\n        }\n      }\n      const updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        if (__DEV__) {\n          if (\n            finishedWork.type === finishedWork.elementType &&\n            !didWarnAboutReassigningProps\n          ) {\n            warning(\n              instance.props === finishedWork.memoizedProps,\n              'Expected %s props to match memoized props before ' +\n                'processing the update queue. ' +\n                'This might either be because of a bug in React, or because ' +\n                'a component reassigns its own `this.props`. ' +\n                'Please file an issue.',\n              getComponentName(finishedWork.type) || 'instance',\n            );\n            warning(\n              instance.state === finishedWork.memoizedState,\n              'Expected %s state to match memoized state before ' +\n                'processing the update queue. ' +\n                'This might either be because of a bug in React, or because ' +\n                'a component reassigns its own `this.props`. ' +\n                'Please file an issue.',\n              getComponentName(finishedWork.type) || 'instance',\n            );\n          }\n        }\n        // We could update instance props and state here,\n        // but instead we rely on them being set during last render.\n        // TODO: revisit this when we implement resuming.\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime,\n        );\n      }\n      return;\n    }\n    case HostRoot: {\n      const updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        let instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n              instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime,\n        );\n      }\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current === null && finishedWork.effectTag & Update) {\n        const type = finishedWork.type;\n        const props = finishedWork.memoizedProps;\n        commitMount(instance, type, props, finishedWork);\n      }\n\n      return;\n    }\n    case HostText: {\n      // We have no life-cycles associated with text.\n      return;\n    }\n    case HostPortal: {\n      // We have no life-cycles associated with portals.\n      return;\n    }\n    case Profiler: {\n      if (enableProfilerTimer) {\n        const onRender = finishedWork.memoizedProps.onRender;\n\n        if (enableSchedulerTracing) {\n          onRender(\n            finishedWork.memoizedProps.id,\n            current === null ? 'mount' : 'update',\n            finishedWork.actualDuration,\n            finishedWork.treeBaseDuration,\n            finishedWork.actualStartTime,\n            getCommitTime(),\n            finishedRoot.memoizedInteractions,\n          );\n        } else {\n          onRender(\n            finishedWork.memoizedProps.id,\n            current === null ? 'mount' : 'update',\n            finishedWork.actualDuration,\n            finishedWork.treeBaseDuration,\n            finishedWork.actualStartTime,\n            getCommitTime(),\n          );\n        }\n      }\n      return;\n    }\n    case SuspenseComponent:\n    case IncompleteClassComponent:\n    case EventTarget:\n      break;\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent) {\n        const instance = node.stateNode;\n        if (isHidden) {\n          hideInstance(instance);\n        } else {\n          unhideInstance(node.stateNode, node.memoizedProps);\n        }\n      } else if (node.tag === HostText) {\n        const instance = node.stateNode;\n        if (isHidden) {\n          hideTextInstance(instance);\n        } else {\n          unhideTextInstance(instance, node.memoizedProps);\n        }\n      } else if (\n        node.tag === SuspenseComponent &&\n        node.memoizedState !== null\n      ) {\n        // Found a nested Suspense component that timed out. Skip over the\n        // primary child fragment, which should remain hidden.\n        const fallbackChildFragment: Fiber = (node.child: any).sibling;\n        fallbackChildFragment.return = node;\n        node = fallbackChildFragment;\n        continue;\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          warningWithoutStack(\n            false,\n            'Unexpected ref object provided for %s. ' +\n              'Use either a ref-setter function or React.createRef().%s',\n            getComponentName(finishedWork.type),\n            getStackByFiberInDevAndProd(finishedWork),\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current: Fiber) {\n  const currentRef = current.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current: Fiber): void {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n          let effect = firstEffect;\n          do {\n            const destroy = effect.destroy;\n            if (destroy !== undefined) {\n              safelyCallDestroy(current, destroy);\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      break;\n    }\n    case ClassComponent: {\n      safelyDetachRef(current);\n      const instance = current.stateNode;\n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(current, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      safelyDetachRef(current);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(current);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current);\n      }\n      return;\n    }\n    case EventComponent: {\n      if (enableEventAPI) {\n        const rootContainerInstance = current.stateNode.rootInstance;\n        const responder = current.type.responder;\n        unmountEventComponent(responder, rootContainerInstance, current);\n        current.stateNode = null;\n      }\n    }\n  }\n}\n\nfunction commitNestedUnmounts(root: Fiber): void {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node: Fiber = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current: Fiber) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current.return = null;\n  current.child = null;\n  current.memoizedState = null;\n  current.updateQueue = null;\n  const alternate = current.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n    alternate.child = null;\n    alternate.memoizedState = null;\n    alternate.updateQueue = null;\n  }\n}\n\nfunction emptyPortalContainer(current: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal: {containerInfo: Container, pendingChildren: ChildSet} =\n    current.stateNode;\n  const {containerInfo} = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n    case EventTarget: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      const portalOrRoot: {\n        containerInfo: Container,\n        pendingChildren: ChildSet,\n      } =\n        finishedWork.stateNode;\n      const {containerInfo, pendingChildren} = portalOrRoot;\n      replaceContainerChildren(containerInfo, pendingChildren);\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction getHostParentFiber(fiber: Fiber): Fiber {\n  let parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(\n    false,\n    'Expected to find a host parent. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n}\n\nfunction isHostParent(fiber: Fiber): boolean {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber: Fiber): ?Instance {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node: Fiber = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (\n      node.tag !== HostComponent &&\n      node.tag !== HostText &&\n      node.tag !== DehydratedSuspenseComponent\n    ) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  let parent;\n  let isContainer;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(\n        false,\n        'Invalid host parent fiber. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent);\n    // Clear ContentReset from the effect tag\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  const before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node: Fiber = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      const stateNode = node.stateNode;\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, stateNode, before);\n        } else {\n          insertBefore(parent, stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, stateNode);\n        } else {\n          appendChild(parent, stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current): void {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node: Fiber = current;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  let currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n      findParent: while (true) {\n        invariant(\n          parent !== null,\n          'Expected to find a host parent. This error is likely caused by ' +\n            'a bug in React. Please file an issue.',\n        );\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: Instance | TextInstance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (node.stateNode: Instance | TextInstance),\n        );\n      }\n      // Don't visit children because we already visited them.\n    } else if (\n      enableSuspenseServerRenderer &&\n      node.tag === DehydratedSuspenseComponent\n    ) {\n      // Delete the dehydrated suspense boundary and all of its content.\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: SuspenseInstance),\n        );\n      } else {\n        clearSuspenseBoundary(\n          ((currentParent: any): Instance),\n          (node.stateNode: SuspenseInstance),\n        );\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true;\n        // Visit children because portals might contain host components.\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current: Fiber): void {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current);\n  }\n  detachFiber(current);\n}\n\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent: {\n        // Note: We currently never use MountMutation, but useLayout uses\n        // UnmountMutation.\n        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n        return;\n      }\n      case Profiler: {\n        return;\n      }\n      case SuspenseComponent: {\n        commitSuspenseComponent(finishedWork);\n        return;\n      }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      // Note: We currently never use MountMutation, but useLayout uses\n      // UnmountMutation.\n      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n      return;\n    }\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        'This should have a text node initialized. This error is likely ' +\n          'caused by a bug in React. Please file an issue.',\n      );\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case EventTarget: {\n      if (enableEventAPI) {\n        const type = finishedWork.type.type;\n        const props = finishedWork.memoizedProps;\n        const instance = finishedWork.stateNode;\n        let parentInstance = null;\n\n        let node = finishedWork.return;\n        // Traverse up the fiber tree until we find the parent host node.\n        while (node !== null) {\n          if (node.tag === HostComponent) {\n            parentInstance = node.stateNode;\n            break;\n          } else if (node.tag === HostRoot) {\n            parentInstance = node.stateNode.containerInfo;\n            break;\n          }\n          node = node.return;\n        }\n        invariant(\n          parentInstance !== null,\n          'This should have a parent host component initialized. This error is likely ' +\n            'caused by a bug in React. Please file an issue.',\n        );\n        commitEventTarget(type, props, instance, parentInstance);\n      }\n      return;\n    }\n    case HostRoot: {\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case SuspenseComponent: {\n      commitSuspenseComponent(finishedWork);\n      return;\n    }\n    case IncompleteClassComponent: {\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction commitSuspenseComponent(finishedWork: Fiber) {\n  let newState: SuspenseState | null = finishedWork.memoizedState;\n\n  let newDidTimeout;\n  let primaryChildParent = finishedWork;\n  if (newState === null) {\n    newDidTimeout = false;\n  } else {\n    newDidTimeout = true;\n    primaryChildParent = finishedWork.child;\n    if (newState.timedOutAt === NoWork) {\n      // If the children had not already timed out, record the time.\n      // This is used to compute the elapsed time during subsequent\n      // attempts to render the children.\n      newState.timedOutAt = requestCurrentTime();\n    }\n  }\n\n  if (supportsMutation && primaryChildParent !== null) {\n    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);\n  }\n\n  // If this boundary just timed out, then it will have a set of thenables.\n  // For each thenable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const thenables: Set<Thenable> | null = (finishedWork.updateQueue: any);\n  if (thenables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n    thenables.forEach(thenable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      let retry = resolveRetryThenable.bind(null, finishedWork, thenable);\n      if (enableSchedulerTracing) {\n        retry = Schedule_tracing_wrap(retry);\n      }\n      if (!retryCache.has(thenable)) {\n        retryCache.add(thenable);\n        thenable.then(retry, retry);\n      }\n    });\n  }\n}\n\nfunction commitResetTextContent(current: Fiber) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current.stateNode);\n}\n\nexport {\n  commitBeforeMutationLifeCycles,\n  commitResetTextContent,\n  commitPlacement,\n  commitDeletion,\n  commitWork,\n  commitLifeCycles,\n  commitAttachRef,\n  commitDetachRef,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactCapturedValue.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactProfilerTimer.js",["950"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\n\nimport {enableProfilerTimer} from 'shared/ReactFeatureFlags';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\n\nconst {unstable_now: now} = Scheduler;\n\nexport type ProfilerTimer = {\n  getCommitTime(): number,\n  recordCommitTime(): void,\n  startProfilerTimer(fiber: Fiber): void,\n  stopProfilerTimerIfRunning(fiber: Fiber): void,\n  stopProfilerTimerIfRunningAndRecordDelta(fiber: Fiber): void,\n};\n\nlet commitTime: number = 0;\nlet profilerStartTime: number = -1;\n\nfunction getCommitTime(): number {\n  return commitTime;\n}\n\nfunction recordCommitTime(): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = now();\n}\n\nfunction startProfilerTimer(fiber: Fiber): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = now();\n\n  if (((fiber.actualStartTime: any): number) < 0) {\n    fiber.actualStartTime = now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber: Fiber): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(\n  fiber: Fiber,\n  overrideBaseTime: boolean,\n): void {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    const elapsedTime = now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n    profilerStartTime = -1;\n  }\n}\n\nexport {\n  getCommitTime,\n  recordCommitTime,\n  startProfilerTimer,\n  stopProfilerTimerIfRunning,\n  stopProfilerTimerIfRunningAndRecordDelta,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactStrictModeWarnings.js",["951","952","953","954","955","956"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\n\nimport {getStackByFiberInDevAndProd} from './ReactCurrentFiber';\n\nimport getComponentName from 'shared/getComponentName';\nimport {StrictMode} from './ReactTypeOfMode';\nimport lowPriorityWarning from 'shared/lowPriorityWarning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\ntype LIFECYCLE =\n  | 'UNSAFE_componentWillMount'\n  | 'UNSAFE_componentWillReceiveProps'\n  | 'UNSAFE_componentWillUpdate';\ntype LifecycleToComponentsMap = {[lifecycle: LIFECYCLE]: Array<Fiber>};\ntype FiberToLifecycleMap = Map<Fiber, LifecycleToComponentsMap>;\ntype FiberArray = Array<Fiber>;\ntype FiberToFiberComponentsMap = Map<Fiber, FiberArray>;\n\nconst ReactStrictModeWarnings = {\n  discardPendingWarnings(): void {},\n  flushPendingDeprecationWarnings(): void {},\n  flushPendingUnsafeLifecycleWarnings(): void {},\n  recordDeprecationWarnings(fiber: Fiber, instance: any): void {},\n  recordUnsafeLifecycleWarnings(fiber: Fiber, instance: any): void {},\n  recordLegacyContextWarning(fiber: Fiber, instance: any): void {},\n  flushLegacyContextWarning(): void {},\n};\n\nif (__DEV__) {\n  const LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: 'componentDidMount',\n    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',\n    UNSAFE_componentWillUpdate: 'componentDidUpdate',\n  };\n\n  let pendingComponentWillMountWarnings: Array<Fiber> = [];\n  let pendingComponentWillReceivePropsWarnings: Array<Fiber> = [];\n  let pendingComponentWillUpdateWarnings: Array<Fiber> = [];\n  let pendingUnsafeLifecycleWarnings: FiberToLifecycleMap = new Map();\n  let pendingLegacyContextWarning: FiberToFiberComponentsMap = new Map();\n\n  // Tracks components we have already warned about.\n  const didWarnAboutDeprecatedLifecycles = new Set();\n  const didWarnAboutUnsafeLifecycles = new Set();\n  const didWarnAboutLegacyContext = new Set();\n\n  const setToSortedString = set => {\n    const array = [];\n    set.forEach(value => {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = () => {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = () => {\n    ((pendingUnsafeLifecycleWarnings: any): FiberToLifecycleMap).forEach(\n      (lifecycleWarningsMap, strictRoot) => {\n        const lifecyclesWarningMessages = [];\n\n        Object.keys(lifecycleWarningsMap).forEach(lifecycle => {\n          const lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n          if (lifecycleWarnings.length > 0) {\n            const componentNames = new Set();\n            lifecycleWarnings.forEach(fiber => {\n              componentNames.add(getComponentName(fiber.type) || 'Component');\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n\n            const formatted = lifecycle.replace('UNSAFE_', '');\n            const suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n            const sortedComponentNames = setToSortedString(componentNames);\n\n            lifecyclesWarningMessages.push(\n              `${formatted}: Please update the following components to use ` +\n                `${suggestion} instead: ${sortedComponentNames}`,\n            );\n          }\n        });\n\n        if (lifecyclesWarningMessages.length > 0) {\n          const strictRootComponentStack = getStackByFiberInDevAndProd(\n            strictRoot,\n          );\n\n          warningWithoutStack(\n            false,\n            'Unsafe lifecycle methods were found within a strict-mode tree:%s' +\n              '\\n\\n%s' +\n              '\\n\\nLearn more about this warning here:' +\n              '\\nhttps://fb.me/react-strict-mode-warnings',\n            strictRootComponentStack,\n            lifecyclesWarningMessages.join('\\n\\n'),\n          );\n        }\n      },\n    );\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  const findStrictRoot = (fiber: Fiber): Fiber | null => {\n    let maybeStrictRoot = null;\n\n    let node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = () => {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      const uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(fiber => {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      const sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning(\n        false,\n        'componentWillMount is deprecated and will be removed in the next major version. ' +\n          'Use componentDidMount instead. As a temporary workaround, ' +\n          'you can rename to UNSAFE_componentWillMount.' +\n          '\\n\\nPlease update the following components: %s' +\n          '\\n\\nLearn more about this warning here:' +\n          '\\nhttps://fb.me/react-async-component-lifecycle-hooks',\n        sortedNames,\n      );\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      const uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(fiber => {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      const sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning(\n        false,\n        'componentWillReceiveProps is deprecated and will be removed in the next major version. ' +\n          'Use static getDerivedStateFromProps instead.' +\n          '\\n\\nPlease update the following components: %s' +\n          '\\n\\nLearn more about this warning here:' +\n          '\\nhttps://fb.me/react-async-component-lifecycle-hooks',\n        sortedNames,\n      );\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      const uniqueNames = new Set();\n      pendingComponentWillUpdateWarnings.forEach(fiber => {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      const sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning(\n        false,\n        'componentWillUpdate is deprecated and will be removed in the next major version. ' +\n          'Use componentDidUpdate instead. As a temporary workaround, ' +\n          'you can rename to UNSAFE_componentWillUpdate.' +\n          '\\n\\nPlease update the following components: %s' +\n          '\\n\\nLearn more about this warning here:' +\n          '\\nhttps://fb.me/react-async-component-lifecycle-hooks',\n        sortedNames,\n      );\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = (\n    fiber: Fiber,\n    instance: any,\n  ) => {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (\n      typeof instance.componentWillMount === 'function' &&\n      instance.componentWillMount.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillReceiveProps === 'function' &&\n      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillUpdate === 'function' &&\n      instance.componentWillUpdate.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = (\n    fiber: Fiber,\n    instance: any,\n  ) => {\n    const strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack(\n        false,\n        'Expected to find a StrictMode component in a strict mode tree. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    let warningsForRoot;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: [],\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    const unsafeLifecycles = [];\n    if (\n      (typeof instance.componentWillMount === 'function' &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillMount === 'function'\n    ) {\n      unsafeLifecycles.push('UNSAFE_componentWillMount');\n    }\n    if (\n      (typeof instance.componentWillReceiveProps === 'function' &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !==\n          true) ||\n      typeof instance.UNSAFE_componentWillReceiveProps === 'function'\n    ) {\n      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');\n    }\n    if (\n      (typeof instance.componentWillUpdate === 'function' &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillUpdate === 'function'\n    ) {\n      unsafeLifecycles.push('UNSAFE_componentWillUpdate');\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(lifecycle => {\n        ((warningsForRoot: any): LifecycleToComponentsMap)[lifecycle].push(\n          fiber,\n        );\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = (\n    fiber: Fiber,\n    instance: any,\n  ) => {\n    const strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack(\n        false,\n        'Expected to find a StrictMode component in a strict mode tree. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    let warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (\n      fiber.type.contextTypes != null ||\n      fiber.type.childContextTypes != null ||\n      (instance !== null && typeof instance.getChildContext === 'function')\n    ) {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = () => {\n    ((pendingLegacyContextWarning: any): FiberToFiberComponentsMap).forEach(\n      (fiberArray: FiberArray, strictRoot) => {\n        const uniqueNames = new Set();\n        fiberArray.forEach(fiber => {\n          uniqueNames.add(getComponentName(fiber.type) || 'Component');\n          didWarnAboutLegacyContext.add(fiber.type);\n        });\n\n        const sortedNames = setToSortedString(uniqueNames);\n        const strictRootComponentStack = getStackByFiberInDevAndProd(\n          strictRoot,\n        );\n\n        warningWithoutStack(\n          false,\n          'Legacy context API has been detected within a strict-mode tree: %s' +\n            '\\n\\nPlease update the following components: %s' +\n            '\\n\\nLearn more about this warning here:' +\n            '\\nhttps://fb.me/react-strict-mode-warnings',\n          strictRootComponentStack,\n          sortedNames,\n        );\n      },\n    );\n  };\n}\n\nexport default ReactStrictModeWarnings;\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHooks.js",["957","958","959","960","961","962","963","964","965","966","967","968","969","970","971","972","973","974","975","976","977","978","979","980","981","982","983","984","985","986","987","988","989","990","991","992","993","994","995","996","997","998","999","1000"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactContext} from 'shared/ReactTypes';\nimport type {SideEffectTag} from 'shared/ReactSideEffectTags';\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {HookEffectTag} from './ReactHookEffectTags';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {readContext} from './ReactFiberNewContext';\nimport {\n  Update as UpdateEffect,\n  Passive as PassiveEffect,\n} from 'shared/ReactSideEffectTags';\nimport {\n  NoEffect as NoHookEffect,\n  UnmountMutation,\n  MountLayout,\n  UnmountPassive,\n  MountPassive,\n} from './ReactHookEffectTags';\nimport {\n  scheduleWork,\n  computeExpirationForFiber,\n  flushPassiveEffects,\n  requestCurrentTime,\n  warnIfNotCurrentlyActingUpdatesInDev,\n} from './ReactFiberScheduler';\n\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport getComponentName from 'shared/getComponentName';\nimport is from 'shared/objectIs';\nimport {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';\n\nconst {ReactCurrentDispatcher} = ReactSharedInternals;\n\nexport type Dispatcher = {\n  readContext<T>(\n    context: ReactContext<T>,\n    observedBits: void | number | boolean,\n  ): T,\n  useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],\n  useReducer<S, I, A>(\n    reducer: (S, A) => S,\n    initialArg: I,\n    init?: (I) => S,\n  ): [S, Dispatch<A>],\n  useContext<T>(\n    context: ReactContext<T>,\n    observedBits: void | number | boolean,\n  ): T,\n  useRef<T>(initialValue: T): {current: T},\n  useEffect(\n    create: () => (() => void) | void,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useLayoutEffect(\n    create: () => (() => void) | void,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useCallback<T>(callback: T, deps: Array<mixed> | void | null): T,\n  useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T,\n  useImperativeHandle<T>(\n    ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n    create: () => T,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,\n};\n\ntype Update<S, A> = {\n  expirationTime: ExpirationTime,\n  action: A,\n  eagerReducer: ((S, A) => S) | null,\n  eagerState: S | null,\n  next: Update<S, A> | null,\n};\n\ntype UpdateQueue<S, A> = {\n  last: Update<S, A> | null,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n};\n\nexport type HookType =\n  | 'useState'\n  | 'useReducer'\n  | 'useContext'\n  | 'useRef'\n  | 'useEffect'\n  | 'useLayoutEffect'\n  | 'useCallback'\n  | 'useMemo'\n  | 'useImperativeHandle'\n  | 'useDebugValue';\n\nlet didWarnAboutMismatchedHooksForComponent;\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\nexport type Hook = {\n  memoizedState: any,\n\n  baseState: any,\n  baseUpdate: Update<any, any> | null,\n  queue: UpdateQueue<any, any> | null,\n\n  next: Hook | null,\n};\n\ntype Effect = {\n  tag: HookEffectTag,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | null,\n  next: Effect,\n};\n\nexport type FunctionComponentUpdateQueue = {\n  lastEffect: Effect | null,\n};\n\ntype BasicStateAction<S> = (S => S) | S;\n\ntype Dispatch<A> = A => void;\n\n// These are set right before calling the component.\nlet renderExpirationTime: ExpirationTime = NoWork;\n// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nlet currentlyRenderingFiber: Fiber | null = null;\n\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet currentHook: Hook | null = null;\nlet nextCurrentHook: Hook | null = null;\nlet firstWorkInProgressHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\nlet nextWorkInProgressHook: Hook | null = null;\n\nlet remainingExpirationTime: ExpirationTime = NoWork;\nlet componentUpdateQueue: FunctionComponentUpdateQueue | null = null;\nlet sideEffectTag: SideEffectTag = 0;\n\n// Updates scheduled during render will trigger an immediate re-render at the\n// end of the current pass. We can't store these updates on the normal queue,\n// because if the work is aborted, they should be discarded. Because this is\n// a relatively rare case, we also don't want to add an additional field to\n// either the hook or queue object types. So we store them in a lazily create\n// map of queue -> render-phase updates, which are discarded once the component\n// completes without re-rendering.\n\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false;\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<\n  UpdateQueue<any, any>,\n  Update<any, any>,\n> | null = null;\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0;\nconst RE_RENDER_LIMIT = 25;\n\n// In DEV, this is the name of the currently executing primitive hook\nlet currentHookNameInDev: ?HookType = null;\n\n// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nlet hookTypesDev: Array<HookType> | null = null;\nlet hookTypesUpdateIndexDev: number = -1;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps: mixed) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      warning(\n        false,\n        '%s received a final argument that is not an array (instead, received `%s`). When ' +\n          'specified, the final argument must be an array.',\n        currentHookNameInDev,\n        typeof deps,\n      );\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName: HookType) {\n  if (__DEV__) {\n    const componentName = getComponentName(\n      ((currentlyRenderingFiber: any): Fiber).type,\n    );\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= ((hookTypesUpdateIndexDev: any): number); i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName =\n            i === ((hookTypesUpdateIndexDev: any): number)\n              ? currentHookName\n              : oldHookName;\n\n          let row = `${i + 1}. ${oldHookName}`;\n\n          // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n\n          table += row;\n        }\n\n        warning(\n          false,\n          'React has detected a change in the order of Hooks called by %s. ' +\n            'This will lead to bugs and errors if not fixed. ' +\n            'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\\n\\n' +\n            '   Previous render            Next render\\n' +\n            '   ------------------------------------------------------\\n' +\n            '%s' +\n            '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',\n          componentName,\n          table,\n        );\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  invariant(\n    false,\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n      ' one of the following reasons:\\n' +\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n      '2. You might be breaking the Rules of Hooks\\n' +\n      '3. You might have more than one copy of React in the same app\\n' +\n      'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',\n  );\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (prevDeps === null) {\n    if (__DEV__) {\n      warning(\n        false,\n        '%s received a final argument during this render, but not during ' +\n          'the previous render. Even though the final argument is optional, ' +\n          'its type cannot change between renders.',\n        currentHookNameInDev,\n      );\n    }\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      warning(\n        false,\n        'The final argument passed to %s changed size between renders. The ' +\n          'order and size of this array must remain constant.\\n\\n' +\n          'Previous: %s\\n' +\n          'Incoming: %s',\n        currentHookNameInDev,\n        `[${nextDeps.join(', ')}]`,\n        `[${prevDeps.join(', ')}]`,\n      );\n    }\n  }\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function renderWithHooks(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  props: any,\n  refOrContext: any,\n  nextRenderExpirationTime: ExpirationTime,\n): any {\n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress;\n  nextCurrentHook = current !== null ? current.memoizedState : null;\n\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n\n  // remainingExpirationTime = NoWork;\n  // componentUpdateQueue = null;\n\n  // didScheduleRenderPhaseUpdate = false;\n  // renderPhaseUpdates = null;\n  // numberOfReRenders = 0;\n  // sideEffectTag = 0;\n\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because nextCurrentHook === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\n  // Using nextCurrentHook to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so nextCurrentHook would be null during updates and mounts.\n  if (__DEV__) {\n    if (nextCurrentHook !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current =\n      nextCurrentHook === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, refOrContext);\n\n  if (didScheduleRenderPhaseUpdate) {\n    do {\n      didScheduleRenderPhaseUpdate = false;\n      numberOfReRenders += 1;\n\n      // Start over from the beginning of the list\n      nextCurrentHook = current !== null ? current.memoizedState : null;\n      nextWorkInProgressHook = firstWorkInProgressHook;\n\n      currentHook = null;\n      workInProgressHook = null;\n      componentUpdateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__\n        ? HooksDispatcherOnUpdateInDEV\n        : HooksDispatcherOnUpdate;\n\n      children = Component(props, refOrContext);\n    } while (didScheduleRenderPhaseUpdate);\n\n    renderPhaseUpdates = null;\n    numberOfReRenders = 0;\n  }\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  const renderedWork: Fiber = (currentlyRenderingFiber: any);\n\n  renderedWork.memoizedState = firstWorkInProgressHook;\n  renderedWork.expirationTime = remainingExpirationTime;\n  renderedWork.updateQueue = (componentUpdateQueue: any);\n  renderedWork.effectTag |= sideEffectTag;\n\n  if (__DEV__) {\n    renderedWork._debugHookTypes = hookTypesDev;\n  }\n\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n\n  currentHook = null;\n  nextCurrentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n  nextWorkInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  remainingExpirationTime = NoWork;\n  componentUpdateQueue = null;\n  sideEffectTag = 0;\n\n  // These were reset above\n  // didScheduleRenderPhaseUpdate = false;\n  // renderPhaseUpdates = null;\n  // numberOfReRenders = 0;\n\n  invariant(\n    !didRenderTooFewHooks,\n    'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n      'early return statement.',\n  );\n\n  return children;\n}\n\nexport function bailoutHooks(\n  current: Fiber,\n  workInProgress: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.effectTag &= ~(PassiveEffect | UpdateEffect);\n  if (current.expirationTime <= expirationTime) {\n    current.expirationTime = NoWork;\n  }\n}\n\nexport function resetHooks(): void {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  // This is used to reset the state of this module when a component throws.\n  // It's also called inside mountIndeterminateComponent if we determine the\n  // component is a module-style component.\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n\n  currentHook = null;\n  nextCurrentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n  nextWorkInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    currentHookNameInDev = null;\n  }\n\n  remainingExpirationTime = NoWork;\n  componentUpdateQueue = null;\n  sideEffectTag = 0;\n\n  didScheduleRenderPhaseUpdate = false;\n  renderPhaseUpdates = null;\n  numberOfReRenders = 0;\n}\n\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    queue: null,\n    baseUpdate: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    firstWorkInProgressHook = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook(): Hook {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n\n    currentHook = nextCurrentHook;\n    nextCurrentHook = currentHook !== null ? currentHook.next : null;\n  } else {\n    // Clone from the current hook.\n    invariant(\n      nextCurrentHook !== null,\n      'Rendered more hooks than during the previous render.',\n    );\n    currentHook = nextCurrentHook;\n\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n\n      baseState: currentHook.baseState,\n      queue: currentHook.queue,\n      baseUpdate: currentHook.baseUpdate,\n\n      next: null,\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      workInProgressHook = firstWorkInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n    nextCurrentHook = currentHook.next;\n  }\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue {\n  return {\n    lastEffect: null,\n  };\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  });\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n    null,\n    // Flow doesn't know this is non-null, but we do.\n    ((currentlyRenderingFiber: any): Fiber),\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'Should have a queue. This is likely a bug in React. Please file an issue.',\n  );\n\n  queue.lastRenderedReducer = reducer;\n\n  if (numberOfReRenders > 0) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // work-in-progress hook.\n    const dispatch: Dispatch<A> = (queue.dispatch: any);\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          const action = update.action;\n          newState = reducer(newState, action);\n          update = update.next;\n        } while (update !== null);\n\n        // Mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n        if (!is(newState, hook.memoizedState)) {\n          markWorkInProgressReceivedUpdate();\n        }\n\n        hook.memoizedState = newState;\n        // Don't persist the state accumlated from the render phase updates to\n        // the base state unless the queue is empty.\n        // TODO: Not sure if this is the desired semantics, but it's what we\n        // do for gDSFP. I can't remember why.\n        if (hook.baseUpdate === queue.last) {\n          hook.baseState = newState;\n        }\n\n        queue.lastRenderedState = newState;\n\n        return [newState, dispatch];\n      }\n    }\n    return [hook.memoizedState, dispatch];\n  }\n\n  // The last update in the entire queue\n  const last = queue.last;\n  // The last update that is part of the base state.\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState;\n\n  // Find the first unprocessed update.\n  let first;\n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // For the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. Once the first update commits, and\n      // the `baseUpdate` is no longer empty, we can unravel the list.\n      last.next = null;\n    }\n    first = baseUpdate.next;\n  } else {\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n    do {\n      const updateExpirationTime = update.expirationTime;\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        }\n        // Update the remaining priority in the queue.\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n        }\n      } else {\n        // Process this update.\n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          newState = ((update.eagerState: any): S);\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      prevUpdate = update;\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  });\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchAction.bind(\n    null,\n    // Flow doesn't know this is non-null, but we do.\n    ((currentlyRenderingFiber: any): Fiber),\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\nfunction mountRef<T>(initialValue: T): {current: T} {\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return mountEffectImpl(\n    UpdateEffect | PassiveEffect,\n    UnmountPassive | MountPassive,\n    create,\n    deps,\n  );\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(\n    UpdateEffect | PassiveEffect,\n    UnmountPassive | MountPassive,\n    create,\n    deps,\n  );\n}\n\nfunction mountLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return mountEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    create,\n    deps,\n  );\n}\n\nfunction updateLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    create,\n    deps,\n  );\n}\n\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n    if (__DEV__) {\n      warning(\n        refObject.hasOwnProperty('current'),\n        'Expected useImperativeHandle() first argument to either be a ' +\n          'ref callback or React.createRef() object. Instead received: %s.',\n        'an object with keys {' + Object.keys(refObject).join(', ') + '}',\n      );\n    }\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    warning(\n      typeof create === 'function',\n      'Expected useImperativeHandle() second argument to be a function ' +\n        'that creates a handle. Instead received: %s.',\n      create !== null ? typeof create : 'null',\n    );\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return mountEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction updateImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    warning(\n      typeof create === 'function',\n      'Expected useImperativeHandle() second argument to be a function ' +\n        'that creates a handle. Instead received: %s.',\n      create !== null ? typeof create : 'null',\n    );\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return updateEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction mountDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n  // This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  invariant(\n    numberOfReRenders < RE_RENDER_LIMIT,\n    'Too many re-renders. React limits the number of renders to prevent ' +\n      'an infinite loop.',\n  );\n\n  if (__DEV__) {\n    warning(\n      arguments.length <= 3,\n      \"State updates from the useState() and useReducer() Hooks don't support the \" +\n        'second callback argument. To execute a side effect after ' +\n        'rendering, declare it in the component body with useEffect().',\n    );\n  }\n\n  const alternate = fiber.alternate;\n  if (\n    fiber === currentlyRenderingFiber ||\n    (alternate !== null && alternate === currentlyRenderingFiber)\n  ) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true;\n    const update: Update<S, A> = {\n      expirationTime: renderExpirationTime,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map();\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n      lastRenderPhaseUpdate.next = update;\n    }\n  } else {\n    flushPassiveEffects();\n\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update: Update<S, A> = {\n      expirationTime,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n\n    // Append the update to the end of the list.\n    const last = queue.last;\n    if (last === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      const first = last.next;\n      if (first !== null) {\n        // Still circular.\n        update.next = first;\n      }\n      last.next = update;\n    }\n    queue.last = update;\n\n    if (\n      fiber.expirationTime === NoWork &&\n      (alternate === null || alternate.expirationTime === NoWork)\n    ) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          const eagerState = lastRenderedReducer(currentState, action);\n          // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n    if (__DEV__) {\n      // jest isn't a 'global', it's just exposed to tests via a wrapped function\n      // further, this isn't a test file, so flow doesn't recognize the symbol. So...\n      // $FlowExpectedError - because requirements don't give a damn about your type sigs.\n      if ('undefined' !== typeof jest) {\n        warnIfNotCurrentlyActingUpdatesInDev(fiber);\n      }\n    }\n    scheduleWork(fiber, expirationTime);\n  }\n}\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n};\n\nconst HooksDispatcherOnMount: Dispatcher = {\n  readContext,\n\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n};\n\nlet HooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    warning(\n      false,\n      'Context can only be read while React is rendering. ' +\n        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\n        'In function components, you can read it directly in the function body, but not ' +\n        'inside Hooks like useReducer() or useMemo().',\n    );\n  };\n\n  const warnInvalidHookAccess = () => {\n    warning(\n      false,\n      'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\n        'You can only call Hooks at the top level of your React function. ' +\n        'For more information, see ' +\n        'https://fb.me/rules-of-hooks',\n    );\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n  };\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n  };\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n  };\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberPendingPriority.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberBeginWork.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHostContext.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberSuspenseComponent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberErrorLogger.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberLazyComponent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberHydrationContext.js",["1001","1002","1003","1004","1005","1006"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {\n  Instance,\n  TextInstance,\n  HydratableInstance,\n  SuspenseInstance,\n  Container,\n  HostContext,\n} from './ReactFiberHostConfig';\n\nimport {\n  HostComponent,\n  HostText,\n  HostRoot,\n  SuspenseComponent,\n  DehydratedSuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport {Deletion, Placement} from 'shared/ReactSideEffectTags';\nimport invariant from 'shared/invariant';\n\nimport {createFiberFromHostInstanceForDeletion} from './ReactFiber';\nimport {\n  shouldSetTextContent,\n  supportsHydration,\n  canHydrateInstance,\n  canHydrateTextInstance,\n  canHydrateSuspenseInstance,\n  getNextHydratableSibling,\n  getFirstHydratableChild,\n  hydrateInstance,\n  hydrateTextInstance,\n  getNextHydratableInstanceAfterSuspenseInstance,\n  didNotMatchHydratedContainerTextInstance,\n  didNotMatchHydratedTextInstance,\n  didNotHydrateContainerInstance,\n  didNotHydrateInstance,\n  didNotFindHydratableContainerInstance,\n  didNotFindHydratableContainerTextInstance,\n  didNotFindHydratableContainerSuspenseInstance,\n  didNotFindHydratableInstance,\n  didNotFindHydratableTextInstance,\n  didNotFindHydratableSuspenseInstance,\n} from './ReactFiberHostConfig';\nimport {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nlet hydrationParentFiber: null | Fiber = null;\nlet nextHydratableInstance: null | HydratableInstance = null;\nlet isHydrating: boolean = false;\n\nfunction enterHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(\n  fiber: Fiber,\n): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const suspenseInstance = fiber.stateNode;\n  nextHydratableInstance = getNextHydratableSibling(suspenseInstance);\n  popToNextHostParent(fiber);\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(\n  returnFiber: Fiber,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(\n          returnFiber.stateNode.containerInfo,\n          instance,\n        );\n        break;\n      case HostComponent:\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance,\n        );\n        break;\n    }\n  }\n\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {\n  fiber.effectTag |= Placement;\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        const parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableContainerInstance(parentContainer, type, props);\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableContainerTextInstance(parentContainer, text);\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableContainerSuspenseInstance(parentContainer);\n            break;\n        }\n        break;\n      }\n      case HostComponent: {\n        const parentType = returnFiber.type;\n        const parentProps = returnFiber.memoizedProps;\n        const parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              type,\n              props,\n            );\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              text,\n            );\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableSuspenseInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n            );\n            break;\n        }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent: {\n      const type = fiber.type;\n      const props = fiber.pendingProps;\n      const instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = (instance: Instance);\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      const text = fiber.pendingProps;\n      const textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = (textInstance: TextInstance);\n        return true;\n      }\n      return false;\n    }\n    case SuspenseComponent: {\n      if (enableSuspenseServerRenderer) {\n        const suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n        if (suspenseInstance !== null) {\n          // Downgrade the tag to a dehydrated component until we've hydrated it.\n          fiber.tag = DehydratedSuspenseComponent;\n          fiber.stateNode = (suspenseInstance: SuspenseInstance);\n          return true;\n        }\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber: Fiber): void {\n  if (!isHydrating) {\n    return;\n  }\n  let nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  const firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(\n      (hydrationParentFiber: any),\n      firstAttemptedInstance,\n    );\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild((nextInstance: any));\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber: Fiber,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected prepareToHydrateHostInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const instance: Instance = fiber.stateNode;\n  const updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    rootContainerInstance,\n    hostContext,\n    fiber,\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = (updatePayload: any);\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected prepareToHydrateHostTextInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const textInstance: TextInstance = fiber.stateNode;\n  const textContent: string = fiber.memoizedProps;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  if (__DEV__) {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      const returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot: {\n            const parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(\n              parentContainer,\n              textInstance,\n              textContent,\n            );\n            break;\n          }\n          case HostComponent: {\n            const parentType = returnFiber.type;\n            const parentProps = returnFiber.memoizedProps;\n            const parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              textInstance,\n              textContent,\n            );\n            break;\n          }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber: Fiber): void {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n  let suspenseInstance = fiber.stateNode;\n  invariant(\n    suspenseInstance,\n    'Expected to have a hydrated suspense instance. ' +\n      'This error is likely caused by a bug in React. Please file an issue.',\n  );\n  nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(\n    suspenseInstance,\n  );\n}\n\nfunction popToNextHostParent(fiber: Fiber): void {\n  let parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot &&\n    parent.tag !== DehydratedSuspenseComponent\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  const type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (\n    fiber.tag !== HostComponent ||\n    (type !== 'head' &&\n      type !== 'body' &&\n      !shouldSetTextContent(type, fiber.memoizedProps))\n  ) {\n    let nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber\n    ? getNextHydratableSibling(fiber.stateNode)\n    : null;\n  return true;\n}\n\nfunction resetHydrationState(): void {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nexport {\n  enterHydrationState,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  tryToClaimNextHydratableInstance,\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  skipPastDehydratedSuspenseInstance,\n  popHydrationState,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactHookEffectTags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactChildFiber.js",["1007","1008","1009","1010"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement} from 'shared/ReactElementType';\nimport type {ReactPortal} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport getComponentName from 'shared/getComponentName';\nimport {Placement, Deletion} from 'shared/ReactSideEffectTags';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {\n  FunctionComponent,\n  ClassComponent,\n  HostText,\n  HostPortal,\n  Fragment,\n} from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nimport {\n  createWorkInProgress,\n  createFiberFromElement,\n  createFiberFromFragment,\n  createFiberFromText,\n  createFiberFromPortal,\n} from './ReactFiber';\nimport {emptyRefsObject} from './ReactFiberClassComponent';\nimport {\n  getCurrentFiberStackInDev,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {StrictMode} from './ReactTypeOfMode';\n\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefInStrictMode;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\nlet warnForMissingKey = (child: mixed) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child: mixed) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === 'object',\n      'React Component in warnForMissingKey should have a _store. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n    child._store.validated = true;\n\n    const currentComponentErrorInfo =\n      'Each child in a list should have a unique ' +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      'more information.' +\n      getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(\n      false,\n      'Each child in a list should have a unique ' +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        'more information.',\n    );\n  };\n}\n\nconst isArray = Array.isArray;\n\nfunction coerceRef(\n  returnFiber: Fiber,\n  current: Fiber | null,\n  element: ReactElement,\n) {\n  let mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== 'function' &&\n    typeof mixedRef !== 'object'\n  ) {\n    if (__DEV__) {\n      if (returnFiber.mode & StrictMode) {\n        const componentName = getComponentName(returnFiber.type) || 'Component';\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warningWithoutStack(\n            false,\n            'A string ref, \"%s\", has been found within a strict mode tree. ' +\n              'String refs are a source of potential bugs and should be avoided. ' +\n              'We recommend using createRef() instead.' +\n              '\\n%s' +\n              '\\n\\nLearn more about using refs safely here:' +\n              '\\nhttps://fb.me/react-strict-mode-string-ref',\n            mixedRef,\n            getStackByFiberInDevAndProd(returnFiber),\n          );\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner: ?Fiber = (element._owner: any);\n      let inst;\n      if (owner) {\n        const ownerFiber = ((owner: any): Fiber);\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          'Function components cannot have refs. ' +\n            'Did you mean to use React.forwardRef()?',\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        'Missing owner for string ref %s. This error is likely caused by a ' +\n          'bug in React. Please file an issue.',\n        mixedRef,\n      );\n      const stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        typeof current.ref === 'function' &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      const ref = function(value) {\n        let refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === 'string',\n        'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',\n      );\n      invariant(\n        element._owner,\n        'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' +\n          ' the following reasons:\\n' +\n          '1. You may be adding a ref to a function component\\n' +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          '3. You have multiple copies of React loaded\\n' +\n          'See https://fb.me/react-refs-must-have-owner for more information.',\n        mixedRef,\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber: Fiber, newChild: Object) {\n  if (returnFiber.type !== 'textarea') {\n    let addendum = '';\n    if (__DEV__) {\n      addendum =\n        ' If you meant to render a collection of children, use an array ' +\n        'instead.' +\n        getCurrentFiberStackInDev();\n    }\n    invariant(\n      false,\n      'Objects are not valid as a React child (found: %s).%s',\n      Object.prototype.toString.call(newChild) === '[object Object]'\n        ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\n        : newChild,\n      addendum,\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  const currentComponentErrorInfo =\n    'Functions are not valid as a React child. This may happen if ' +\n    'you return a Component instead of <Component /> from render. ' +\n    'Or maybe you meant to call this function rather than return it.' +\n    getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(\n    false,\n    'Functions are not valid as a React child. This may happen if ' +\n      'you return a Component instead of <Component /> from render. ' +\n      'Or maybe you meant to call this function rather than return it.',\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    // 找到父组件中需要更新的最后一个子组件\n    const last = returnFiber.lastEffect;\n    // 判断链表是否存在\n    // 这个链表的目的就是把该父节点上的所有需要更新的子节点通过链表链接起来\n    // 然后下次真正需要更新的时候只需要遍历链表即可\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n  ): null {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    let childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber,\n  ): Map<string | number, Fiber> {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren: Map<string | number, Fiber> = new Map();\n\n    let existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(\n    fiber: Fiber,\n    pendingProps: mixed,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(\n    newFiber: Fiber,\n    lastPlacedIndex: number,\n    newIndex: number,\n  ): number {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    // 更新组件才执行下面逻辑\n    const current = newFiber.alternate;\n    // 比较两个 index 的值，并打上 tag，这个 tag 代表插入或者移动节点。\n    if (current !== null) {\n      const oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber: Fiber): Fiber {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    textContent: string,\n    expirationTime: ExpirationTime,\n  ) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    element: ReactElement,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    if (current !== null && current.elementType === element.type) {\n      // Move based on index\n      const existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing.return = returnFiber;\n      if (__DEV__) {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      const created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.ref = coerceRef(returnFiber, current, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    portal: ReactPortal,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      const created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    fragment: Iterable<*>,\n    expirationTime: ExpirationTime,\n    key: null | string,\n  ): Fiber {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(\n    returnFiber: Fiber,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText(\n        '' + newChild,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime,\n          );\n          created.ref = coerceRef(returnFiber, null, newChild);\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_PORTAL_TYPE: {\n          const created = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime,\n          );\n          created.return = returnFiber;\n          return created;\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null,\n        );\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // Update the fiber if the keys match, otherwise return null.\n\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        '' + newChild,\n        expirationTime,\n      );\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key,\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime,\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime,\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren: Map<string | number, Fiber>,\n    returnFiber: Fiber,\n    newIdx: number,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        '' + newChild,\n        expirationTime,\n      );\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key,\n            );\n          }\n          return updateElement(\n            returnFiber,\n            matchedFiber,\n            newChild,\n            expirationTime,\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            matchedFiber,\n            newChild,\n            expirationTime,\n          );\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n          null,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(\n    child: mixed,\n    knownKeys: Set<string> | null,\n  ): Set<string> | null {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          const key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            'Encountered two children with the same key, `%s`. ' +\n              'Keys should be unique so that components maintain their identity ' +\n              'across updates. Non-unique keys may cause children to be ' +\n              'duplicated and/or omitted — the behavior is unsupported and ' +\n              'could change in a future version.',\n            key,\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildren: Array<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n    // 原父节点的第一个子节点\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    // 第一轮遍历条件：存在原先的子节点且未遍历完需要更新的子节点\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      // 第一个条件没看懂，想不到什么情况下会老的 fiber 的 index > newIdx\n      //  正常来说 nextOldFiber 就是下一个节点了\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      // 如果 key 相同的话就可以复用 fiber。另外 oldFiber 如果为空的话，就会重新创建一个 fiber\n      // 这个情况对应上面我看不懂的条件\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      // 如果不能复用 fiber 话，就跳出循环\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      // 接下来都是可以复用 fiber 的逻辑\n      // shouldTrackSideEffects 代表更新组件\n      // 如果需要追踪副作用并且是重新创建了一个 fiber 的情况\n      // 那么会把 oldFiber 删掉\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // 第一次渲染赋值\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        // 链表连接新的 fiber 节点\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    // 新的子节点已经遍历完毕，那就看看是否还需要把老的剩余子节点删掉\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n    // 老的子节点遍历完毕\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      // 遍历剩余的新子节点\n      for (; newIdx < newChildren.length; newIdx++) {\n        // 不能复用了，所以只能创建\n        const newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime,\n        );\n        if (!newFiber) {\n          continue;\n        }\n        // 下面的逻辑和之前一样\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    // 这里指新老的子节点都没有遍历完，那就把老的子节点的 key 或者 index 生成一个 Map\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    // 继续遍历新的子节点\n    for (; newIdx < newChildren.length; newIdx++) {\n      // 从 Map 中找出可以复用的 fiber 节点，不能复用就重新创建新的\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      // 以下逻辑和之前的一样\n      if (newFiber) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            // 如果复用 fiber，就把原先的 fiber 删了\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); // 2\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n    // 把不能复用的子节点都删了\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildrenIterable: Iterable<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === 'function',\n      'An object is not an iterable. This error is likely caused by a bug in ' +\n        'React. Please file an issue.',\n    );\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === 'function' &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === 'Generator'\n      ) {\n        warning(\n          didWarnAboutGenerators,\n          'Using Generators as children is unsupported and will likely yield ' +\n            'unexpected results because enumerating a generator mutates it. ' +\n            'You may convert it to an array with `Array.from()` or the ' +\n            '`[...spread]` operator before rendering. Keep in mind ' +\n            'you might need to polyfill these features for older browsers.',\n        );\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if ((newChildrenIterable: any).entries === iteratorFn) {\n        warning(\n          didWarnAboutMaps,\n          'Using Maps as children is unsupported and will likely yield ' +\n            'unexpected results. Convert it to a sequence/iterable of keyed ' +\n            'ReactElements instead.',\n        );\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      const newChildren = iteratorFn.call(newChildrenIterable);\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, 'An iterable object provided no iterator.');\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    let step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      // 只有当 key 相同时复用 fiber\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime,\n      );\n      // 不能复用 fiber 就结束第一轮遍历\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, expirationTime);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    textContent: string,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    const key = element.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.elementType === element.type\n        ) {\n          // key 相同且 type 相同，进行复用，不相同呢就开始删\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime,\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          if (__DEV__) {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n    // 不相同的情况下去创建新的 fiber node\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    portal: ReactPortal,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    const key = portal.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(\n            child,\n            portal.children || [],\n            expirationTime,\n          );\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    // 判断是否为 fragment，是的话取 fragment 的 children\n    const isUnkeyedTopLevelFragment =\n      typeof newChild === 'object' &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    //  是的话，就取 fragment 的 children\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    // 接下来开始判断返回值的类型\n    const isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      // 判断下类型，反正都是单个节点的类型，\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // 判断之前是否也是 text Node，是的话就可以复用，只需要替换文本即可\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          '' + newChild,\n          expirationTime,\n        ),\n      );\n    }\n    // 处理子节点是数组的情况\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    // 错误处理\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          if (__DEV__) {\n            const instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionComponent: {\n          const Component = returnFiber.type;\n          invariant(\n            false,\n            '%s(...): Nothing was returned from render. This usually means a ' +\n              'return statement is missing. Or, to render nothing, ' +\n              'return null.',\n            Component.displayName || Component.name || 'Component',\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    // 进这里说明返回值为 null，删除所有的 children\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    'Resuming work not yet implemented.',\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime,\n  );\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberClassComponent.js",["1011"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport React from 'react';\nimport {Update, Snapshot} from 'shared/ReactSideEffectTags';\nimport {\n  debugRenderPhaseSideEffects,\n  debugRenderPhaseSideEffectsForStrictMode,\n  warnAboutDeprecatedLifecycles,\n} from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {isMounted} from 'react-reconciler/reflection';\nimport {get as getInstance, set as setInstance} from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE} from 'shared/ReactSymbols';\n\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {StrictMode} from './ReactTypeOfMode';\n\nimport {\n  enqueueUpdate,\n  processUpdateQueue,\n  checkHasForceUpdateAfterProcessing,\n  resetHasForceUpdateBeforeProcessing,\n  createUpdate,\n  ReplaceState,\n  ForceUpdate,\n} from './ReactUpdateQueue';\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  cacheContext,\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged,\n  emptyContextObject,\n} from './ReactFiberContext';\nimport {readContext} from './ReactFiberNewContext';\nimport {\n  requestCurrentTime,\n  computeExpirationForFiber,\n  scheduleWork,\n  flushPassiveEffects,\n} from './ReactFiberScheduler';\n\nconst fakeInternalInstance = {};\nconst isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nexport const emptyRefsObject = new React.Component().refs;\n\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    const key = `${callerName}_${(callback: any)}`;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack(\n        false,\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentName(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack(\n          false,\n          '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' +\n            'You have returned undefined.',\n          componentName,\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        '_processChildContext is not available in React 16+. This likely ' +\n          'means you have multiple copies of React and are attempting to nest ' +\n          'a React 15 tree inside a React 16 tree using ' +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          'to make sure you have only one copy of React (and ideally, switch ' +\n          'to ReactDOM.createPortal).',\n      );\n    },\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nexport function applyDerivedStateFromProps(\n  workInProgress: Fiber,\n  ctor: any,\n  getDerivedStateFromProps: (props: any, state: any) => any,\n  nextProps: any,\n) {\n  const prevState = workInProgress.memoizedState;\n\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  const partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  const memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  const updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nconst classComponentUpdater = {\n  isMounted,\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    flushPassiveEffects();\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    flushPassiveEffects();\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTime();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    const update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    flushPassiveEffects();\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext,\n) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    const shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextContext,\n    );\n    stopPhaseTimer();\n\n    if (__DEV__) {\n      warningWithoutStack(\n        shouldUpdate !== undefined,\n        '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\n          'boolean value. Make sure to return true or false.',\n        getComponentName(ctor) || 'Component',\n      );\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress: Fiber, ctor: any, newProps: any) {\n  const instance = workInProgress.stateNode;\n  if (__DEV__) {\n    const name = getComponentName(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        warningWithoutStack(\n          false,\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: did you accidentally return an object from the constructor?',\n          name,\n        );\n      } else {\n        warningWithoutStack(\n          false,\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: you may have forgotten to define `render`.',\n          name,\n        );\n      }\n    }\n\n    const noGetInitialStateOnES6 =\n      !instance.getInitialState ||\n      instance.getInitialState.isReactClassApproved ||\n      instance.state;\n    warningWithoutStack(\n      noGetInitialStateOnES6,\n      'getInitialState was defined on %s, a plain JavaScript class. ' +\n        'This is only supported for classes created using React.createClass. ' +\n        'Did you mean to define a state property instead?',\n      name,\n    );\n    const noGetDefaultPropsOnES6 =\n      !instance.getDefaultProps ||\n      instance.getDefaultProps.isReactClassApproved;\n    warningWithoutStack(\n      noGetDefaultPropsOnES6,\n      'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n        'This is only supported for classes created using React.createClass. ' +\n        'Use a static property to define defaultProps instead.',\n      name,\n    );\n    const noInstancePropTypes = !instance.propTypes;\n    warningWithoutStack(\n      noInstancePropTypes,\n      'propTypes was defined as an instance property on %s. Use a static ' +\n        'property to define propTypes instead.',\n      name,\n    );\n    const noInstanceContextType = !instance.contextType;\n    warningWithoutStack(\n      noInstanceContextType,\n      'contextType was defined as an instance property on %s. Use a static ' +\n        'property to define contextType instead.',\n      name,\n    );\n    const noInstanceContextTypes = !instance.contextTypes;\n    warningWithoutStack(\n      noInstanceContextTypes,\n      'contextTypes was defined as an instance property on %s. Use a static ' +\n        'property to define contextTypes instead.',\n      name,\n    );\n\n    if (\n      ctor.contextType &&\n      ctor.contextTypes &&\n      !didWarnAboutContextTypeAndContextTypes.has(ctor)\n    ) {\n      didWarnAboutContextTypeAndContextTypes.add(ctor);\n      warningWithoutStack(\n        false,\n        '%s declares both contextTypes and contextType static properties. ' +\n          'The legacy contextTypes property will be ignored.',\n        name,\n      );\n    }\n\n    const noComponentShouldUpdate =\n      typeof instance.componentShouldUpdate !== 'function';\n    warningWithoutStack(\n      noComponentShouldUpdate,\n      '%s has a method called ' +\n        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n        'The name is phrased as a question because the function is ' +\n        'expected to return a value.',\n      name,\n    );\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== 'undefined'\n    ) {\n      warningWithoutStack(\n        false,\n        '%s has a method called shouldComponentUpdate(). ' +\n          'shouldComponentUpdate should not be used when extending React.PureComponent. ' +\n          'Please extend React.Component if shouldComponentUpdate is used.',\n        getComponentName(ctor) || 'A pure component',\n      );\n    }\n    const noComponentDidUnmount =\n      typeof instance.componentDidUnmount !== 'function';\n    warningWithoutStack(\n      noComponentDidUnmount,\n      '%s has a method called ' +\n        'componentDidUnmount(). But there is no such lifecycle method. ' +\n        'Did you mean componentWillUnmount()?',\n      name,\n    );\n    const noComponentDidReceiveProps =\n      typeof instance.componentDidReceiveProps !== 'function';\n    warningWithoutStack(\n      noComponentDidReceiveProps,\n      '%s has a method called ' +\n        'componentDidReceiveProps(). But there is no such lifecycle method. ' +\n        'If you meant to update the state in response to changing props, ' +\n        'use componentWillReceiveProps(). If you meant to fetch data or ' +\n        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',\n      name,\n    );\n    const noComponentWillRecieveProps =\n      typeof instance.componentWillRecieveProps !== 'function';\n    warningWithoutStack(\n      noComponentWillRecieveProps,\n      '%s has a method called ' +\n        'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n      name,\n    );\n    const noUnsafeComponentWillRecieveProps =\n      typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n    warningWithoutStack(\n      noUnsafeComponentWillRecieveProps,\n      '%s has a method called ' +\n        'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',\n      name,\n    );\n    const hasMutatedProps = instance.props !== newProps;\n    warningWithoutStack(\n      instance.props === undefined || !hasMutatedProps,\n      '%s(...): When calling super() in `%s`, make sure to pass ' +\n        \"up the same props that your component's constructor was passed.\",\n      name,\n      name,\n    );\n    const noInstanceDefaultProps = !instance.defaultProps;\n    warningWithoutStack(\n      noInstanceDefaultProps,\n      'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +\n        ' Instead, define defaultProps as a static property on %s.',\n      name,\n      name,\n    );\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === 'function' &&\n      typeof instance.componentDidUpdate !== 'function' &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack(\n        false,\n        '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' +\n          'This component defines getSnapshotBeforeUpdate() only.',\n        getComponentName(ctor),\n      );\n    }\n\n    const noInstanceGetDerivedStateFromProps =\n      typeof instance.getDerivedStateFromProps !== 'function';\n    warningWithoutStack(\n      noInstanceGetDerivedStateFromProps,\n      '%s: getDerivedStateFromProps() is defined as an instance method ' +\n        'and will be ignored. Instead, declare it as a static method.',\n      name,\n    );\n    const noInstanceGetDerivedStateFromCatch =\n      typeof instance.getDerivedStateFromError !== 'function';\n    warningWithoutStack(\n      noInstanceGetDerivedStateFromCatch,\n      '%s: getDerivedStateFromError() is defined as an instance method ' +\n        'and will be ignored. Instead, declare it as a static method.',\n      name,\n    );\n    const noStaticGetSnapshotBeforeUpdate =\n      typeof ctor.getSnapshotBeforeUpdate !== 'function';\n    warningWithoutStack(\n      noStaticGetSnapshotBeforeUpdate,\n      '%s: getSnapshotBeforeUpdate() is defined as a static method ' +\n        'and will be ignored. Instead, declare it as an instance method.',\n      name,\n    );\n    const state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      warningWithoutStack(\n        false,\n        '%s.state: must be set to an object or null',\n        name,\n      );\n    }\n    if (typeof instance.getChildContext === 'function') {\n      warningWithoutStack(\n        typeof ctor.childContextTypes === 'object',\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n          'use getChildContext().',\n        name,\n      );\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress: Fiber, instance: any): void {\n  // setState = this.updater.enqueueSetState\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  // 用于获取 fiber\n  // instance._reactInternalFiber = workInProgress\n  setInstance(instance, workInProgress);\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  props: any,\n  renderExpirationTime: ExpirationTime,\n): any {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = null;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      let isValid =\n        // Allow null for conditional declaration\n        contextType === null ||\n        (contextType !== undefined &&\n          contextType.$$typeof === REACT_CONTEXT_TYPE &&\n          contextType._context === undefined); // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n\n        let addendum = '';\n        if (contextType === undefined) {\n          addendum =\n            ' However, it is set to undefined. ' +\n            'This can be caused by a typo or by mixing up named and default imports. ' +\n            'This can also happen due to a circular dependency, so ' +\n            'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum =\n            ' However, it is set to an object with keys {' +\n            Object.keys(contextType).join(', ') +\n            '}.';\n        }\n        warningWithoutStack(\n          false,\n          '%s defines an invalid contextType. ' +\n            'contextType should point to the Context object returned by React.createContext().%s',\n          getComponentName(ctor) || 'Component',\n          addendum,\n        );\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext((contextType: any));\n  } else {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer =\n      contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyContextObject;\n  }\n\n  // Instantiate twice to help detect side-effects.\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  const instance = new ctor(props, context);\n  const state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack(\n          false,\n          '`%s` uses `getDerivedStateFromProps` but its initial state is ' +\n            '%s. This is not recommended. Instead, define the initial state by ' +\n            'assigning an object to `this.state` in the constructor of `%s`. ' +\n            'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',\n          componentName,\n          instance.state === null ? 'null' : 'undefined',\n          componentName,\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === 'function' ||\n      typeof instance.getSnapshotBeforeUpdate === 'function'\n    ) {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === 'function' &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (\n        typeof instance.componentWillReceiveProps === 'function' &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === 'function'\n      ) {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (\n        typeof instance.componentWillUpdate === 'function' &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        const componentName = getComponentName(ctor) || 'Component';\n        const newApiName =\n          typeof ctor.getDerivedStateFromProps === 'function'\n            ? 'getDerivedStateFromProps()'\n            : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          warningWithoutStack(\n            false,\n            'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n              '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' +\n              'The above lifecycles should be removed. Learn more about this warning here:\\n' +\n              'https://fb.me/react-async-component-lifecycle-hooks',\n            componentName,\n            newApiName,\n            foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '',\n            foundWillReceivePropsName !== null\n              ? `\\n  ${foundWillReceivePropsName}`\n              : '',\n            foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '',\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      warningWithoutStack(\n        false,\n        '%s.componentWillMount(): Assigning directly to this.state is ' +\n          \"deprecated (except inside a component's \" +\n          'constructor). Use setState instead.',\n        getComponentName(workInProgress.type) || 'Component',\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext,\n) {\n  const oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName =\n        getComponentName(workInProgress.type) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack(\n          false,\n          '%s.componentWillReceiveProps(): Assigning directly to ' +\n            \"this.state is deprecated (except inside a component's \" +\n            'constructor). Use setState instead.',\n          componentName,\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n\n  const contextType = ctor.contextType;\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack(\n          false,\n          '%s: It is not recommended to assign props directly to state ' +\n            \"because updates to props won't be reflected in state. \" +\n            'In most cases, it is better to use props directly.',\n          componentName,\n        );\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance,\n      );\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance,\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(\n        workInProgress,\n        instance,\n      );\n    }\n  }\n\n  // 获取 updateQueue，和 setState 相关\n  let updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    // 执行所有的 setState 获取当前的 state\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n  // 接下来就是判断是否存在生命周期函数并执行了\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== 'function' &&\n    typeof instance.getSnapshotBeforeUpdate !== 'function' &&\n    (typeof instance.UNSAFE_componentWillMount === 'function' ||\n      typeof instance.componentWillMount === 'function')\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    // 在 WillMount 执行后会判断是否 setState 了\n    // 如果有的话，会立即获取最新的 state\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(\n        workInProgress,\n        updateQueue,\n        newProps,\n        instance,\n        renderExpirationTime,\n      );\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(\n      workInProgress,\n      ctor,\n      true,\n    );\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  let updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    newState = workInProgress.memoizedState;\n  }\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === 'function' ||\n        typeof instance.componentWillMount === 'function')\n    ) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(\n  current: Fiber,\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props =\n    workInProgress.type === workInProgress.elementType\n      ? oldProps\n      : resolveDefaultProps(workInProgress.type, oldProps);\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n  // 前面的没啥好看的\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  let updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    newState = workInProgress.memoizedState;\n  }\n  // 判断是否不需要更新，如果不需要渲染，但是 state 或者 props 和之前的数据不同\n  // 还是会调用 componentDidUpdate 及 getSnapshotBeforeUpdate\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n  // 执行 shouldComponentUpdate\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n  // 生命周期函数的调用\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === 'function' ||\n        typeof instance.componentWillUpdate === 'function')\n    ) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\nexport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n};\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/ReactFiberErrorDialog.js",["1012"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {CapturedError} from './ReactCapturedValue';\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nexport function showErrorDialog(capturedError: CapturedError): boolean {\n  return true;\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-reconciler/src/forks/ReactFiberHostConfig.dom.js",[],"/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/ReactDOMHostConfig.js",["1013","1014","1015","1016","1017","1018","1019","1020","1021","1022","1023","1024","1025","1026","1027"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as Scheduler from 'scheduler';\n\nimport {precacheFiberNode, updateFiberProps} from './ReactDOMComponentTree';\nimport {\n  createElement,\n  createTextNode,\n  setInitialProperties,\n  diffProperties,\n  updateProperties,\n  diffHydratedProperties,\n  diffHydratedText,\n  trapClickOnNonInteractiveElement,\n  warnForUnmatchedText,\n  warnForDeletedHydratableElement,\n  warnForDeletedHydratableText,\n  warnForInsertedHydratedElement,\n  warnForInsertedHydratedText,\n  listenToEventResponderEventTypes,\n} from './ReactDOMComponent';\nimport {getSelectionInformation, restoreSelection} from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport {validateDOMNesting, updatedAncestorInfo} from './validateDOMNesting';\nimport {\n  isEnabled as ReactBrowserEventEmitterIsEnabled,\n  setEnabled as ReactBrowserEventEmitterSetEnabled,\n} from '../events/ReactBrowserEventEmitter';\nimport {Namespaces, getChildNamespace} from '../shared/DOMNamespaces';\nimport {\n  ELEMENT_NODE,\n  TEXT_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n} from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\n\nimport type {DOMContainer} from './ReactDOM';\nimport type {ReactEventResponder} from 'shared/ReactTypes';\nimport {unmountEventResponder} from '../events/DOMEventResponderSystem';\nimport {REACT_EVENT_TARGET_TOUCH_HIT} from 'shared/ReactSymbols';\nimport {canUseDOM} from 'shared/ExecutionEnvironment';\n\nexport type Type = string;\nexport type Props = {\n  autoFocus?: boolean,\n  children?: mixed,\n  hidden?: boolean,\n  suppressHydrationWarning?: boolean,\n  dangerouslySetInnerHTML?: mixed,\n  style?: {\n    display?: string,\n  },\n  bottom?: null | number,\n  left?: null | number,\n  right?: null | number,\n  top?: null | number,\n};\nexport type EventTargetChildElement = {\n  type: string,\n  props: null | {\n    style?: {\n      position?: string,\n      zIndex?: number,\n      bottom?: string,\n      left?: string,\n      right?: string,\n      top?: string,\n    },\n  },\n};\nexport type Container = Element | Document;\nexport type Instance = Element;\nexport type TextInstance = Text;\nexport type SuspenseInstance = Comment & {_reactRetry?: () => void};\nexport type HydratableInstance = Instance | TextInstance | SuspenseInstance;\nexport type PublicInstance = Element | Text;\ntype HostContextDev = {\n  namespace: string,\n  ancestorInfo: mixed,\n  eventData: null | {|\n    isEventComponent?: boolean,\n    isEventTarget?: boolean,\n  |},\n};\ntype HostContextProd = string;\nexport type HostContext = HostContextDev | HostContextProd;\nexport type UpdatePayload = Array<mixed>;\nexport type ChildSet = void; // Unused\nexport type TimeoutHandle = TimeoutID;\nexport type NoTimeout = -1;\n\nimport {\n  enableSuspenseServerRenderer,\n  enableEventAPI,\n} from 'shared/ReactFeatureFlags';\nimport warning from 'shared/warning';\n\nconst {html: HTML_NAMESPACE} = Namespaces;\n\n// Intentionally not named imports because Rollup would\n// use dynamic dispatch for CommonJS interop named imports.\nconst {\n  unstable_now: now,\n  unstable_scheduleCallback: scheduleDeferredCallback,\n  unstable_shouldYield: shouldYield,\n  unstable_cancelCallback: cancelDeferredCallback,\n} = Scheduler;\n\nexport {now, scheduleDeferredCallback, shouldYield, cancelDeferredCallback};\n\nlet SUPPRESS_HYDRATION_WARNING;\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\n\nconst STYLE = 'style';\n\nlet eventsEnabled: ?boolean = null;\nlet selectionInformation: ?mixed = null;\n\nfunction shouldAutoFocusHostComponent(type: string, props: Props): boolean {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nexport * from 'shared/HostConfigWithNoPersistence';\n\nexport function getRootHostContext(\n  rootContainerInstance: Container,\n): HostContext {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE: {\n      type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n      let root = (rootContainerInstance: any).documentElement;\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n      break;\n    }\n    default: {\n      const container: any =\n        nodeType === COMMENT_NODE\n          ? rootContainerInstance.parentNode\n          : rootContainerInstance;\n      const ownNamespace = container.namespaceURI || null;\n      type = container.tagName;\n      namespace = getChildNamespace(ownNamespace, type);\n      break;\n    }\n  }\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {namespace, ancestorInfo, eventData: null};\n  }\n  return namespace;\n}\n\nexport function getChildHostContext(\n  parentHostContext: HostContext,\n  type: string,\n  rootContainerInstance: Container,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(\n      parentHostContextDev.ancestorInfo,\n      type,\n    );\n    return {namespace, ancestorInfo, eventData: null};\n  }\n  const parentNamespace = ((parentHostContext: any): HostContextProd);\n  return getChildNamespace(parentNamespace, type);\n}\n\nexport function getChildHostContextForEventComponent(\n  parentHostContext: HostContext,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const {namespace, ancestorInfo} = parentHostContextDev;\n    warning(\n      parentHostContextDev.eventData === null ||\n        !parentHostContextDev.eventData.isEventTarget,\n      'validateDOMNesting: React event targets must not have event components as children.',\n    );\n    const eventData = {\n      isEventComponent: true,\n      isEventTarget: false,\n    };\n    return {namespace, ancestorInfo, eventData};\n  }\n  return parentHostContext;\n}\n\nexport function getChildHostContextForEventTarget(\n  parentHostContext: HostContext,\n  type: Symbol | number,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const {namespace, ancestorInfo} = parentHostContextDev;\n    if (type === REACT_EVENT_TARGET_TOUCH_HIT) {\n      warning(\n        parentHostContextDev.eventData === null ||\n          !parentHostContextDev.eventData.isEventComponent,\n        'validateDOMNesting: <TouchHitTarget> cannot not be a direct child of an event component. ' +\n          'Ensure <TouchHitTarget> is a direct child of a DOM element.',\n      );\n      const parentNamespace = parentHostContextDev.namespace;\n      if (parentNamespace !== HTML_NAMESPACE) {\n        throw new Error(\n          '<TouchHitTarget> was used in an unsupported DOM namespace. ' +\n            'Ensure the <TouchHitTarget> is used in an HTML namespace.',\n        );\n      }\n    }\n    const eventData = {\n      isEventComponent: false,\n      isEventTarget: true,\n    };\n    return {namespace, ancestorInfo, eventData};\n  }\n  return parentHostContext;\n}\n\nexport function getPublicInstance(instance: Instance): * {\n  return instance;\n}\n\nexport function prepareForCommit(containerInfo: Container): void {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  ReactBrowserEventEmitterSetEnabled(false);\n}\n\nexport function resetAfterCommit(containerInfo: Container): void {\n  restoreSelection(selectionInformation);\n  selectionInformation = null;\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n}\n\nexport function createInstance(\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): Instance {\n  let parentNamespace: string;\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (\n      typeof props.children === 'string' ||\n      typeof props.children === 'number'\n    ) {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  const domElement: Instance = createElement(\n    type,\n    props,\n    rootContainerInstance,\n    parentNamespace,\n  );\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nexport function appendInitialChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function finalizeInitialChildren(\n  domElement: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nexport function prepareUpdate(\n  domElement: Instance,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): null | Array<mixed> {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    if (\n      typeof newProps.children !== typeof oldProps.children &&\n      (typeof newProps.children === 'string' ||\n        typeof newProps.children === 'number')\n    ) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(\n    domElement,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n  );\n}\n\nexport function shouldSetTextContent(type: string, props: Props): boolean {\n  return (\n    type === 'textarea' ||\n    type === 'option' ||\n    type === 'noscript' ||\n    typeof props.children === 'string' ||\n    typeof props.children === 'number' ||\n    (typeof props.dangerouslySetInnerHTML === 'object' &&\n      props.dangerouslySetInnerHTML !== null &&\n      props.dangerouslySetInnerHTML.__html != null)\n  );\n}\n\nexport function shouldDeprioritizeSubtree(type: string, props: Props): boolean {\n  return !!props.hidden;\n}\n\nexport function createTextInstance(\n  text: string,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): TextInstance {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n    if (enableEventAPI) {\n      const eventData = hostContextDev.eventData;\n      if (eventData !== null) {\n        warning(\n          !eventData.isEventComponent,\n          'validateDOMNesting: React event components cannot have text DOM nodes as children. ' +\n            'Wrap the child text \"%s\" in an element.',\n          text,\n        );\n      }\n    }\n  }\n  const textNode: TextInstance = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nexport const isPrimaryRenderer = true;\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nexport const scheduleTimeout =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\nexport const cancelTimeout =\n  typeof clearTimeout === 'function' ? clearTimeout : (undefined: any);\nexport const noTimeout = -1;\n\n// -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\n\nexport function commitMount(\n  domElement: Instance,\n  type: string,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    ((domElement: any):\n      | HTMLButtonElement\n      | HTMLInputElement\n      | HTMLSelectElement\n      | HTMLTextAreaElement).focus();\n  }\n}\n\nexport function commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nexport function resetTextContent(domElement: Instance): void {\n  setTextContent(domElement, '');\n}\n\nexport function commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\nexport function appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function appendChildToContainer(\n  container: DOMContainer,\n  child: Instance | TextInstance,\n): void {\n  let parentNode;\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = (container.parentNode: any);\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n  const reactRootContainer = container._reactRootContainer;\n  if (\n    (reactRootContainer === null || reactRootContainer === undefined) &&\n    parentNode.onclick === null\n  ) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement));\n  }\n}\n\nexport function insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nexport function insertInContainerBefore(\n  container: Container,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nexport function removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\nexport function removeChildFromContainer(\n  container: Container,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\nexport function clearSuspenseBoundary(\n  parentInstance: Instance,\n  suspenseInstance: SuspenseInstance,\n): void {\n  let node = suspenseInstance;\n  // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  do {\n    let nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      let data = ((nextNode: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = nextNode;\n  } while (node);\n  // TODO: Warn, we didn't find the end comment boundary.\n}\n\nexport function clearSuspenseBoundaryFromContainer(\n  container: Container,\n  suspenseInstance: SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary((container.parentNode: any), suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary((container: any), suspenseInstance);\n  } else {\n    // Document nodes should never contain suspense boundaries.\n  }\n}\n\nexport function hideInstance(instance: Instance): void {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = ((instance: any): HTMLElement);\n  instance.style.display = 'none';\n}\n\nexport function hideTextInstance(textInstance: TextInstance): void {\n  textInstance.nodeValue = '';\n}\n\nexport function unhideInstance(instance: Instance, props: Props): void {\n  instance = ((instance: any): HTMLElement);\n  const styleProp = props[STYLE];\n  const display =\n    styleProp !== undefined &&\n    styleProp !== null &&\n    styleProp.hasOwnProperty('display')\n      ? styleProp.display\n      : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\n\nexport function unhideTextInstance(\n  textInstance: TextInstance,\n  text: string,\n): void {\n  textInstance.nodeValue = text;\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\n\nexport function canHydrateInstance(\n  instance: HydratableInstance,\n  type: string,\n  props: Props,\n): null | Instance {\n  if (\n    instance.nodeType !== ELEMENT_NODE ||\n    type.toLowerCase() !== instance.nodeName.toLowerCase()\n  ) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return ((instance: any): Instance);\n}\n\nexport function canHydrateTextInstance(\n  instance: HydratableInstance,\n  text: string,\n): null | TextInstance {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return ((instance: any): TextInstance);\n}\n\nexport function canHydrateSuspenseInstance(\n  instance: HydratableInstance,\n): null | SuspenseInstance {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a suspense node.\n  return ((instance: any): SuspenseInstance);\n}\n\nexport function isSuspenseInstancePending(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\n\nexport function isSuspenseInstanceFallback(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\n\nexport function registerSuspenseInstanceRetry(\n  instance: SuspenseInstance,\n  callback: () => void,\n) {\n  instance._reactRetry = callback;\n}\n\nexport function getNextHydratableSibling(\n  instance: HydratableInstance,\n): null | HydratableInstance {\n  let node = instance.nextSibling;\n  // Skip non-hydratable nodes.\n  while (\n    node &&\n    node.nodeType !== ELEMENT_NODE &&\n    node.nodeType !== TEXT_NODE &&\n    (!enableSuspenseServerRenderer ||\n      node.nodeType !== COMMENT_NODE ||\n      ((node: any).data !== SUSPENSE_START_DATA &&\n        (node: any).data !== SUSPENSE_PENDING_START_DATA &&\n        (node: any).data !== SUSPENSE_FALLBACK_START_DATA))\n  ) {\n    node = node.nextSibling;\n  }\n  return (node: any);\n}\n\nexport function getFirstHydratableChild(\n  parentInstance: Container | Instance,\n): null | HydratableInstance {\n  let next = parentInstance.firstChild;\n  // Skip non-hydratable nodes.\n  while (\n    next &&\n    next.nodeType !== ELEMENT_NODE &&\n    next.nodeType !== TEXT_NODE &&\n    (!enableSuspenseServerRenderer ||\n      next.nodeType !== COMMENT_NODE ||\n      ((next: any).data !== SUSPENSE_START_DATA &&\n        (next: any).data !== SUSPENSE_FALLBACK_START_DATA &&\n        (next: any).data !== SUSPENSE_PENDING_START_DATA))\n  ) {\n    next = next.nextSibling;\n  }\n  return (next: any);\n}\n\nexport function hydrateInstance(\n  instance: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): null | Array<mixed> {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  let parentNamespace: string;\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  return diffHydratedProperties(\n    instance,\n    type,\n    props,\n    parentNamespace,\n    rootContainerInstance,\n  );\n}\n\nexport function hydrateTextInstance(\n  textInstance: TextInstance,\n  text: string,\n  internalInstanceHandle: Object,\n): boolean {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nexport function getNextHydratableInstanceAfterSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): null | HydratableInstance {\n  let node = suspenseInstance.nextSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = ((node: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling((node: any));\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA) {\n        depth++;\n      }\n    }\n    node = node.nextSibling;\n  }\n  // TODO: Warn, we didn't find the end comment boundary.\n  return null;\n}\n\nexport function didNotMatchHydratedContainerTextInstance(\n  parentContainer: Container,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotMatchHydratedTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotHydrateContainerInstance(\n  parentContainer: Container,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, (instance: any));\n    }\n  }\n}\n\nexport function didNotHydrateInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  instance: HydratableInstance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, (instance: any));\n    }\n  }\n}\n\nexport function didNotFindHydratableContainerInstance(\n  parentContainer: Container,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nexport function didNotFindHydratableContainerTextInstance(\n  parentContainer: Container,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nexport function didNotFindHydratableContainerSuspenseInstance(\n  parentContainer: Container,\n) {\n  if (__DEV__) {\n    // TODO: warnForInsertedHydratedSupsense(parentContainer);\n  }\n}\n\nexport function didNotFindHydratableInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    // TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\n\nexport function handleEventComponent(\n  eventResponder: ReactEventResponder,\n  rootContainerInstance: Container,\n): void {\n  if (enableEventAPI) {\n    const rootElement = rootContainerInstance.ownerDocument;\n    listenToEventResponderEventTypes(\n      eventResponder.targetEventTypes,\n      rootElement,\n    );\n  }\n}\n\nexport function unmountEventComponent(\n  eventResponder: ReactEventResponder,\n  rootContainerInstance: Container,\n  internalInstanceHandle: Object,\n): void {\n  if (enableEventAPI) {\n    // TODO stop listening to targetEventTypes\n    unmountEventResponder(eventResponder, internalInstanceHandle);\n  }\n}\n\nexport function getEventTargetChildElement(\n  type: Symbol | number,\n  props: Props,\n): null | EventTargetChildElement {\n  if (enableEventAPI) {\n    if (type === REACT_EVENT_TARGET_TOUCH_HIT) {\n      const {bottom, left, right, top} = props;\n\n      if (!bottom && !left && !right && !top) {\n        return null;\n      }\n      return {\n        type: 'div',\n        props: {\n          style: {\n            position: 'absolute',\n            zIndex: -1,\n            bottom: bottom ? `-${bottom}px` : '0px',\n            left: left ? `-${left}px` : '0px',\n            right: right ? `-${right}px` : '0px',\n            top: top ? `-${top}px` : '0px',\n          },\n        },\n      };\n    }\n  }\n  return null;\n}\n\nexport function handleEventTarget(\n  type: Symbol | number,\n  props: Props,\n  rootContainerInstance: Container,\n  internalInstanceHandle: Object,\n): boolean {\n  return false;\n}\n\nexport function commitEventTarget(\n  type: Symbol | number,\n  props: Props,\n  instance: Instance,\n  parentInstance: Instance,\n): void {\n  if (enableEventAPI) {\n    if (type === REACT_EVENT_TARGET_TOUCH_HIT) {\n      if (__DEV__ && canUseDOM) {\n        // This is done at DEV time because getComputedStyle will\n        // typically force a style recalculation and force a layout,\n        // reflow -– both of which are sync are expensive.\n        const computedStyles = window.getComputedStyle(parentInstance);\n        const position = computedStyles.getPropertyValue('position');\n        warning(\n          position !== '' && position !== 'static',\n          '<TouchHitTarget> inserts an empty absolutely positioned <div>. ' +\n            'This requires its parent DOM node to be positioned too, but the ' +\n            'parent DOM node was found to have the style \"position\" set to ' +\n            'either no value, or a value of \"static\". Try using a \"position\" ' +\n            'value of \"relative\".',\n        );\n        warning(\n          computedStyles.getPropertyValue('zIndex') !== '',\n          '<TouchHitTarget> inserts an empty <div> with \"z-index\" of \"-1\". ' +\n            'This requires its parent DOM node to have a \"z-index\" great than \"-1\",' +\n            'but the parent DOM node was found to no \"z-index\" value set.' +\n            ' Try using a \"z-index\" value of \"0\" or greater.',\n        );\n      }\n    }\n  }\n}\n","/Users/wxj/locality/my-debug/src/react/packages/react-dom/src/client/validateDOMNesting.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/HostConfigWithNoPersistence.js",["1028"],"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport invariant from 'shared/invariant';\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim(...args: any) {\n  invariant(\n    false,\n    'The current renderer does not support persistence. ' +\n      'This error is likely caused by a bug in React. ' +\n      'Please file an issue.',\n  );\n}\n\n// Persistence (when unsupported)\nexport const supportsPersistence = false;\nexport const cloneInstance = shim;\nexport const createContainerChildSet = shim;\nexport const appendChildToContainerChildSet = shim;\nexport const finalizeContainerChildren = shim;\nexport const replaceContainerChildren = shim;\nexport const cloneHiddenInstance = shim;\nexport const cloneHiddenTextInstance = shim;\nexport const cloneHiddenTouchHitTargetInstance = shim;\n","/Users/wxj/locality/my-debug/src/react/packages/events/ReactGenericBatching.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/ReactControlledComponent.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/EventPluginHub.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/EventBatching.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/EventPropagators.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/EventPluginRegistry.js",["1029","1030","1031","1032"],"/Users/wxj/locality/my-debug/src/react/packages/events/EventPluginUtils.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/accumulateInto.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/forEachAccumulated.js",[],"/Users/wxj/locality/my-debug/src/react/packages/shared/ReactTreeTraversal.js",["1033","1034"],"/Users/wxj/locality/my-debug/src/react/packages/events/EventSystemFlags.js",[],"/Users/wxj/locality/my-debug/src/react/packages/events/SyntheticEvent.js",["1035"],"/Users/wxj/locality/my-debug/src/react/packages/events/TopLevelEventTypes.js",["1036","1037","1038","1039"],{"ruleId":"1040","severity":2,"message":"1041","line":188,"column":23,"nodeType":"1042","messageId":"1043","endLine":188,"endColumn":38},{"ruleId":"1040","severity":2,"message":"1041","line":412,"column":21,"nodeType":"1042","messageId":"1043","endLine":412,"endColumn":36},{"ruleId":"1040","severity":2,"message":"1041","line":555,"column":21,"nodeType":"1042","messageId":"1043","endLine":555,"endColumn":36},{"ruleId":"1040","severity":2,"message":"1041","line":645,"column":36,"nodeType":"1042","messageId":"1043","endLine":645,"endColumn":51},{"ruleId":"1040","severity":2,"message":"1044","line":676,"column":20,"nodeType":"1042","messageId":"1043","endLine":676,"endColumn":30},{"ruleId":"1040","severity":2,"message":"1045","line":703,"column":14,"nodeType":"1042","messageId":"1043","endLine":703,"endColumn":27},{"ruleId":"1040","severity":2,"message":"1041","line":732,"column":22,"nodeType":"1042","messageId":"1043","endLine":732,"endColumn":37},{"ruleId":"1040","severity":2,"message":"1045","line":733,"column":14,"nodeType":"1042","messageId":"1043","endLine":733,"endColumn":27},{"ruleId":"1046","severity":2,"message":"1047","line":136,"column":24,"nodeType":"1048","messageId":"1049","endLine":136,"endColumn":38},{"ruleId":"1050","severity":2,"message":"1051","line":285,"column":49,"nodeType":"1042","messageId":"1052","endLine":285,"endColumn":53},{"ruleId":"1046","severity":2,"message":"1047","line":207,"column":25,"nodeType":"1048","messageId":"1049","endLine":207,"endColumn":39},{"ruleId":"1046","severity":2,"message":"1047","line":345,"column":25,"nodeType":"1048","messageId":"1049","endLine":345,"endColumn":39},{"ruleId":"1040","severity":2,"message":"1053","line":16,"column":56,"nodeType":"1042","messageId":"1043","endLine":16,"endColumn":73},{"ruleId":"1040","severity":2,"message":"1054","line":17,"column":31,"nodeType":"1042","messageId":"1043","endLine":17,"endColumn":40},{"ruleId":"1040","severity":2,"message":"1044","line":17,"column":58,"nodeType":"1042","messageId":"1043","endLine":17,"endColumn":68},{"ruleId":"1040","severity":2,"message":"1053","line":17,"column":9,"nodeType":"1042","messageId":"1043","endLine":17,"endColumn":26},{"ruleId":"1055","severity":2,"message":"1056","line":58,"column":53,"nodeType":"1057","messageId":"1058","endLine":58,"endColumn":54,"suggestions":"1059"},{"ruleId":"1050","severity":2,"message":"1060","line":262,"column":58,"nodeType":"1042","messageId":"1052","endLine":262,"endColumn":66},{"ruleId":"1050","severity":2,"message":"1061","line":362,"column":44,"nodeType":"1042","messageId":"1052","endLine":362,"endColumn":51},{"ruleId":"1050","severity":2,"message":"1062","line":362,"column":53,"nodeType":"1042","messageId":"1052","endLine":362,"endColumn":58},{"ruleId":"1050","severity":2,"message":"1060","line":362,"column":60,"nodeType":"1042","messageId":"1052","endLine":362,"endColumn":68},{"ruleId":"1040","severity":2,"message":"1063","line":64,"column":61,"nodeType":"1042","messageId":"1043","endLine":64,"endColumn":69},{"ruleId":"1064","severity":2,"message":"1065","line":50,"column":17,"nodeType":"1066","messageId":"1067","endLine":50,"endColumn":19},{"ruleId":"1064","severity":2,"message":"1065","line":36,"column":17,"nodeType":"1066","messageId":"1067","endLine":36,"endColumn":19},{"ruleId":"1068","severity":2,"message":"1069","line":66,"column":43,"nodeType":"1070","messageId":"1071","endLine":68,"endColumn":2},{"ruleId":"1046","severity":2,"message":"1047","line":181,"column":21,"nodeType":"1048","messageId":"1049","endLine":181,"endColumn":35},{"ruleId":"1055","severity":2,"message":"1072","line":399,"column":20,"nodeType":"1057","messageId":"1058","endLine":399,"endColumn":21,"suggestions":"1073"},{"ruleId":"1055","severity":2,"message":"1074","line":399,"column":22,"nodeType":"1057","messageId":"1058","endLine":399,"endColumn":23,"suggestions":"1075"},{"ruleId":"1076","severity":2,"message":"1077","line":156,"column":48,"nodeType":"1057","messageId":"1067","endLine":156,"endColumn":64},{"ruleId":"1046","severity":2,"message":"1047","line":310,"column":20,"nodeType":"1048","messageId":"1049","endLine":310,"endColumn":34},{"ruleId":"1046","severity":2,"message":"1047","line":352,"column":40,"nodeType":"1048","messageId":"1049","endLine":352,"endColumn":54},{"ruleId":"1046","severity":2,"message":"1047","line":679,"column":17,"nodeType":"1048","messageId":"1049","endLine":679,"endColumn":31},{"ruleId":"1046","severity":2,"message":"1047","line":680,"column":18,"nodeType":"1048","messageId":"1049","endLine":680,"endColumn":32},{"ruleId":"1046","severity":2,"message":"1047","line":688,"column":23,"nodeType":"1048","messageId":"1049","endLine":688,"endColumn":37},{"ruleId":"1046","severity":2,"message":"1047","line":704,"column":40,"nodeType":"1048","messageId":"1049","endLine":704,"endColumn":54},{"ruleId":"1046","severity":2,"message":"1047","line":721,"column":18,"nodeType":"1048","messageId":"1049","endLine":721,"endColumn":32},{"ruleId":"1046","severity":2,"message":"1047","line":739,"column":22,"nodeType":"1048","messageId":"1049","endLine":739,"endColumn":36},{"ruleId":"1046","severity":2,"message":"1047","line":740,"column":37,"nodeType":"1048","messageId":"1049","endLine":740,"endColumn":51},{"ruleId":"1046","severity":2,"message":"1047","line":751,"column":22,"nodeType":"1048","messageId":"1049","endLine":751,"endColumn":36},{"ruleId":"1046","severity":2,"message":"1047","line":793,"column":40,"nodeType":"1048","messageId":"1049","endLine":793,"endColumn":54},{"ruleId":"1046","severity":2,"message":"1047","line":874,"column":32,"nodeType":"1048","messageId":"1049","endLine":874,"endColumn":46},{"ruleId":"1046","severity":2,"message":"1047","line":995,"column":19,"nodeType":"1048","messageId":"1049","endLine":995,"endColumn":33},{"ruleId":"1046","severity":2,"message":"1047","line":1024,"column":40,"nodeType":"1048","messageId":"1049","endLine":1024,"endColumn":54},{"ruleId":"1050","severity":2,"message":"1062","line":1222,"column":3,"nodeType":"1042","messageId":"1052","endLine":1222,"endColumn":16},{"ruleId":"1050","severity":2,"message":"1078","line":20,"column":35,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":44},{"ruleId":"1050","severity":2,"message":"1079","line":20,"column":46,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":52},{"ruleId":"1050","severity":2,"message":"1080","line":20,"column":54,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":55},{"ruleId":"1050","severity":2,"message":"1081","line":20,"column":57,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":58},{"ruleId":"1050","severity":2,"message":"1082","line":20,"column":60,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":61},{"ruleId":"1050","severity":2,"message":"1083","line":20,"column":63,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":64},{"ruleId":"1050","severity":2,"message":"1084","line":20,"column":66,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":67},{"ruleId":"1050","severity":2,"message":"1085","line":20,"column":69,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":70},{"ruleId":"1050","severity":2,"message":"1086","line":8,"column":8,"nodeType":"1042","messageId":"1052","endLine":8,"endColumn":13},{"ruleId":"1046","severity":2,"message":"1047","line":18,"column":27,"nodeType":"1048","messageId":"1049","endLine":18,"endColumn":41},{"ruleId":"1050","severity":2,"message":"1087","line":48,"column":23,"nodeType":"1042","messageId":"1052","endLine":48,"endColumn":37},{"ruleId":"1050","severity":2,"message":"1088","line":67,"column":48,"nodeType":"1042","messageId":"1052","endLine":67,"endColumn":56},{"ruleId":"1050","severity":2,"message":"1089","line":67,"column":58,"nodeType":"1042","messageId":"1052","endLine":67,"endColumn":68},{"ruleId":"1050","severity":2,"message":"1090","line":86,"column":5,"nodeType":"1042","messageId":"1052","endLine":86,"endColumn":18},{"ruleId":"1050","severity":2,"message":"1088","line":87,"column":5,"nodeType":"1042","messageId":"1052","endLine":87,"endColumn":13},{"ruleId":"1050","severity":2,"message":"1089","line":88,"column":5,"nodeType":"1042","messageId":"1052","endLine":88,"endColumn":15},{"ruleId":"1050","severity":2,"message":"1091","line":107,"column":5,"nodeType":"1042","messageId":"1052","endLine":107,"endColumn":17},{"ruleId":"1050","severity":2,"message":"1088","line":108,"column":5,"nodeType":"1042","messageId":"1052","endLine":108,"endColumn":13},{"ruleId":"1050","severity":2,"message":"1089","line":109,"column":5,"nodeType":"1042","messageId":"1052","endLine":109,"endColumn":15},{"ruleId":"1092","message":"1093","line":27,"column":5,"endLine":27,"endColumn":74,"severity":2,"nodeType":null},{"ruleId":"1046","severity":2,"message":"1047","line":90,"column":38,"nodeType":"1048","messageId":"1049","endLine":90,"endColumn":52},{"ruleId":"1046","severity":2,"message":"1047","line":202,"column":15,"nodeType":"1048","messageId":"1049","endLine":202,"endColumn":29},{"ruleId":"1046","severity":2,"message":"1047","line":211,"column":15,"nodeType":"1048","messageId":"1049","endLine":211,"endColumn":29},{"ruleId":"1046","severity":2,"message":"1047","line":213,"column":22,"nodeType":"1048","messageId":"1049","endLine":213,"endColumn":36},{"ruleId":"1046","severity":2,"message":"1047","line":245,"column":13,"nodeType":"1048","messageId":"1049","endLine":245,"endColumn":27},{"ruleId":"1046","severity":2,"message":"1047","line":245,"column":46,"nodeType":"1048","messageId":"1049","endLine":245,"endColumn":60},{"ruleId":"1046","severity":2,"message":"1047","line":328,"column":15,"nodeType":"1048","messageId":"1049","endLine":328,"endColumn":29},{"ruleId":"1050","severity":2,"message":"1062","line":149,"column":52,"nodeType":"1042","messageId":"1052","endLine":149,"endColumn":65},{"ruleId":"1046","severity":2,"message":"1047","line":65,"column":10,"nodeType":"1048","messageId":"1049","endLine":65,"endColumn":24},{"ruleId":"1046","severity":2,"message":"1047","line":32,"column":19,"nodeType":"1048","messageId":"1049","endLine":32,"endColumn":33},{"ruleId":"1046","severity":2,"message":"1047","line":62,"column":17,"nodeType":"1048","messageId":"1049","endLine":62,"endColumn":31},{"ruleId":"1046","severity":2,"message":"1047","line":27,"column":45,"nodeType":"1048","messageId":"1049","endLine":27,"endColumn":59},{"ruleId":"1046","severity":2,"message":"1047","line":57,"column":46,"nodeType":"1048","messageId":"1049","endLine":57,"endColumn":60},{"ruleId":"1050","severity":2,"message":"1094","line":188,"column":59,"nodeType":"1042","messageId":"1052","endLine":188,"endColumn":69},{"ruleId":"1095","severity":2,"message":"1096","line":22,"column":7,"nodeType":"1097","messageId":"1098","endLine":22,"endColumn":20},{"ruleId":"1099","severity":2,"message":"1100","line":307,"column":7,"nodeType":"1101","messageId":"1067","endLine":307,"endColumn":39},{"ruleId":"1099","severity":2,"message":"1100","line":317,"column":7,"nodeType":"1101","messageId":"1067","endLine":317,"endColumn":38},{"ruleId":"1040","severity":2,"message":"1102","line":46,"column":24,"nodeType":"1042","messageId":"1043","endLine":46,"endColumn":30},{"ruleId":"1040","severity":2,"message":"1102","line":47,"column":25,"nodeType":"1042","messageId":"1043","endLine":47,"endColumn":31},{"ruleId":"1040","severity":2,"message":"1102","line":52,"column":14,"nodeType":"1042","messageId":"1043","endLine":52,"endColumn":20},{"ruleId":"1040","severity":2,"message":"1102","line":91,"column":54,"nodeType":"1042","messageId":"1043","endLine":91,"endColumn":60},{"ruleId":"1040","severity":2,"message":"1103","line":229,"column":40,"nodeType":"1042","messageId":"1043","endLine":229,"endColumn":49},{"ruleId":"1040","severity":2,"message":"1102","line":258,"column":9,"nodeType":"1042","messageId":"1043","endLine":258,"endColumn":15},{"ruleId":"1040","severity":2,"message":"1102","line":287,"column":30,"nodeType":"1042","messageId":"1043","endLine":287,"endColumn":36},{"ruleId":"1040","severity":2,"message":"1102","line":294,"column":24,"nodeType":"1042","messageId":"1043","endLine":294,"endColumn":30},{"ruleId":"1040","severity":2,"message":"1102","line":295,"column":25,"nodeType":"1042","messageId":"1043","endLine":295,"endColumn":31},{"ruleId":"1099","severity":2,"message":"1100","line":38,"column":7,"nodeType":"1101","messageId":"1067","endLine":38,"endColumn":39},{"ruleId":"1099","severity":2,"message":"1100","line":39,"column":7,"nodeType":"1101","messageId":"1067","endLine":39,"endColumn":41},{"ruleId":"1099","severity":2,"message":"1100","line":40,"column":7,"nodeType":"1101","messageId":"1067","endLine":40,"endColumn":49},{"ruleId":"1099","severity":2,"message":"1100","line":41,"column":7,"nodeType":"1101","messageId":"1067","endLine":41,"endColumn":28},{"ruleId":"1099","severity":2,"message":"1100","line":166,"column":11,"nodeType":"1101","messageId":"1067","endLine":166,"endColumn":75},{"ruleId":"1046","severity":2,"message":"1047","line":53,"column":35,"nodeType":"1048","messageId":"1049","endLine":53,"endColumn":49},{"ruleId":"1046","severity":2,"message":"1047","line":56,"column":58,"nodeType":"1048","messageId":"1049","endLine":56,"endColumn":72},{"ruleId":"1046","severity":2,"message":"1047","line":152,"column":31,"nodeType":"1048","messageId":"1049","endLine":152,"endColumn":45},{"ruleId":"1040","severity":2,"message":"1041","line":95,"column":21,"nodeType":"1042","messageId":"1043","endLine":95,"endColumn":36},{"ruleId":"1040","severity":2,"message":"1041","line":165,"column":21,"nodeType":"1042","messageId":"1043","endLine":165,"endColumn":36},{"ruleId":"1040","severity":2,"message":"1041","line":287,"column":21,"nodeType":"1042","messageId":"1043","endLine":287,"endColumn":36},{"ruleId":"1040","severity":2,"message":"1041","line":322,"column":4,"nodeType":"1042","messageId":"1043","endLine":322,"endColumn":19},{"ruleId":"1050","severity":2,"message":"1104","line":349,"column":25,"nodeType":"1042","messageId":"1052","endLine":349,"endColumn":30},{"ruleId":"1055","severity":2,"message":"1056","line":10,"column":34,"nodeType":"1057","messageId":"1058","endLine":10,"endColumn":35,"suggestions":"1105"},{"ruleId":"1076","severity":2,"message":"1106","line":30,"column":30,"nodeType":"1057","messageId":"1067","endLine":30,"endColumn":153},{"ruleId":"1055","severity":2,"message":"1074","line":30,"column":149,"nodeType":"1057","messageId":"1058","endLine":30,"endColumn":150,"suggestions":"1107"},{"ruleId":"1050","severity":2,"message":"1108","line":31,"column":38,"nodeType":"1042","messageId":"1052","endLine":31,"endColumn":51},{"ruleId":"1050","severity":2,"message":"1108","line":48,"column":40,"nodeType":"1042","messageId":"1052","endLine":48,"endColumn":53},{"ruleId":"1040","severity":2,"message":"1109","line":10,"column":20,"nodeType":"1042","messageId":"1043","endLine":10,"endColumn":33},{"ruleId":"1040","severity":2,"message":"1109","line":21,"column":33,"nodeType":"1042","messageId":"1043","endLine":21,"endColumn":46},{"ruleId":"1040","severity":2,"message":"1109","line":25,"column":49,"nodeType":"1042","messageId":"1043","endLine":25,"endColumn":62},{"ruleId":"1046","severity":2,"message":"1047","line":39,"column":24,"nodeType":"1048","messageId":"1049","endLine":39,"endColumn":38},{"ruleId":"1046","severity":2,"message":"1047","line":33,"column":26,"nodeType":"1048","messageId":"1049","endLine":33,"endColumn":40},{"ruleId":"1046","severity":2,"message":"1047","line":50,"column":26,"nodeType":"1048","messageId":"1049","endLine":50,"endColumn":40},{"ruleId":"1046","severity":2,"message":"1047","line":64,"column":27,"nodeType":"1048","messageId":"1049","endLine":64,"endColumn":41},{"ruleId":"1050","severity":2,"message":"1110","line":78,"column":46,"nodeType":"1042","messageId":"1052","endLine":78,"endColumn":51},{"ruleId":"1050","severity":2,"message":"1110","line":91,"column":51,"nodeType":"1042","messageId":"1052","endLine":91,"endColumn":56},{"ruleId":"1040","severity":2,"message":"1041","line":66,"column":38,"nodeType":"1042","messageId":"1043","endLine":66,"endColumn":53},{"ruleId":"1111","severity":2,"message":"1112","line":118,"column":10,"nodeType":"1057","messageId":"1067","endLine":118,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":246,"column":10,"nodeType":"1057","messageId":"1067","endLine":246,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":279,"column":10,"nodeType":"1057","messageId":"1067","endLine":279,"endColumn":14},{"ruleId":"1050","severity":2,"message":"1051","line":42,"column":3,"nodeType":"1042","messageId":"1052","endLine":42,"endColumn":22},{"ruleId":"1050","severity":2,"message":"1113","line":43,"column":3,"nodeType":"1042","messageId":"1052","endLine":43,"endColumn":54},{"ruleId":"1050","severity":2,"message":"1114","line":44,"column":3,"nodeType":"1042","messageId":"1052","endLine":44,"endColumn":19},{"ruleId":"1050","severity":2,"message":"1080","line":45,"column":3,"nodeType":"1042","messageId":"1052","endLine":45,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1081","line":46,"column":3,"nodeType":"1042","messageId":"1052","endLine":46,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1082","line":47,"column":3,"nodeType":"1042","messageId":"1052","endLine":47,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1083","line":48,"column":3,"nodeType":"1042","messageId":"1052","endLine":48,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1084","line":49,"column":3,"nodeType":"1042","messageId":"1052","endLine":49,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1085","line":50,"column":3,"nodeType":"1042","messageId":"1052","endLine":50,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1051","line":76,"column":3,"nodeType":"1042","messageId":"1052","endLine":76,"endColumn":22},{"ruleId":"1050","severity":2,"message":"1113","line":77,"column":3,"nodeType":"1042","messageId":"1052","endLine":77,"endColumn":53},{"ruleId":"1050","severity":2,"message":"1114","line":78,"column":3,"nodeType":"1042","messageId":"1052","endLine":78,"endColumn":19},{"ruleId":"1050","severity":2,"message":"1080","line":79,"column":3,"nodeType":"1042","messageId":"1052","endLine":79,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1081","line":80,"column":3,"nodeType":"1042","messageId":"1052","endLine":80,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1082","line":81,"column":3,"nodeType":"1042","messageId":"1052","endLine":81,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1083","line":82,"column":3,"nodeType":"1042","messageId":"1052","endLine":82,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1084","line":83,"column":3,"nodeType":"1042","messageId":"1052","endLine":83,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1085","line":84,"column":3,"nodeType":"1042","messageId":"1052","endLine":84,"endColumn":7},{"ruleId":"1046","severity":2,"message":"1047","line":85,"column":19,"nodeType":"1048","messageId":"1049","endLine":85,"endColumn":33},{"ruleId":"1050","severity":2,"message":"1115","line":604,"column":3,"nodeType":"1042","messageId":"1052","endLine":604,"endColumn":39},{"ruleId":"1050","severity":2,"message":"1116","line":10,"column":8,"nodeType":"1042","messageId":"1052","endLine":10,"endColumn":17},{"ruleId":"1111","severity":2,"message":"1112","line":75,"column":17,"nodeType":"1057","messageId":"1067","endLine":75,"endColumn":21},{"ruleId":"1111","severity":2,"message":"1112","line":78,"column":12,"nodeType":"1057","messageId":"1067","endLine":78,"endColumn":16},{"ruleId":"1111","severity":2,"message":"1112","line":104,"column":12,"nodeType":"1057","messageId":"1067","endLine":104,"endColumn":16},{"ruleId":"1050","severity":2,"message":"1117","line":38,"column":3,"nodeType":"1042","messageId":"1052","endLine":38,"endColumn":30},{"ruleId":"1050","severity":2,"message":"1080","line":16,"column":3,"nodeType":"1042","messageId":"1052","endLine":16,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1081","line":17,"column":3,"nodeType":"1042","messageId":"1052","endLine":17,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1082","line":18,"column":3,"nodeType":"1042","messageId":"1052","endLine":18,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1083","line":19,"column":3,"nodeType":"1042","messageId":"1052","endLine":19,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1084","line":20,"column":3,"nodeType":"1042","messageId":"1052","endLine":20,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1085","line":21,"column":3,"nodeType":"1042","messageId":"1052","endLine":21,"endColumn":7},{"ruleId":"1050","severity":2,"message":"1080","line":65,"column":7,"nodeType":"1042","messageId":"1052","endLine":65,"endColumn":11},{"ruleId":"1050","severity":2,"message":"1081","line":66,"column":7,"nodeType":"1042","messageId":"1052","endLine":66,"endColumn":11},{"ruleId":"1050","severity":2,"message":"1082","line":67,"column":7,"nodeType":"1042","messageId":"1052","endLine":67,"endColumn":11},{"ruleId":"1050","severity":2,"message":"1083","line":68,"column":7,"nodeType":"1042","messageId":"1052","endLine":68,"endColumn":11},{"ruleId":"1050","severity":2,"message":"1084","line":69,"column":7,"nodeType":"1042","messageId":"1052","endLine":69,"endColumn":11},{"ruleId":"1050","severity":2,"message":"1085","line":70,"column":7,"nodeType":"1042","messageId":"1052","endLine":70,"endColumn":11},{"ruleId":"1046","severity":2,"message":"1047","line":125,"column":18,"nodeType":"1048","messageId":"1049","endLine":125,"endColumn":32},{"ruleId":"1050","severity":2,"message":"1118","line":381,"column":3,"nodeType":"1042","messageId":"1052","endLine":381,"endColumn":33},{"ruleId":"1040","severity":2,"message":"1119","line":31,"column":20,"nodeType":"1042","messageId":"1043","endLine":31,"endColumn":38},{"ruleId":"1040","severity":2,"message":"1119","line":43,"column":33,"nodeType":"1042","messageId":"1043","endLine":43,"endColumn":51},{"ruleId":"1040","severity":2,"message":"1119","line":44,"column":36,"nodeType":"1042","messageId":"1043","endLine":44,"endColumn":54},{"ruleId":"1040","severity":2,"message":"1119","line":45,"column":30,"nodeType":"1042","messageId":"1043","endLine":45,"endColumn":48},{"ruleId":"1040","severity":2,"message":"1119","line":46,"column":27,"nodeType":"1042","messageId":"1043","endLine":46,"endColumn":45},{"ruleId":"1040","severity":2,"message":"1119","line":47,"column":28,"nodeType":"1042","messageId":"1043","endLine":47,"endColumn":46},{"ruleId":"1040","severity":2,"message":"1119","line":49,"column":26,"nodeType":"1042","messageId":"1043","endLine":49,"endColumn":44},{"ruleId":"1040","severity":2,"message":"1119","line":60,"column":44,"nodeType":"1042","messageId":"1043","endLine":60,"endColumn":62},{"ruleId":"1040","severity":2,"message":"1119","line":95,"column":23,"nodeType":"1042","messageId":"1043","endLine":95,"endColumn":41},{"ruleId":"1040","severity":2,"message":"1119","line":103,"column":23,"nodeType":"1042","messageId":"1043","endLine":103,"endColumn":41},{"ruleId":"1111","severity":2,"message":"1112","line":813,"column":14,"nodeType":"1057","messageId":"1067","endLine":813,"endColumn":18},{"ruleId":"1050","severity":2,"message":"1120","line":919,"column":3,"nodeType":"1042","messageId":"1052","endLine":919,"endColumn":32},{"ruleId":"1050","severity":2,"message":"1118","line":1809,"column":3,"nodeType":"1042","messageId":"1052","endLine":1809,"endColumn":33},{"ruleId":"1050","severity":2,"message":"1121","line":233,"column":38,"nodeType":"1042","messageId":"1052","endLine":233,"endColumn":68},{"ruleId":"1040","severity":2,"message":"1041","line":233,"column":48,"nodeType":"1042","messageId":"1043","endLine":233,"endColumn":63},{"ruleId":"1111","severity":2,"message":"1112","line":993,"column":10,"nodeType":"1057","messageId":"1067","endLine":993,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":1424,"column":12,"nodeType":"1057","messageId":"1067","endLine":1424,"endColumn":16},{"ruleId":"1099","severity":2,"message":"1100","line":1571,"column":9,"nodeType":"1101","messageId":"1067","endLine":1571,"endColumn":33},{"ruleId":"1099","severity":2,"message":"1100","line":1572,"column":9,"nodeType":"1101","messageId":"1067","endLine":1572,"endColumn":42},{"ruleId":"1050","severity":2,"message":"1120","line":1686,"column":3,"nodeType":"1042","messageId":"1052","endLine":1686,"endColumn":32},{"ruleId":"1050","severity":2,"message":"1122","line":114,"column":5,"nodeType":"1042","messageId":"1052","endLine":114,"endColumn":35},{"ruleId":"1050","severity":2,"message":"1123","line":115,"column":5,"nodeType":"1042","messageId":"1052","endLine":115,"endColumn":22},{"ruleId":"1050","severity":2,"message":"1124","line":146,"column":34,"nodeType":"1042","messageId":"1052","endLine":146,"endColumn":55},{"ruleId":"1125","severity":2,"message":"1126","line":215,"column":7,"nodeType":"1042","messageId":"1127","endLine":215,"endColumn":15,"fix":"1128"},{"ruleId":"1125","severity":2,"message":"1126","line":300,"column":7,"nodeType":"1042","messageId":"1127","endLine":300,"endColumn":15,"fix":"1129"},{"ruleId":"1050","severity":2,"message":"1124","line":484,"column":34,"nodeType":"1042","messageId":"1052","endLine":484,"endColumn":55},{"ruleId":"1050","severity":2,"message":"1130","line":488,"column":5,"nodeType":"1042","messageId":"1052","endLine":488,"endColumn":19},{"ruleId":"1050","severity":2,"message":"1124","line":489,"column":5,"nodeType":"1042","messageId":"1052","endLine":489,"endColumn":26},{"ruleId":"1050","severity":2,"message":"1131","line":490,"column":5,"nodeType":"1042","messageId":"1052","endLine":490,"endColumn":15},{"ruleId":"1050","severity":2,"message":"1132","line":491,"column":5,"nodeType":"1042","messageId":"1052","endLine":491,"endColumn":20},{"ruleId":"1050","severity":2,"message":"1133","line":492,"column":5,"nodeType":"1042","messageId":"1052","endLine":492,"endColumn":37},{"ruleId":"1050","severity":2,"message":"1130","line":497,"column":5,"nodeType":"1042","messageId":"1052","endLine":497,"endColumn":19},{"ruleId":"1050","severity":2,"message":"1124","line":498,"column":5,"nodeType":"1042","messageId":"1052","endLine":498,"endColumn":26},{"ruleId":"1050","severity":2,"message":"1134","line":499,"column":5,"nodeType":"1042","messageId":"1052","endLine":499,"endColumn":20},{"ruleId":"1050","severity":2,"message":"1135","line":500,"column":5,"nodeType":"1042","messageId":"1052","endLine":500,"endColumn":20},{"ruleId":"1099","severity":2,"message":"1100","line":409,"column":9,"nodeType":"1101","messageId":"1067","endLine":409,"endColumn":33},{"ruleId":"1099","severity":2,"message":"1100","line":410,"column":9,"nodeType":"1101","messageId":"1067","endLine":410,"endColumn":42},{"ruleId":"1099","severity":2,"message":"1100","line":411,"column":9,"nodeType":"1101","messageId":"1067","endLine":411,"endColumn":51},{"ruleId":"1050","severity":2,"message":"1115","line":440,"column":3,"nodeType":"1042","messageId":"1052","endLine":440,"endColumn":39},{"ruleId":"1111","severity":2,"message":"1112","line":611,"column":12,"nodeType":"1057","messageId":"1067","endLine":611,"endColumn":16},{"ruleId":"1046","severity":2,"message":"1047","line":672,"column":18,"nodeType":"1048","messageId":"1049","endLine":672,"endColumn":32},{"ruleId":"1111","severity":2,"message":"1112","line":768,"column":10,"nodeType":"1057","messageId":"1067","endLine":768,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":889,"column":20,"nodeType":"1057","messageId":"1067","endLine":889,"endColumn":24},{"ruleId":"1111","severity":2,"message":"1112","line":972,"column":10,"nodeType":"1057","messageId":"1067","endLine":972,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":1024,"column":10,"nodeType":"1057","messageId":"1067","endLine":1024,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":1027,"column":26,"nodeType":"1057","messageId":"1067","endLine":1027,"endColumn":30},{"ruleId":"1050","severity":2,"message":"1104","line":54,"column":37,"nodeType":"1042","messageId":"1052","endLine":54,"endColumn":49},{"ruleId":"1050","severity":2,"message":"1104","line":32,"column":29,"nodeType":"1042","messageId":"1052","endLine":32,"endColumn":41},{"ruleId":"1050","severity":2,"message":"1121","line":32,"column":43,"nodeType":"1042","messageId":"1052","endLine":32,"endColumn":56},{"ruleId":"1050","severity":2,"message":"1104","line":33,"column":33,"nodeType":"1042","messageId":"1052","endLine":33,"endColumn":45},{"ruleId":"1050","severity":2,"message":"1121","line":33,"column":47,"nodeType":"1042","messageId":"1052","endLine":33,"endColumn":60},{"ruleId":"1050","severity":2,"message":"1104","line":34,"column":30,"nodeType":"1042","messageId":"1052","endLine":34,"endColumn":42},{"ruleId":"1050","severity":2,"message":"1121","line":34,"column":44,"nodeType":"1042","messageId":"1052","endLine":34,"endColumn":57},{"ruleId":"1040","severity":2,"message":"1136","line":48,"column":15,"nodeType":"1042","messageId":"1043","endLine":48,"endColumn":16},{"ruleId":"1040","severity":2,"message":"1136","line":49,"column":27,"nodeType":"1042","messageId":"1043","endLine":49,"endColumn":28},{"ruleId":"1040","severity":2,"message":"1136","line":51,"column":6,"nodeType":"1042","messageId":"1043","endLine":51,"endColumn":7},{"ruleId":"1040","severity":2,"message":"1137","line":52,"column":12,"nodeType":"1042","messageId":"1043","endLine":52,"endColumn":13},{"ruleId":"1040","severity":2,"message":"1137","line":52,"column":36,"nodeType":"1042","messageId":"1043","endLine":52,"endColumn":37},{"ruleId":"1040","severity":2,"message":"1137","line":52,"column":41,"nodeType":"1042","messageId":"1043","endLine":52,"endColumn":42},{"ruleId":"1040","severity":2,"message":"1137","line":52,"column":46,"nodeType":"1042","messageId":"1043","endLine":52,"endColumn":47},{"ruleId":"1040","severity":2,"message":"1137","line":52,"column":75,"nodeType":"1042","messageId":"1043","endLine":52,"endColumn":76},{"ruleId":"1040","severity":2,"message":"1137","line":53,"column":14,"nodeType":"1042","messageId":"1043","endLine":53,"endColumn":15},{"ruleId":"1040","severity":2,"message":"1138","line":53,"column":17,"nodeType":"1042","messageId":"1043","endLine":53,"endColumn":18},{"ruleId":"1040","severity":2,"message":"1139","line":53,"column":20,"nodeType":"1042","messageId":"1043","endLine":53,"endColumn":21},{"ruleId":"1040","severity":2,"message":"1137","line":54,"column":15,"nodeType":"1042","messageId":"1043","endLine":54,"endColumn":16},{"ruleId":"1040","severity":2,"message":"1139","line":54,"column":18,"nodeType":"1042","messageId":"1043","endLine":54,"endColumn":19},{"ruleId":"1040","severity":2,"message":"1137","line":54,"column":24,"nodeType":"1042","messageId":"1043","endLine":54,"endColumn":25},{"ruleId":"1040","severity":2,"message":"1138","line":55,"column":17,"nodeType":"1042","messageId":"1043","endLine":55,"endColumn":18},{"ruleId":"1040","severity":2,"message":"1138","line":56,"column":13,"nodeType":"1042","messageId":"1043","endLine":56,"endColumn":14},{"ruleId":"1040","severity":2,"message":"1137","line":56,"column":19,"nodeType":"1042","messageId":"1043","endLine":56,"endColumn":20},{"ruleId":"1040","severity":2,"message":"1137","line":57,"column":7,"nodeType":"1042","messageId":"1043","endLine":57,"endColumn":8},{"ruleId":"1040","severity":2,"message":"1139","line":57,"column":19,"nodeType":"1042","messageId":"1043","endLine":57,"endColumn":20},{"ruleId":"1040","severity":2,"message":"1136","line":58,"column":14,"nodeType":"1042","messageId":"1043","endLine":58,"endColumn":15},{"ruleId":"1040","severity":2,"message":"1136","line":59,"column":27,"nodeType":"1042","messageId":"1043","endLine":59,"endColumn":28},{"ruleId":"1040","severity":2,"message":"1136","line":61,"column":6,"nodeType":"1042","messageId":"1043","endLine":61,"endColumn":7},{"ruleId":"1040","severity":2,"message":"1136","line":62,"column":10,"nodeType":"1042","messageId":"1043","endLine":62,"endColumn":11},{"ruleId":"1040","severity":2,"message":"1136","line":62,"column":27,"nodeType":"1042","messageId":"1043","endLine":62,"endColumn":28},{"ruleId":"1040","severity":2,"message":"1136","line":62,"column":41,"nodeType":"1042","messageId":"1043","endLine":62,"endColumn":42},{"ruleId":"1040","severity":2,"message":"1136","line":71,"column":15,"nodeType":"1042","messageId":"1043","endLine":71,"endColumn":16},{"ruleId":"1040","severity":2,"message":"1136","line":71,"column":28,"nodeType":"1042","messageId":"1043","endLine":71,"endColumn":29},{"ruleId":"1040","severity":2,"message":"1136","line":71,"column":66,"nodeType":"1042","messageId":"1043","endLine":71,"endColumn":67},{"ruleId":"1040","severity":2,"message":"1136","line":72,"column":11,"nodeType":"1042","messageId":"1043","endLine":72,"endColumn":12},{"ruleId":"1040","severity":2,"message":"1136","line":72,"column":32,"nodeType":"1042","messageId":"1043","endLine":72,"endColumn":33},{"ruleId":"1040","severity":2,"message":"1136","line":72,"column":70,"nodeType":"1042","messageId":"1043","endLine":72,"endColumn":71},{"ruleId":"1040","severity":2,"message":"1136","line":73,"column":23,"nodeType":"1042","messageId":"1043","endLine":73,"endColumn":24},{"ruleId":"1040","severity":2,"message":"1136","line":74,"column":20,"nodeType":"1042","messageId":"1043","endLine":74,"endColumn":21},{"ruleId":"1040","severity":2,"message":"1136","line":74,"column":40,"nodeType":"1042","messageId":"1043","endLine":74,"endColumn":41},{"ruleId":"1040","severity":2,"message":"1136","line":75,"column":19,"nodeType":"1042","messageId":"1043","endLine":75,"endColumn":20},{"ruleId":"1040","severity":2,"message":"1136","line":78,"column":17,"nodeType":"1042","messageId":"1043","endLine":78,"endColumn":18},{"ruleId":"1040","severity":2,"message":"1136","line":78,"column":27,"nodeType":"1042","messageId":"1043","endLine":78,"endColumn":28},{"ruleId":"1040","severity":2,"message":"1136","line":78,"column":52,"nodeType":"1042","messageId":"1043","endLine":78,"endColumn":53},{"ruleId":"1050","severity":2,"message":"1140","line":624,"column":3,"nodeType":"1042","messageId":"1052","endLine":624,"endColumn":16},{"ruleId":"1050","severity":2,"message":"1141","line":625,"column":3,"nodeType":"1042","messageId":"1052","endLine":625,"endColumn":16},{"ruleId":"1050","severity":2,"message":"1142","line":824,"column":23,"nodeType":"1042","messageId":"1052","endLine":824,"endColumn":38},{"ruleId":"1046","severity":2,"message":"1047","line":920,"column":19,"nodeType":"1048","messageId":"1049","endLine":920,"endColumn":33},{"ruleId":"1050","severity":2,"message":"1110","line":986,"column":29,"nodeType":"1042","messageId":"1052","endLine":986,"endColumn":37},{"ruleId":"1050","severity":2,"message":"1143","line":986,"column":39,"nodeType":"1042","messageId":"1052","endLine":986,"endColumn":72},{"ruleId":"1099","severity":2,"message":"1100","line":136,"column":13,"nodeType":"1101","messageId":"1067","endLine":136,"endColumn":37},{"ruleId":"1099","severity":2,"message":"1100","line":137,"column":13,"nodeType":"1101","messageId":"1067","endLine":137,"endColumn":46},{"ruleId":"1099","severity":2,"message":"1100","line":141,"column":13,"nodeType":"1101","messageId":"1067","endLine":141,"endColumn":45},{"ruleId":"1099","severity":2,"message":"1100","line":156,"column":13,"nodeType":"1101","messageId":"1067","endLine":156,"endColumn":37},{"ruleId":"1099","severity":2,"message":"1100","line":157,"column":13,"nodeType":"1101","messageId":"1067","endLine":157,"endColumn":46},{"ruleId":"1099","severity":2,"message":"1100","line":167,"column":13,"nodeType":"1101","messageId":"1067","endLine":167,"endColumn":45},{"ruleId":"1050","severity":2,"message":"1144","line":53,"column":26,"nodeType":"1042","messageId":"1052","endLine":53,"endColumn":38},{"ruleId":"1040","severity":2,"message":"1145","line":441,"column":15,"nodeType":"1042","messageId":"1043","endLine":441,"endColumn":23},{"ruleId":"1099","severity":2,"message":"1100","line":709,"column":11,"nodeType":"1101","messageId":"1067","endLine":709,"endColumn":33},{"ruleId":"1040","severity":2,"message":"1145","line":921,"column":26,"nodeType":"1042","messageId":"1043","endLine":921,"endColumn":34},{"ruleId":"1050","severity":2,"message":"1115","line":513,"column":3,"nodeType":"1042","messageId":"1052","endLine":513,"endColumn":39},{"ruleId":"1050","severity":2,"message":"1146","line":15,"column":33,"nodeType":"1042","messageId":"1052","endLine":15,"endColumn":61},{"ruleId":"1040","severity":2,"message":"1103","line":98,"column":29,"nodeType":"1042","messageId":"1043","endLine":98,"endColumn":38},{"ruleId":"1050","severity":2,"message":"1133","line":184,"column":3,"nodeType":"1042","messageId":"1052","endLine":184,"endColumn":35},{"ruleId":"1050","severity":2,"message":"1147","line":254,"column":34,"nodeType":"1042","messageId":"1052","endLine":254,"endColumn":58},{"ruleId":"1050","severity":2,"message":"1147","line":260,"column":34,"nodeType":"1042","messageId":"1052","endLine":260,"endColumn":58},{"ruleId":"1050","severity":2,"message":"1148","line":317,"column":3,"nodeType":"1042","messageId":"1052","endLine":317,"endColumn":27},{"ruleId":"1050","severity":2,"message":"1149","line":418,"column":3,"nodeType":"1042","messageId":"1052","endLine":418,"endColumn":33},{"ruleId":"1050","severity":2,"message":"1149","line":441,"column":3,"nodeType":"1042","messageId":"1052","endLine":441,"endColumn":33},{"ruleId":"1046","severity":2,"message":"1047","line":601,"column":15,"nodeType":"1048","messageId":"1049","endLine":601,"endColumn":29},{"ruleId":"1050","severity":2,"message":"1062","line":623,"column":3,"nodeType":"1042","messageId":"1052","endLine":623,"endColumn":15},{"ruleId":"1050","severity":2,"message":"1150","line":851,"column":3,"nodeType":"1042","messageId":"1052","endLine":851,"endColumn":29},{"ruleId":"1050","severity":2,"message":"1151","line":884,"column":3,"nodeType":"1042","messageId":"1052","endLine":884,"endColumn":27},{"ruleId":"1050","severity":2,"message":"1131","line":945,"column":3,"nodeType":"1042","messageId":"1052","endLine":945,"endColumn":24},{"ruleId":"1050","severity":2,"message":"1062","line":946,"column":3,"nodeType":"1042","messageId":"1052","endLine":946,"endColumn":15},{"ruleId":"1050","severity":2,"message":"1133","line":947,"column":3,"nodeType":"1042","messageId":"1052","endLine":947,"endColumn":35},{"ruleId":"1050","severity":2,"message":"1149","line":948,"column":3,"nodeType":"1042","messageId":"1052","endLine":948,"endColumn":33},{"ruleId":"1050","severity":2,"message":"1152","line":15,"column":18,"nodeType":"1042","messageId":"1052","endLine":15,"endColumn":22},{"ruleId":"1046","severity":2,"message":"1047","line":91,"column":31,"nodeType":"1048","messageId":"1049","endLine":91,"endColumn":45},{"ruleId":"1046","severity":2,"message":"1047","line":101,"column":35,"nodeType":"1048","messageId":"1049","endLine":101,"endColumn":49},{"ruleId":"1046","severity":2,"message":"1047","line":226,"column":33,"nodeType":"1048","messageId":"1049","endLine":226,"endColumn":47},{"ruleId":"1046","severity":2,"message":"1047","line":231,"column":23,"nodeType":"1048","messageId":"1049","endLine":231,"endColumn":37},{"ruleId":"1111","severity":2,"message":"1112","line":111,"column":10,"nodeType":"1057","messageId":"1067","endLine":111,"endColumn":14},{"ruleId":"1111","severity":2,"message":"1112","line":126,"column":10,"nodeType":"1057","messageId":"1067","endLine":126,"endColumn":14},{"ruleId":"1046","severity":2,"message":"1047","line":83,"column":20,"nodeType":"1048","messageId":"1049","endLine":83,"endColumn":34},{"ruleId":"1040","severity":2,"message":"1153","line":21,"column":20,"nodeType":"1042","messageId":"1043","endLine":21,"endColumn":40},{"ruleId":"1040","severity":2,"message":"1153","line":29,"column":4,"nodeType":"1042","messageId":"1043","endLine":29,"endColumn":24},{"ruleId":"1040","severity":2,"message":"1153","line":34,"column":17,"nodeType":"1042","messageId":"1043","endLine":34,"endColumn":37},{"ruleId":"1040","severity":2,"message":"1153","line":39,"column":28,"nodeType":"1042","messageId":"1043","endLine":39,"endColumn":48},"no-undef","'React$Component' is not defined.","Identifier","undef","'React$Node' is not defined.","'React$Element' is not defined.","no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn","no-unused-vars","'name' is defined but never used.","unusedVar","'React$ElementType' is not defined.","'React$Ref' is not defined.","no-useless-escape","Unnecessary escape character: \\/.","Literal","unnecessaryEscape",["1154","1155"],"'children' is defined but never used.","'element' is defined but never used.","'props' is defined but never used.","'Iterator' is not defined.","no-empty","Empty block statement.","BlockStatement","unexpected","no-misleading-character-class","Unexpected combined character in character class.","NewExpression","combiningClass","Unnecessary escape character: \\-.",["1156","1157"],"Unnecessary escape character: \\:.",["1158","1159"],"no-control-regex","Unexpected control character(s) in regular expression: \\x00.","'condition' is defined but never used.","'format' is defined but never used.","'a' is defined but never used.","'b' is defined but never used.","'c' is defined but never used.","'d' is defined but never used.","'e' is defined but never used.","'f' is defined but never used.","'React' is defined but never used.","'publicInstance' is defined but never used.","'callback' is defined but never used.","'callerName' is defined but never used.","'completeState' is defined but never used.","'partialState' is defined but never used.","react-internal/warning-and-invariant-args","Definition for rule 'react-internal/warning-and-invariant-args' was not found.","'targetInst' is defined but never used.","getter-return","Expected to return a value in method 'get'.","FunctionExpression","expected","no-case-declarations","Unexpected lexical declaration in case block.","VariableDeclaration","'$Shape' is not defined.","'TimeoutID' is not defined.","'fiber' is defined but never used.",["1160","1161"],"Unexpected control character(s) in regular expression: \\x00, \\x1f.",["1162","1163"],"'componentName' is defined but never used.","'ToStringValue' is not defined.","'value' is defined but never used.","no-constant-condition","Unexpected constant condition.","'func' is defined but never used.","'context' is defined but never used.","'renderExpirationTime' is defined but never used.","'invariant' is defined but never used.","'nativeEvent' is defined but never used.","'expirationTime' is defined but never used.","'ReactPriorityLevel' is not defined.","'suspendedTime' is defined but never used.","'instance' is defined but never used.","'needsVisibilityToggle' is defined but never used.","'isHidden' is defined but never used.","'workInProgress' is defined but never used.","no-unused-labels","'branches:' is defined but never used.","unused",{"range":"1164","text":"1165"},{"range":"1166","text":"1165"},"'current' is defined but never used.","'type' is defined but never used.","'newProps' is defined but never used.","'rootContainerInstance' is defined but never used.","'oldText' is defined but never used.","'newText' is defined but never used.","'T' is not defined.","'S' is not defined.","'I' is not defined.","'A' is not defined.","'initialArg' is defined but never used.","'init' is defined but never used.","'initialValue' is defined but never used.","'formatterFn' is defined but never used.","'child' is defined but never used.","'Iterable' is not defined.","'capturedError' is defined but never used.","'containerInfo' is defined but never used.","'hostContext' is defined but never used.","'internalInstanceHandle' is defined but never used.","'parentContainer' is defined but never used.","'parentInstance' is defined but never used.","'args' is defined but never used.","'DOMTopLevelEventType' is not defined.",{"messageId":"1167","fix":"1168","desc":"1169"},{"messageId":"1170","fix":"1171","desc":"1172"},{"messageId":"1167","fix":"1173","desc":"1169"},{"messageId":"1170","fix":"1174","desc":"1172"},{"messageId":"1167","fix":"1175","desc":"1169"},{"messageId":"1170","fix":"1176","desc":"1172"},{"messageId":"1167","fix":"1177","desc":"1169"},{"messageId":"1170","fix":"1178","desc":"1172"},{"messageId":"1167","fix":"1179","desc":"1169"},{"messageId":"1170","fix":"1180","desc":"1172"},[5951,5961],"",[9126,9136],"removeEscape",{"range":"1181","text":"1165"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"1182","text":"1183"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"1184","text":"1165"},{"range":"1185","text":"1183"},{"range":"1186","text":"1165"},{"range":"1187","text":"1183"},{"range":"1188","text":"1165"},{"range":"1189","text":"1183"},{"range":"1190","text":"1165"},{"range":"1191","text":"1183"},[1759,1760],[1759,1759],"\\",[10872,10873],[10872,10872],[10874,10875],[10874,10874],[235,236],[235,235],[1202,1203],[1202,1202]]